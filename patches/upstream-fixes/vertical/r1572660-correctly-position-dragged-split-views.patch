From 1f27b5affc2d01528b774141358082cd6324fa5c Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@google.com>
Date: Wed, 21 Jan 2026 17:10:27 -0800
Subject: [PATCH] Correctly position dragged vertical split views

Updates VerticalTabDragHandler to consider tabs in a split, allowing the
split tab header to be correctly laid out during the drag.

Change-Id: Ibbf2a407f28275d264b554401496e9f1095e7c2c
Bug: 476084253
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7496993
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Reviewed-by: David Pennington <dpenning@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1572660}
---

--- a/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
+++ b/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
@@ -1725,6 +1725,11 @@ std::vector<TabSlotView*> TabDragControl
   const TabStripModel* const model = context->GetTabStripModel();
   std::vector<TabSlotView*> views;
   for (const TabDragData& tab_drag_datum : drag_data_.tab_drag_data_) {
+    // TODO(crbug.com/477230662): Ideally, split tabs would also be directly
+    // compatible with `TabDragController`, rather than relying on the tab
+    // selection model to achieve expected behavior. As is, this is incompatible
+    // with the vertical tab strip because the split tabs are contained within
+    // a single dedicated `VerticalSplitTabView`.
     if (tab_drag_datum.view_type == TabSlotView::ViewType::kTab) {
       TabSlotView* tab_view =
           context->GetTabForContents(tab_drag_datum.contents);
--- a/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.h
+++ b/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.h
@@ -216,6 +216,12 @@ class TabDragController : public views::
   //   kDraggingUsingSystemDnD state for the first time.
   void SetDragLoopDoneCallbackForTesting(base::OnceClosure callback);
 
+  // TabDragTarget::DragController
+  std::unique_ptr<tabs::TabModel> DetachTabAtForInsertion(
+      int drag_idx) override;
+  const DragSessionData& GetSessionData() const override;
+  const TabDragContext* GetAttachedContext() const override;
+
  private:
   friend class TabDragControllerTest;
 
@@ -282,12 +288,6 @@ class TabDragController : public views::
                              const gfx::Rect& new_bounds) override;
   void OnWidgetDestroyed(views::Widget* widget) override;
 
-  // TabDragTarget::DragController
-  std::unique_ptr<tabs::TabModel> DetachTabAtForInsertion(
-      int drag_idx) override;
-  const DragSessionData& GetSessionData() const override;
-  const TabDragContext* GetAttachedContext() const override;
-
   // Forget the source tabstrip. It doesn't exist any more, so it doesn't
   // make sense to insert dragged tabs back into it if the drag is reverted.
   void OnSourceTabStripEmpty();
--- a/chrome/browser/ui/views/tabs/vertical/tab_collection_node.cc
+++ b/chrome/browser/ui/views/tabs/vertical/tab_collection_node.cc
@@ -181,6 +181,12 @@ TabCollectionNode* TabCollectionNode::Ge
 
 TabCollectionNode* TabCollectionNode::GetParentNodeForHandle(
     const tabs::TabCollectionNodeHandle& handle) {
+  return const_cast<TabCollectionNode*>(
+      std::as_const(*this).GetParentNodeForHandle(handle));
+}
+
+const TabCollectionNode* TabCollectionNode::GetParentNodeForHandle(
+    const tabs::TabCollectionNodeHandle& handle) const {
   for (auto& child_node : children_) {
     if (child_node->GetHandle() == handle) {
       return this;
--- a/chrome/browser/ui/views/tabs/vertical/tab_collection_node.h
+++ b/chrome/browser/ui/views/tabs/vertical/tab_collection_node.h
@@ -60,6 +60,8 @@ class TabCollectionNode {
       const tabs::TabCollectionNodeHandle& handle);
   TabCollectionNode* GetParentNodeForHandle(
       const tabs::TabCollectionNodeHandle& handle);
+  const TabCollectionNode* GetParentNodeForHandle(
+      const tabs::TabCollectionNodeHandle& handle) const;
 
   // Creates a new child and adds it at model_index. If |perform_initialization|
   // is true, then the entire subtree of the node data will be constructed as
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -134,7 +134,7 @@ void VerticalDraggedTabsContainer::Initi
   // Move each dragged tab to the origin position. Transformations will be used
   // to render them during the drag.
   for (TabSlotView* slot_view : controller.GetSessionData().attached_views()) {
-    auto* tab_view = VerticalTabDragHandler::ViewFromTabSlot(slot_view);
+    auto* tab_view = GetDragHandler().ViewFromTabSlot(slot_view);
     CHECK(tab_view);
     if (tab_view->parent() == base::to_address(host_view_)) {
       dragging_views_.insert(tab_view);
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -66,14 +66,6 @@ ui::mojom::DragEventSource EventSourceFr
 
 }  // namespace
 
-// static
-views::View* VerticalTabDragHandler::ViewFromTabSlot(TabSlotView* view) {
-  if (auto* shim_view = views::AsViewClass<TabSlotShimView>(view)) {
-    return shim_view->parent();
-  }
-  return nullptr;
-}
-
 VerticalTabDragHandlerImpl::VerticalTabDragHandlerImpl(
     TabStripModel& tab_strip_model,
     TabCollectionNode& root_node)
@@ -102,7 +94,6 @@ void VerticalTabDragHandlerImpl::Initial
     TabCollectionNode* selected_node =
         root_node_->GetNodeForHandle(tab->GetHandle());
     CHECK(selected_node);
-    dragged_tabs_.insert(selected_node);
     auto* shim_view = &GetOrCreateShimViewForNode(*selected_node);
     shim_view->SetBoundsRect(selected_node->view()->GetLocalBounds());
     dragged_views[next_dragged_view_idx++] = shim_view;
@@ -118,7 +109,7 @@ void VerticalTabDragHandlerImpl::Initial
           tab_strip_model_->selection_model().GetListSelectionModel(),
           EventSourceFromEvent(event)) ==
       TabDragController::Liveness::kDeleted) {
-    dragged_tabs_.clear();
+    ResetDragState();
   }
 }
 
@@ -153,10 +144,6 @@ void VerticalTabDragHandlerImpl::HandleD
     // first iteration of the drag loop).
     return;
   }
-  if (dragged_tabs_.contains(&node)) {
-    return;
-  }
-  CHECK(!dragged_tabs_.empty());
   switch (node.type()) {
     case TabCollectionNode::Type::TAB:
       HandleTabDragOverTab(node);
@@ -276,8 +263,40 @@ TabDragContext* VerticalTabDragHandlerIm
 }
 
 bool VerticalTabDragHandlerImpl::IsViewDragging(const views::View& view) const {
-  return std::ranges::find(dragged_tabs_, &view, &TabCollectionNode::view) !=
-         dragged_tabs_.end();
+  if (!drag_controller_) {
+    return false;
+  }
+  for (TabSlotView* slot_view :
+       drag_controller_->GetSessionData().attached_views()) {
+    if (&view == ViewFromTabSlot(slot_view)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+views::View* VerticalTabDragHandlerImpl::ViewFromTabSlot(
+    TabSlotView* view) const {
+  auto* shim_view = views::AsViewClass<TabSlotShimView>(view);
+  CHECK(shim_view);
+
+  const TabCollectionNode& node = shim_view->node();
+
+  // If the dragged tab view is in a split, return the split's tab view
+  // instead.
+  if (node.type() == TabCollectionNode::Type::TAB) {
+    const auto* tab = std::get<const tabs::TabInterface*>(node.GetNodeData());
+    CHECK(tab);
+    if (tab->IsSplit()) {
+      const TabCollectionNode* split_node =
+          root_node_->GetParentNodeForHandle(tab->GetHandle());
+      CHECK(split_node);
+      CHECK_EQ(split_node->type(), TabCollectionNode::Type::SPLIT);
+      return split_node->view();
+    }
+  }
+
+  return node.view();
 }
 
 bool VerticalTabDragHandlerImpl::CanAcceptEvent(const ui::Event& event) {
@@ -365,9 +384,11 @@ void VerticalTabDragHandlerImpl::Started
   for (auto* view : views) {
     auto* shim_view = views::AsViewClass<TabSlotShimView>(view);
     CHECK(shim_view);
-    dragged_tabs_.insert(&shim_view->node());
-    shim_view->parent()->SetPaintToLayer();
-    shim_view->parent()->layer()->SetFillsBoundsOpaquely(false);
+
+    views::View* dragged_view = ViewFromTabSlot(shim_view);
+    CHECK(dragged_view);
+    dragged_view->SetPaintToLayer();
+    dragged_view->layer()->SetFillsBoundsOpaquely(false);
 
     // Update the height to use preferred size because newly added tabs will
     // animate in from 0, which affects the window offset for newly-detached
@@ -378,15 +399,14 @@ void VerticalTabDragHandlerImpl::Started
   }
 }
 
-void VerticalTabDragHandlerImpl::DraggedTabsDetached() {
-  dragged_tabs_.clear();
-}
+void VerticalTabDragHandlerImpl::DraggedTabsDetached() {}
 
 void VerticalTabDragHandlerImpl::StoppedDragging() {
   for (auto& [_, shim_view] : shim_views_) {
-    shim_view->parent()->DestroyLayer();
+    views::View* dragged_view = ViewFromTabSlot(shim_view);
+    CHECK(dragged_view);
+    dragged_view->DestroyLayer();
   }
-  dragged_tabs_.clear();
 }
 
 void VerticalTabDragHandlerImpl::SetDragControllerCallbackForTesting(
@@ -431,12 +451,10 @@ void VerticalTabDragHandlerImpl::OnNodeW
   CHECK(it != shim_views_.end());
   auto view = node.view()->RemoveChildViewT(it->second);
   shim_views_.erase(it);
-  dragged_tabs_.erase(&node);
 }
 
 void VerticalTabDragHandlerImpl::ResetDragState() {
   drag_controller_.reset();
-  dragged_tabs_.clear();
 }
 
 BEGIN_METADATA(VerticalTabDragHandlerImpl)
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
@@ -47,7 +47,7 @@ class VerticalTabDragHandler {
   // For vertical tabs, `TabSlotView` doesn't represent the actual tab
   // view. This method converts `view` to its actual tab view, or nullptr
   // if this handler doesn't manage it.
-  static views::View* ViewFromTabSlot(TabSlotView* view);
+  virtual views::View* ViewFromTabSlot(TabSlotView* view) const = 0;
 };
 
 // Implements a minimal drag context to interact with the central
@@ -75,6 +75,7 @@ class VerticalTabDragHandlerImpl : publi
   void HandleDraggedTabsOverNode(const TabCollectionNode& node) override;
   TabDragContext* GetDragContext() override;
   bool IsViewDragging(const views::View& view) const override;
+  views::View* ViewFromTabSlot(TabSlotView* view) const override;
 
   // TabDragContext
   bool CanAcceptEvent(const ui::Event& event) override;
@@ -127,10 +128,6 @@ class VerticalTabDragHandlerImpl : publi
   // Null if this handler is not managing a dragging session.
   std::unique_ptr<TabDragController> drag_controller_ = nullptr;
 
-  // The tabs currently being dragged as part of a dragging session managed by
-  // this handler.
-  std::set<raw_ptr<const TabCollectionNode>> dragged_tabs_;
-
   // A mapping from nodes to their `TabSlotView` shims, used for compatibility
   // with the core dragging system.
   std::map<raw_ptr<const TabCollectionNode>, raw_ptr<TabSlotView>> shim_views_;
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
@@ -357,6 +357,52 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
 // that if a layout cycle hasn't happened between drag loop iterations then
 // the tab strip model updates might bounce. This should be fixed once a more
 // robust hit-testing approach is implemented.
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest, DISABLED_DragSplitTabs) {
+  DEFINE_LOCAL_ELEMENT_IDENTIFIER_VALUE(kFourthTab);
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      AddInstrumentedTab(kFourthTab, GURL(chrome::kChromeUIVersionURL), 3),
+      Do([&]() {
+        tab_strip_model->ActivateTabAt(
+            2, TabStripUserGestureDetails(
+                   TabStripUserGestureDetails::GestureType::kOther));
+        tab_strip_model->AddToNewSplit(
+            {3}, {}, split_tabs::SplitTabCreatedSource::kTabContextMenu);
+      }),
+      PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
+      WaitForState(kTabOrderPoller, URLs({
+                                        url::kAboutBlankURL,
+                                        chrome::kChromeUIBookmarksURL,
+                                        chrome::kChromeUISettingsURL,
+                                        chrome::kChromeUIVersionURL,
+                                    })),
+      DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      PollState(kDragStatePoller, GetDragActive()), MoveMouseToTabAsync(0),
+      WaitForState(kTabOrderPoller, URLs({
+                                        chrome::kChromeUISettingsURL,
+                                        chrome::kChromeUIVersionURL,
+                                        url::kAboutBlankURL,
+                                        chrome::kChromeUIBookmarksURL,
+                                    })),
+      MoveMouseToTabAsync(2),
+      WaitForState(kTabOrderPoller, URLs({
+                                        url::kAboutBlankURL,
+                                        chrome::kChromeUISettingsURL,
+                                        chrome::kChromeUIVersionURL,
+                                        chrome::kChromeUIBookmarksURL,
+                                    })),
+      ReleaseMouseAsync());
+}
+
+// TODO(crbug.com/476509652): This test flakes because drag handling hit tests
+// against the view's position in the layout (skipping animation), which means
+// that if a layout cycle hasn't happened between drag loop iterations then
+// the tab strip model updates might bounce. This should be fixed once a more
+// robust hit-testing approach is implemented.
 IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest, DISABLED_DragOverSplit) {
   DEFINE_LOCAL_ELEMENT_IDENTIFIER_VALUE(kFourthTab);
   TabStripModel* tab_strip_model = browser()->GetTabStripModel();
