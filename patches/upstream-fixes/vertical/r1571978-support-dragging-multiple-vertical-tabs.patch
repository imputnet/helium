From c453a74637034c395f8a7df7d12645cb6ecedce1 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@google.com>
Date: Tue, 20 Jan 2026 17:11:52 -0800
Subject: [PATCH] Support dragging multiple vertical tabs

This CL implements drag handler support for dragging multiple selected
tabs. Note, this doesn't handle laying out the multiple dragged tabs,
which will be handled separately.

Bug: 476084253
Change-Id: I679d0e8724df6000b03e3f203c3b7f28e4fbd9a4
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7490133
Reviewed-by: David Pennington <dpenning@chromium.org>
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1571978}
---

--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -128,6 +128,7 @@ void VerticalDraggedTabsContainer::OnVie
       base::to_address(host_view_), last_drag_point_in_screen_));
 }
 
+// TODO(crbug.com/476084253): Animate selected dragged tabs into the container.
 void VerticalDraggedTabsContainer::InitializeDragState(
     TabDragTarget::DragController& controller) {
   // Move each dragged tab to the origin position. Transformations will be used
@@ -149,6 +150,9 @@ void VerticalDraggedTabsContainer::Reset
   dragging_views_.clear();
 }
 
+// TODO(crbug.com/476084253): Support laying out with multiple dragged tabs.
+// Currently, all selected tabs are stacked on each other, but still block out
+// the space at their expected tab slot.
 void VerticalDraggedTabsContainer::UpdateDraggingViewTransforms(
     const gfx::Point& point_in_container) {
   int drag_clamp_min_y = GetMinYForDragToClamp();
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -88,16 +88,35 @@ void VerticalTabDragHandlerImpl::Initial
   ResetDragState();
   drag_controller_ = std::make_unique<TabDragController>();
 
-  // TODO(crbug.com/439963720): Support dragging multiple tabs.
-  dragged_tabs_.insert(&node);
+  const auto& selected_tabs =
+      tab_strip_model_->selection_model().selected_tabs();
+
+  std::vector<TabSlotView*> dragged_views(selected_tabs.size());
+  size_t next_dragged_view_idx = 0;
+
+  TabSlotView* source_dragged_view = nullptr;
+
+  // Track the node and build a shim view for each selected node.
+  for (tabs::TabInterface* tab : selected_tabs) {
+    CHECK(tab);
+    TabCollectionNode* selected_node =
+        root_node_->GetNodeForHandle(tab->GetHandle());
+    CHECK(selected_node);
+    dragged_tabs_.insert(selected_node);
+    auto* shim_view = &GetOrCreateShimViewForNode(*selected_node);
+    shim_view->SetBoundsRect(selected_node->view()->GetLocalBounds());
+    dragged_views[next_dragged_view_idx++] = shim_view;
+    if (selected_node == &node) {
+      source_dragged_view = shim_view;
+    }
+  }
+  CHECK(source_dragged_view);
+
   const gfx::Point offset_from_source = event.location();
-  ui::ListSelectionModel selection_model;
-  TabSlotView& dragged_view = GetOrCreateShimViewForNode(node);
-  dragged_view.SetBoundsRect(node.view()->GetLocalBounds());
-
-  if (drag_controller_->Init(this, &dragged_view, {&dragged_view},
-                             offset_from_source, std::move(selection_model),
-                             EventSourceFromEvent(event)) ==
+  if (drag_controller_->Init(
+          this, source_dragged_view, dragged_views, offset_from_source,
+          tab_strip_model_->selection_model().GetListSelectionModel(),
+          EventSourceFromEvent(event)) ==
       TabDragController::Liveness::kDeleted) {
     dragged_tabs_.clear();
   }
@@ -137,8 +156,7 @@ void VerticalTabDragHandlerImpl::HandleD
   if (dragged_tabs_.contains(&node)) {
     return;
   }
-  // TODO(crbug.com/439963720): This assumes only one tab is being dragged.
-  CHECK_EQ(1u, dragged_tabs_.size());
+  CHECK(!dragged_tabs_.empty());
   switch (node.type()) {
     case TabCollectionNode::Type::TAB:
       HandleTabDragOverTab(node);
@@ -161,8 +179,16 @@ void VerticalTabDragHandlerImpl::HandleT
     const TabCollectionNode& node) {
   const auto* tab = std::get<const tabs::TabInterface*>(node.GetNodeData());
   CHECK(tab);
-  tab_strip_model_->MoveSelectedTabsTo(tab_strip_model_->GetIndexOfTab(tab),
-                                       tab->GetGroup());
+  const auto& selection_model = tab_strip_model_->selection_model();
+  int first_selected_idx =
+      *selection_model.GetListSelectionModel().selected_indices().cbegin();
+  int insertion_idx = tab_strip_model_->GetIndexOfTab(tab);
+  if (first_selected_idx <= insertion_idx) {
+    insertion_idx -= selection_model.size();
+    ++insertion_idx;
+  }
+  insertion_idx = std::clamp(insertion_idx, 0, tab_strip_model_->count() - 1);
+  tab_strip_model_->MoveSelectedTabsTo(insertion_idx, tab->GetGroup());
 }
 
 void VerticalTabDragHandlerImpl::HandleTabDragOverSplit(
@@ -342,6 +368,13 @@ void VerticalTabDragHandlerImpl::Started
     dragged_tabs_.insert(&shim_view->node());
     shim_view->parent()->SetPaintToLayer();
     shim_view->parent()->layer()->SetFillsBoundsOpaquely(false);
+
+    // Update the height to use preferred size because newly added tabs will
+    // animate in from 0, which affects the window offset for newly-detached
+    // windows.
+    gfx::Rect bounds = shim_view->node().view()->GetLocalBounds();
+    bounds.set_height(shim_view->node().view()->GetPreferredSize({}).height());
+    shim_view->SetBoundsRect(bounds);
   }
 }
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
@@ -54,7 +54,6 @@ class VerticalTabDragHandler {
 // `TabDragController`.
 // TODO(crbug.com/439963720): The following is an incremental checklist of
 // support that needs to be added:
-// - Dragging more than one tab (split tabs, tab group, multi-selection).
 // - Dragging pinned tab (split tabs, tab group, multi-selection).
 class VerticalTabDragHandlerImpl : public VerticalTabDragHandler,
                                    public TabDragContext {
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
@@ -38,6 +38,14 @@ using URL = std::string_view;
 using TabGroupURLs = std::vector<URL>;
 using URLs = std::vector<std::variant<URL, TabGroupURLs>>;
 
+int TabSelectModifier() {
+#if BUILDFLAG(IS_MAC)
+  return ui_controls::kCommand;
+#else
+  return ui_controls::kControl;
+#endif
+}
+
 // Returns a collection of URLs that correspond to the order of tabs.
 // Tab groups are added to a vector nested within the collection.
 // E.g., {A, {B, C}, D}
@@ -116,20 +124,23 @@ class VerticalTabDragHandlerTest
     });
   }
 
+  auto NameTabViewAt(std::string_view tab_name, int tab_index) {
+    return NameView(
+        tab_name, base::BindLambdaForTesting([&, tab_index]() {
+          TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+          tabs::TabInterface* tab = tab_strip_model->GetTabAtIndex(tab_index);
+          RootTabCollectionNode* root_node =
+              GetBrowserView()
+                  .vertical_tab_strip_region_view_for_testing()
+                  ->root_node_for_testing();
+          return root_node->GetNodeForHandle(tab->GetHandle())->view();
+        }));
+  }
+
   auto MoveMouseToTabAsync(int tab_index) {
     const char kTabToMoveMouseTo[] = "Tab to move mouse to";
     return Steps(
-        NameView(
-            kTabToMoveMouseTo, base::BindLambdaForTesting([&, tab_index]() {
-              TabStripModel* tab_strip_model = browser()->GetTabStripModel();
-              tabs::TabInterface* tab =
-                  tab_strip_model->GetTabAtIndex(tab_index);
-              RootTabCollectionNode* root_node =
-                  GetBrowserView()
-                      .vertical_tab_strip_region_view_for_testing()
-                      ->root_node_for_testing();
-              return root_node->GetNodeForHandle(tab->GetHandle())->view();
-            })),
+        NameTabViewAt(kTabToMoveMouseTo, tab_index),
         WithView(
             kTabToMoveMouseTo, base::BindOnce([](views::View* view) {
               const gfx::Point point = view->GetBoundsInScreen().CenterPoint();
@@ -141,6 +152,14 @@ class VerticalTabDragHandlerTest
     return Do([&]() { browser()->GetTabStripModel()->AddToNewGroup(indices); });
   }
 
+  auto SelectTabAt(int tab_index) {
+    const char kTabToSelect[] = "Tab to select";
+    return Steps(NameTabViewAt(kTabToSelect, tab_index),
+                 MoveMouseTo(kTabToSelect),
+                 ClickMouse(ui_controls::MouseButton::LEFT, /*release=*/true,
+                            TabSelectModifier()));
+  }
+
   BrowserView& GetBrowserView() {
     BrowserView* browser_view =
         BrowserView::GetBrowserViewForBrowser(browser());
@@ -454,6 +473,123 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                         }),
                                     })),
       ReleaseMouseAsync());
+}
+
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND)
+#define MAYBE_DetachMultipleTabs DetachMultipleTabs
+#else
+#define MAYBE_DetachMultipleTabs DISABLED_DetachMultipleTabs
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest, MAYBE_DetachMultipleTabs) {
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      SelectTabAt(1),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(1); },
+          true),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(2); },
+          true),
+      DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      PollState(kBrowserCountPoller, GetBrowserCount()),
+      WaitForState(kBrowserCountPoller, 2), ReleaseMouseAsync(),
+      PollState(kDragStatePoller, GetDragActive()),
+      WaitForState(kDragStatePoller, false), Do([&]() {
+        TabStripModel* new_tab_strip_model =
+            GetLatestBrowser().GetTabStripModel();
+        ASSERT_NE(nullptr, new_tab_strip_model);
+        EXPECT_EQ(2, new_tab_strip_model->count());
+        EXPECT_EQ(GURL(chrome::kChromeUIBookmarksURL),
+                  new_tab_strip_model->GetWebContentsAt(0)->GetURL());
+        EXPECT_EQ(GURL(chrome::kChromeUISettingsURL),
+                  new_tab_strip_model->GetWebContentsAt(1)->GetURL());
+        EXPECT_EQ(1, browser()->GetTabStripModel()->count());
+      }),
+      ReleaseMouseAsync());
+}
+
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND)
+#define MAYBE_DragMultipleTabs DragMultipleTabs
+#else
+#define MAYBE_DragMultipleTabs DISABLED_DragMultipleTabs
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest, MAYBE_DragMultipleTabs) {
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      SelectTabAt(1),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(1); },
+          true),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(2); },
+          true),
+      DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      MoveMouseToTabAsync(0),
+      PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
+      WaitForState(kTabOrderPoller, URLs({
+                                        chrome::kChromeUIBookmarksURL,
+                                        chrome::kChromeUISettingsURL,
+                                        url::kAboutBlankURL,
+                                    })),
+      ReleaseMouseAsync());
+}
+
+// TODO(crbug.com/40249472): Disabled because this flakes on all platforms.
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest,
+                       DISABLED_DragMultipleTabsInGroup) {
+  DEFINE_LOCAL_ELEMENT_IDENTIFIER_VALUE(kFourthTab);
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      AddInstrumentedTab(kFourthTab, GURL(chrome::kChromeUIVersionURL), 3),
+      AddTabsToNewGroup({1}),
+      PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
+      WaitForState(kTabOrderPoller, URLs({
+                                        url::kAboutBlankURL,
+                                        TabGroupURLs({
+                                            chrome::kChromeUIBookmarksURL,
+                                        }),
+                                        chrome::kChromeUISettingsURL,
+                                        chrome::kChromeUIVersionURL,
+                                    })),
+      SelectTabAt(2),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(3); },
+          true),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(2); },
+          true),
+      DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      MoveMouseToTabAsync(1),
+      WaitForState(kTabOrderPoller, URLs({
+                                        url::kAboutBlankURL,
+                                        TabGroupURLs({
+                                            chrome::kChromeUISettingsURL,
+                                            chrome::kChromeUIVersionURL,
+                                            chrome::kChromeUIBookmarksURL,
+                                        }),
+                                    })),
+      MoveMouseToTabAsync(0),
+      WaitForState(kTabOrderPoller, URLs({
+                                        chrome::kChromeUISettingsURL,
+                                        chrome::kChromeUIVersionURL,
+                                        url::kAboutBlankURL,
+                                        TabGroupURLs({
+                                            chrome::kChromeUIBookmarksURL,
+                                        }),
+                                    })),
+      ReleaseMouseAsync());
 }
 
 // TODO(crbug.com/40249472): Disabled because this flakes on all platforms.
