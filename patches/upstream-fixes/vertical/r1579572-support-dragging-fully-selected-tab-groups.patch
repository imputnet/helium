From 48ea79950f5c8a53445636d16a8e11d4585bb593 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@chromium.org>
Date: Wed, 04 Feb 2026 10:09:02 -0800
Subject: [PATCH] Support dragging fully selected vertical tab groups

Ensures that if all tabs in a group are fully selected when initiating
the drag, the entire group will be dragged. Prior to this change, the
drag would cause a crash.

Change-Id: Ib7c60753a95df3de28a6194812e72265533b1b25
Fixed: 476084254
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7541753
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Reviewed-by: David Pennington <dpenning@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1579572}
---

--- a/chrome/browser/ui/views/tabs/vertical/tab_collection_node.cc
+++ b/chrome/browser/ui/views/tabs/vertical/tab_collection_node.cc
@@ -188,9 +188,15 @@ void TabCollectionNode::Deinitialize() {
   }
 }
 
-// TODO(crbug.com/450976282): Consider having a map at the root level.
 TabCollectionNode* TabCollectionNode::GetNodeForHandle(
     const tabs::TabCollectionNodeHandle& handle) {
+  return const_cast<TabCollectionNode*>(
+      std::as_const(*this).GetNodeForHandle(handle));
+}
+
+// TODO(crbug.com/450976282): Consider having a map at the root level.
+const TabCollectionNode* TabCollectionNode::GetNodeForHandle(
+    const tabs::TabCollectionNodeHandle& handle) const {
   if (GetHandle() == handle) {
     return this;
   }
--- a/chrome/browser/ui/views/tabs/vertical/tab_collection_node.h
+++ b/chrome/browser/ui/views/tabs/vertical/tab_collection_node.h
@@ -61,6 +61,8 @@ class TabCollectionNode {
   // Returns nullptr if no such node exists.
   TabCollectionNode* GetNodeForHandle(
       const tabs::TabCollectionNodeHandle& handle);
+  const TabCollectionNode* GetNodeForHandle(
+      const tabs::TabCollectionNodeHandle& handle) const;
   TabCollectionNode* GetParentNodeForHandle(
       const tabs::TabCollectionNodeHandle& handle);
   const TabCollectionNode* GetParentNodeForHandle(
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -28,7 +28,8 @@
 
 namespace {
 
-// Returns drag data sorted by index in the source tab strip model.
+// Returns drag data sorted by index in the source tab strip model. Data without
+// a source index a placed at the end.
 // TODO(crbug.com/476084253): Update `DragSessionData` to ensure the tab drag
 // data is already sorted.
 std::vector<TabDragData> GetSortedTabDragData(
@@ -36,6 +37,12 @@ std::vector<TabDragData> GetSortedTabDra
   std::vector<TabDragData> drag_data = session_data.tab_drag_data_;
   std::sort(drag_data.begin(), drag_data.end(),
             [](const TabDragData& a, const TabDragData& b) {
+              if (!a.source_model_index.has_value()) {
+                return false;
+              }
+              if (!b.source_model_index.has_value()) {
+                return true;
+              }
               return a.source_model_index < b.source_model_index;
             });
   return drag_data;
@@ -174,6 +181,9 @@ void VerticalDraggedTabsContainer::Build
       GetSourceViewOffsetFromMouse(*source_dragged_view, session_data));
 
   for (const auto& datum : GetSortedTabDragData(session_data)) {
+    if (!datum.attached_view) {
+      continue;
+    }
     auto* dragging_view = GetDragHandler().ViewFromTabSlot(datum.attached_view);
     CHECK(dragging_view);
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -144,6 +144,15 @@ VerticalTabDragHandlerImpl::GetDragInitD
       std::get<const tabs::TabInterface*>(source_node.GetNodeData());
   CHECK(source_tab);
 
+  if (!source_tab->IsPinned()) {
+    // A TabSlotView must be added for each dragged group, in addition to the
+    // tabs themselves.
+    auto dragged_groups = GetFullySelectedGroups(selected_tabs);
+    drag_init_data.dragged_views.insert(drag_init_data.dragged_views.end(),
+                                        dragged_groups.begin(),
+                                        dragged_groups.end());
+  }
+
   // Track the node and build a shim view for each selected node.
   for (tabs::TabInterface* tab : selected_tabs) {
     // Filter out selections that don't match the pinned state of the latest
@@ -188,6 +197,29 @@ VerticalTabDragHandlerImpl::GetDragInitD
   return drag_init_data;
 }
 
+std::vector<TabSlotView*> VerticalTabDragHandlerImpl::GetFullySelectedGroups(
+    const std::unordered_set<raw_ptr<tabs::TabInterface>>& selected_tabs) {
+  std::map<tab_groups::TabGroupId, int> dragged_group_tab_counts;
+  for (tabs::TabInterface* tab : selected_tabs) {
+    if (auto group_id = tab->GetGroup()) {
+      dragged_group_tab_counts[*group_id]++;
+    }
+  }
+
+  std::vector<TabSlotView*> selected_groups;
+  for (const auto& [group_id, dragged_tab_count] : dragged_group_tab_counts) {
+    const auto* group = tab_strip_model_->group_model()->GetTabGroup(group_id);
+    CHECK(group);
+    if (group->tab_count() == dragged_tab_count) {
+      auto* selected_node = GetNodeForTabGroup(group_id);
+      auto& slot_view = GetOrCreateSlotViewForNode(*selected_node);
+      slot_view.SetBoundsRect(selected_node->view()->GetLocalBounds());
+      selected_groups.push_back(&slot_view);
+    }
+  }
+  return selected_groups;
+}
+
 bool VerticalTabDragHandlerImpl::ContinueDrag(views::View& event_source_view,
                                               const ui::MouseEvent& event) {
   if (!drag_controller_) {
@@ -352,10 +384,12 @@ void VerticalTabDragHandlerImpl::HandleT
     return;
   }
 
-  if (GetDraggingGroupHeaderId().has_value()) {
+  if (IsDraggingGroups()) {
     return;
   }
 
+  // TODO(crbug.com/439963720): Re-evaluate whether this logic is needed once drag
+  // hit-testing is improved.
   const tabs::TabInterface* selected_tab =
       *tab_strip_model_->selection_model().selected_tabs().cbegin();
 
@@ -395,6 +429,13 @@ bool VerticalTabDragHandlerImpl::IsDragg
                      [](const auto& tab_data) { return tab_data.pinned; });
 }
 
+bool VerticalTabDragHandlerImpl::IsDraggingGroups() const {
+  if (!drag_controller_) {
+    return false;
+  }
+  return !drag_controller_->GetSessionData().dragging_groups.empty();
+}
+
 std::optional<tab_groups::TabGroupId>
 VerticalTabDragHandlerImpl::GetDraggingGroupHeaderId() const {
   return drag_controller_ ? drag_controller_->GetSessionData().group_header_id()
@@ -403,17 +444,29 @@ VerticalTabDragHandlerImpl::GetDraggingG
 
 views::View* VerticalTabDragHandlerImpl::ViewFromTabSlot(
     TabSlotView* view) const {
+  CHECK(drag_controller_);
   auto* slot_view = views::AsViewClass<VerticalTabSlotView>(view);
   CHECK(slot_view);
 
   const TabCollectionNode& node = slot_view->node();
 
-  // If the dragged tab view is in a split, return the split's tab view
-  // instead.
   if (node.type() == TabCollectionNode::Type::TAB) {
     const auto* tab = std::get<const tabs::TabInterface*>(node.GetNodeData());
     CHECK(tab);
+
+    if (auto group_id = tab->GetGroup();
+        group_id && drag_controller_->GetSessionData().dragging_groups.contains(
+                        *group_id)) {
+      // If the tab belongs to a group that is being dragged, return the group's
+      // view instead.
+      const TabCollectionNode* group_node = GetNodeForTabGroup(*group_id);
+      CHECK(group_node);
+      return group_node->view();
+    }
+
     if (tab->IsSplit()) {
+      // If the dragged tab view is in a split, return the split's tab view
+      // instead.
       const TabCollectionNode* split_node =
           root_node_->GetParentNodeForHandle(tab->GetHandle());
       CHECK(split_node);
@@ -543,6 +596,7 @@ void VerticalTabDragHandlerImpl::Stopped
   if (!drag_data.group_header_drag_data_.has_value()) {
     return;
   }
+
   // Offset by 1 to account for the group header.
   const int drag_data_index =
       1 + drag_data.group_header_drag_data_->active_tab_index_within_group;
@@ -579,7 +633,13 @@ TabCollectionNode* VerticalTabDragHandle
 
 TabCollectionNode* VerticalTabDragHandlerImpl::GetNodeForTabGroup(
     const tab_groups::TabGroupId& group_id) {
-  auto* group = tab_strip_model_->group_model()->GetTabGroup(group_id);
+  return const_cast<TabCollectionNode*>(
+      std::as_const(*this).GetNodeForTabGroup(group_id));
+}
+
+const TabCollectionNode* VerticalTabDragHandlerImpl::GetNodeForTabGroup(
+    const tab_groups::TabGroupId& group_id) const {
+  const auto* group = tab_strip_model_->group_model()->GetTabGroup(group_id);
   CHECK(group);
   return root_node_->GetNodeForHandle(group->GetCollectionHandle());
 }
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
@@ -56,10 +56,8 @@ class VerticalTabDragHandler {
   // Returns true if there is an ongoing drag that includes a pinned tab.
   virtual bool IsDraggingPinnedTabs() const = 0;
 
-  // Returns the group id of the dragged group header, or null if a group
-  // header is not being dragged.
-  virtual std::optional<tab_groups::TabGroupId> GetDraggingGroupHeaderId()
-      const = 0;
+  // Returns true if there is an ongoing drag where a group is being moved.
+  virtual bool IsDraggingGroups() const = 0;
 
   // For vertical tabs, `TabSlotView` doesn't represent the actual tab
   // view. This method converts `view` to its actual tab view, or nullptr
@@ -95,8 +93,7 @@ class VerticalTabDragHandlerImpl : publi
   TabDragContext* GetDragContext() override;
   bool IsViewDragging(const views::View& view) const override;
   bool IsDraggingPinnedTabs() const override;
-  std::optional<tab_groups::TabGroupId> GetDraggingGroupHeaderId()
-      const override;
+  bool IsDraggingGroups() const override;
   views::View* ViewFromTabSlot(TabSlotView* view) const override;
 
   // TabDragContext
@@ -144,9 +141,13 @@ class VerticalTabDragHandlerImpl : publi
   DragInitData GetDragInitDataForTabDrag(TabCollectionNode& source_node);
   DragInitData GetDragInitDataForGroupHeaderDrag(
       TabCollectionNode& source_node);
+  std::vector<TabSlotView*> GetFullySelectedGroups(
+      const std::unordered_set<raw_ptr<tabs::TabInterface>>& selected_tabs);
 
   TabCollectionNode* GetNodeForContents(content::WebContents* contents);
   TabCollectionNode* GetNodeForTabGroup(const tab_groups::TabGroupId& group_id);
+  const TabCollectionNode* GetNodeForTabGroup(
+      const tab_groups::TabGroupId& group_id) const;
 
   // Creates a `TabSlotView` for `node`, used for compatibility with the
   // core dragging system. The created slot view is cached in `slot_views_`.
@@ -166,6 +167,10 @@ class VerticalTabDragHandlerImpl : publi
       const TabCollectionNode& node,
       std::optional<DragPositionHint> position_hint);
 
+  // Returns the group id of the dragged group header, or null if the drag
+  // was not initiated by a group header.
+  std::optional<tab_groups::TabGroupId> GetDraggingGroupHeaderId() const;
+
   const raw_ref<TabStripModel> tab_strip_model_;
   const raw_ref<TabCollectionNode> root_node_;
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
@@ -186,11 +186,11 @@ void VerticalUnpinnedTabContainerView::H
   } else if (auto* group_view =
                  views::AsViewClass<VerticalTabGroupView>(view_at_point)) {
     // Groups themselves are a drag target except when they are collapsed or
-    // if we are in header drag which are the only cases we handle here.
+    // if we are dragging groups, which are the only cases we handle here.
     if (group_view->IsCollapsed()) {
       node = group_view->collection_node();
-    } else if (GetDragHandler().GetDraggingGroupHeaderId().has_value()) {
-      // For header drag check if the point overlaps with the group's header.
+    } else if (GetDragHandler().IsDraggingGroups()) {
+      // For group drag check if the point overlaps with the group's header.
       auto* group_layout = target_layout.GetLayoutFor(group_view);
       CHECK(group_layout);
       if (gfx::Point point_in_group =
@@ -210,7 +210,7 @@ void VerticalUnpinnedTabContainerView::H
 VerticalDraggedTabsContainer&
 VerticalUnpinnedTabContainerView::GetTabDragTarget(
     const gfx::Point& point_in_screen) {
-  if (GetDragHandler().GetDraggingGroupHeaderId().has_value()) {
+  if (GetDragHandler().IsDraggingGroups()) {
     // Don't consider other tab group views as a drag target if we're dragging
     // a group header already.
     return *this;
--- a/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
+++ b/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
@@ -1395,9 +1395,8 @@ void TabDragController::AttachToNewConte
   // re-attached.
   MaybeResumeTrackingSavedTabGroup();
 
-  AttachImpl();
-
   attached_context_->OwnDragController(std::move(controller));
+  AttachImpl();
 }
 
 void TabDragController::AttachImpl() {
--- a/chrome/browser/ui/views/tabs/vertical/vertical_split_tab_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_split_tab_view.cc
@@ -171,10 +171,20 @@ void VerticalSplitTabView::OnDataChanged
 }
 
 void VerticalSplitTabView::UpdateBorder() {
+  if (!collection_node_) {
+    SetBorder(nullptr);
+    return;
+  }
+
   const tabs::TabCollection* tab_collection =
       std::get<const tabs::TabCollection*>(collection_node_->GetNodeData());
   const std::vector<tabs::TabInterface*> tabs =
       tab_collection->GetTabsRecursive();
+  if (tabs.empty()) {
+    SetBorder(nullptr);
+    return;
+  }
+
   if (tabs[0]->IsPinned()) {
     const bool is_frame_active =
         GetWidget() ? GetWidget()->ShouldPaintAsActive() : true;
