From 9d8cc478a758d31c2e2d3bb5d05a2ead6b722438 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@chromium.org>
Date: Mon, 26 Jan 2026 20:07:24 -0800
Subject: [PATCH] Add handling for dragging pinned vertical tabs

VerticalPinnedTabContainer is updated to extend
VerticalDraggedTabsContainer, and VerticalDraggedTabsContainer is
updated to optionally handle horizontal drag movements.

VerticalTabStripRegionView::GetDragTarget is also updated to return the
correct drag container according to whether the drag contains pinned
tabs.

Bug: 476081516
Change-Id: I5c5c98aa94e5badba8cbe34338407fb98ac019b2
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7507855
Reviewed-by: David Pennington <dpenning@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1574955}
---

--- a/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.cc
@@ -25,6 +25,7 @@
 #include "chrome/browser/ui/views/frame/top_container_background.h"
 #include "chrome/browser/ui/views/tabs/vertical/root_tab_collection_node.h"
 #include "chrome/browser/ui/views/tabs/vertical/tab_collection_node.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_bottom_container.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_controller.h"
@@ -119,7 +120,7 @@ VerticalTabStripRegionView::~VerticalTab
   tab_strip_controller_.reset();
 
   if (drag_handler_) {
-    auto handler = RemoveChildViewT(drag_handler_);
+    auto handler = RemoveChildViewT(drag_handler_->GetDragContext());
     drag_handler_ = nullptr;
   }
 }
@@ -189,7 +190,9 @@ void VerticalTabStripRegionView::ResetTa
   tab_strip_controller_.reset();
 
   CHECK(drag_handler_);
-  RemoveChildViewT(std::exchange(drag_handler_, nullptr));
+  auto* drag_handler = drag_handler_.get();
+  drag_handler_ = nullptr;
+  RemoveChildViewT(drag_handler->GetDragContext());
 
   root_node_.reset();
 }
@@ -303,7 +306,7 @@ views::View* VerticalTabStripRegionView:
 }
 
 TabDragContext* VerticalTabStripRegionView::GetDragContext() {
-  return drag_handler_.get();
+  return drag_handler_->GetDragContext();
 }
 
 std::optional<BrowserRootView::DropIndex>
@@ -517,13 +520,17 @@ TabDragTarget* VerticalTabStripRegionVie
   if (!drag_handler_) {
     return nullptr;
   }
+  if (!tab_strip_view_->GetBoundsInScreen().Contains(point_in_screen)) {
+    return nullptr;
+  }
 
-  VerticalUnpinnedTabContainerView* container = GetUnpinnedTabsContainer();
-  CHECK(container);
-  if (container->GetBoundsInScreen().Contains(point_in_screen)) {
-    return &container->GetTabDragTarget(point_in_screen);
+  // Note: if the drag has not attached to this tab strip yet, it doesn't matter
+  // which container is used because the first drag loop iteration just attaches
+  // it.
+  if (drag_handler_->IsDraggingPinnedTabs()) {
+    return &GetPinnedTabsContainer()->GetTabDragTarget(point_in_screen);
   }
-  return nullptr;
+  return &GetUnpinnedTabsContainer()->GetTabDragTarget(point_in_screen);
 }
 
 BEGIN_METADATA(VerticalTabStripRegionView)
--- a/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.h
+++ b/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.h
@@ -167,7 +167,7 @@ class VerticalTabStripRegionView final :
 
   // The drag handler is a view (required for capturing mouse inputs during
   // a drag loop) owned by the tab strip's View.
-  raw_ptr<TabDragContext> drag_handler_ = nullptr;
+  raw_ptr<VerticalTabDragHandler> drag_handler_ = nullptr;
 
   std::unique_ptr<VerticalTabStripController> tab_strip_controller_;
   std::unique_ptr<RootTabCollectionNode> root_node_;
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -7,6 +7,7 @@
 #include "base/callback_list.h"
 #include "base/containers/flat_set.h"
 #include "base/types/to_address.h"
+#include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/views/tabs/dragging/tab_drag_target.h"
 #include "chrome/browser/ui/views/tabs/tab_slot_view.h"
 #include "chrome/browser/ui/views/tabs/vertical/tab_collection_node.h"
@@ -23,19 +24,41 @@
 namespace {
 
 // Returns the expected Y coordinate for the view of a tab being dragged at
-// `point`. Clamps minimum to `drag_clamp_min_y`.
+// `point`. Clamps to `drag_clamp_min_y` and `drag_clamp_max_y`.
 int GetYForDraggedTab(const views::View& dragging_view,
                       const gfx::Point& point,
-                      int drag_clamp_min_y) {
-  return std::max(static_cast<float>(drag_clamp_min_y),
-                  point.y() - (dragging_view.height() * 0.5f));
+                      int drag_clamp_min_y,
+                      int drag_clamp_max_y) {
+  if (dragging_view.height() > drag_clamp_max_y - drag_clamp_min_y) {
+    return drag_clamp_min_y;
+  }
+  return std::clamp(
+      point.y() - (dragging_view.height() * 0.5f),
+      static_cast<float>(drag_clamp_min_y),
+      static_cast<float>(drag_clamp_max_y) - dragging_view.height());
+}
+
+// Returns the expected X coordinate for the view of a tab being dragged at
+// `point`. Clamps to `drag_clamp_min_x` and `drag_clamp_max_x`.
+int GetXForDraggedTab(const views::View& dragging_view,
+                      const gfx::Point& point,
+                      int drag_clamp_min_x,
+                      int drag_clamp_max_x) {
+  if (dragging_view.width() > drag_clamp_max_x - drag_clamp_min_x) {
+    return drag_clamp_min_x;
+  }
+  return std::clamp(
+      point.x() - (dragging_view.width() * 0.5f),
+      static_cast<float>(drag_clamp_min_x),
+      static_cast<float>(drag_clamp_max_x) - dragging_view.width());
 }
 
 }  // namespace
 
 VerticalDraggedTabsContainer::VerticalDraggedTabsContainer(
-    views::View& host_view)
-    : host_view_(host_view) {
+    views::View& host_view,
+    DragAxes drag_axes)
+    : host_view_(host_view), drag_axes_(drag_axes) {
   host_view_observation_.Observe(&host_view);
 }
 
@@ -45,19 +68,6 @@ VerticalDraggedTabsContainer::~VerticalD
 
 VerticalDraggedTabsContainer& VerticalDraggedTabsContainer::GetTabDragTarget(
     const gfx::Point& point_in_screen) {
-  gfx::Point point_in_container = views::View::ConvertPointFromScreen(
-      base::to_address(host_view_), point_in_screen);
-  for (views::View* child : host_view_->children()) {
-    if (!child->GetVisible() || !child->bounds().Contains(point_in_container) ||
-        dragging_views_.contains(child)) {
-      continue;
-    }
-    if (auto* group_view = views::AsViewClass<VerticalTabGroupView>(child)) {
-      if (!group_view->IsCollapsed()) {
-        return *group_view;
-      }
-    }
-  }
   return *this;
 }
 
@@ -131,6 +141,10 @@ void VerticalDraggedTabsContainer::OnVie
 // TODO(crbug.com/476084253): Animate selected dragged tabs into the container.
 void VerticalDraggedTabsContainer::InitializeDragState(
     TabDragTarget::DragController& controller) {
+  tab_strip_padding_ = GetLayoutConstant(
+      IsTabStripCollapsed()
+          ? LayoutConstant::kVerticalTabStripCollapsedPadding
+          : LayoutConstant::kVerticalTabStripUncollapsedPadding);
   // Move each dragged tab to the origin position. Transformations will be used
   // to render them during the drag.
   for (TabSlotView* slot_view : controller.GetSessionData().attached_views()) {
@@ -155,24 +169,32 @@ void VerticalDraggedTabsContainer::Reset
 // the space at their expected tab slot.
 void VerticalDraggedTabsContainer::UpdateDraggingViewTransforms(
     const gfx::Point& point_in_container) {
-  int drag_clamp_min_y = GetMinYForDragToClamp();
+  const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
   for (views::View* tab_view : dragging_views_) {
     // Use a transformation to render the dragged views, offset from the
     // container's origin.
     gfx::Transform transform;
-    transform.Translate(
-        0, GetYForDraggedTab(*tab_view, point_in_container, drag_clamp_min_y));
+
+    transform.Translate(IsHorizontalDragSupported()
+                            ? GetXForDraggedTab(*tab_view, point_in_container,
+                                                drag_bounds_to_clamp.x(),
+                                                drag_bounds_to_clamp.right())
+                            : 0,
+                        GetYForDraggedTab(*tab_view, point_in_container,
+                                          drag_bounds_to_clamp.y(),
+                                          drag_bounds_to_clamp.bottom()));
     tab_view->SetTransform(transform);
   }
 }
 
-int VerticalDraggedTabsContainer::GetMinYForDragToClamp() const {
-  auto* scroll_view = GetScrollViewForContainer();
+gfx::Rect VerticalDraggedTabsContainer::GetBoundsForDragToClamp() const {
+  const auto* scroll_view = GetScrollViewForContainer();
   CHECK(scroll_view);
-  gfx::Point limit_point;
-  limit_point = views::View::ConvertPointToTarget(
-      scroll_view, base::to_address(host_view_), limit_point);
-  return limit_point.y();
+  gfx::Rect bounds = views::View::ConvertRectToTarget(
+      scroll_view, base::to_address(host_view_), scroll_view->GetLocalBounds());
+
+  bounds.set_width(bounds.width() - tab_strip_padding_);
+  return bounds;
 }
 
 std::optional<int> VerticalDraggedTabsContainer::GetYForDraggedTabBounds(
@@ -181,6 +203,7 @@ std::optional<int> VerticalDraggedTabsCo
     return std::nullopt;
   }
   if (view.GetTransform().IsIdentity()) {
+    const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
     // If a drag recently ended the child will still be in
     // `dragging_views_` but will not have a transformation, which let's
     // the tab view animate into its correct slot.
@@ -188,7 +211,28 @@ std::optional<int> VerticalDraggedTabsCo
         view,
         views::View::ConvertPointFromScreen(base::to_address(host_view_),
                                             last_drag_point_in_screen_),
-        GetMinYForDragToClamp());
+        drag_bounds_to_clamp.y(), drag_bounds_to_clamp.bottom());
+  }
+  // If the tab is being dragged, then it is rendered using
+  // transformations, offset from the container's origin.
+  return 0;
+}
+
+std::optional<int> VerticalDraggedTabsContainer::GetXForDraggedTabBounds(
+    const views::View& view) const {
+  if (!dragging_views_.contains(&view) || !IsHorizontalDragSupported()) {
+    return std::nullopt;
+  }
+  if (view.GetTransform().IsIdentity()) {
+    const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
+    // If a drag recently ended the child will still be in
+    // `dragging_views_` but will not have a transformation, which let's
+    // the tab view animate into its correct slot.
+    return GetXForDraggedTab(
+        view,
+        views::View::ConvertPointFromScreen(base::to_address(host_view_),
+                                            last_drag_point_in_screen_),
+        drag_bounds_to_clamp.x(), drag_bounds_to_clamp.right());
   }
   // If the tab is being dragged, then it is rendered using
   // transformations, offset from the container's origin.
@@ -201,10 +245,13 @@ views::View* VerticalDraggedTabsContaine
   for (const auto& child_layout : layout.child_layouts) {
     if (child_layout.visible &&
         !dragging_views_.contains(child_layout.child_view) &&
-        child_layout.bounds.y() < point.y() &&
-        child_layout.bounds.bottom() > point.y()) {
+        child_layout.bounds.Contains(point)) {
       return child_layout.child_view;
     }
   }
   return nullptr;
 }
+
+bool VerticalDraggedTabsContainer::IsHorizontalDragSupported() const {
+  return drag_axes_ != DragAxes::kVerticalOnly;
+}
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
@@ -9,6 +9,7 @@
 #include "base/memory/raw_ref.h"
 #include "base/scoped_observation.h"
 #include "chrome/browser/ui/views/tabs/dragging/tab_drag_target.h"
+#include "ui/gfx/geometry/rect.h"
 #include "ui/views/view_observer.h"
 
 class VerticalTabDragHandler;
@@ -27,7 +28,12 @@ class ScrollView;
 class VerticalDraggedTabsContainer : public TabDragTarget,
                                      public views::ViewObserver {
  public:
-  explicit VerticalDraggedTabsContainer(views::View& host_view);
+  enum class DragAxes {
+    kVerticalOnly,
+    kBoth,
+  };
+
+  VerticalDraggedTabsContainer(views::View& host_view, DragAxes drag_axis);
   VerticalDraggedTabsContainer(const VerticalDraggedTabsContainer& other) =
       delete;
   VerticalDraggedTabsContainer& operator=(const VerticalDraggedTabsContainer&) =
@@ -36,7 +42,7 @@ class VerticalDraggedTabsContainer : pub
 
   // Recursively searches through the view hierarchy to find the collection
   // that should should be handling the tab drag at the given point.
-  VerticalDraggedTabsContainer& GetTabDragTarget(
+  virtual VerticalDraggedTabsContainer& GetTabDragTarget(
       const gfx::Point& point_in_screen);
 
   // TabDragTarget
@@ -54,8 +60,9 @@ class VerticalDraggedTabsContainer : pub
   void OnViewBoundsChanged(views::View* observed_view) override;
 
  protected:
-  // Returns the expected Y coordinate for a dragged tab view's bounds, or null
-  // if the view isn't being dragged in this.
+  // Returns the expected X/Y coordinate for a dragged tab view's bounds, or
+  // null if the view isn't being dragged in this.
+  std::optional<int> GetXForDraggedTabBounds(const views::View& view) const;
   std::optional<int> GetYForDraggedTabBounds(const views::View& view) const;
 
   // Helper for getting the view at a given point, excluding dragged views.
@@ -66,6 +73,9 @@ class VerticalDraggedTabsContainer : pub
   virtual VerticalTabDragHandler& GetDragHandler() = 0;
   virtual const VerticalTabDragHandler& GetDragHandler() const = 0;
 
+  // Whether the tab strip is collapsed.
+  virtual bool IsTabStripCollapsed() const = 0;
+
   // Returns the scroll view for the container.
   virtual views::ScrollView* GetScrollViewForContainer() const = 0;
 
@@ -89,15 +99,20 @@ class VerticalDraggedTabsContainer : pub
   // the last drag point.
   void UpdateDraggingViewTransforms(const gfx::Point& point_in_container);
 
-  // Returns the minimum top bounds to clamp the transformation applied to the
+  // Returns the bounds to clamp the transformation applied to the
   // drag view. This is to ensure the dragged view transform doesn't clip.
-  int GetMinYForDragToClamp() const;
+  gfx::Rect GetBoundsForDragToClamp() const;
+
+  bool IsHorizontalDragSupported() const;
 
   const raw_ref<const views::View> host_view_;
 
   // Child views that are being dragged.
   base::flat_set<raw_ptr<views::View>> dragging_views_;
   gfx::Point last_drag_point_in_screen_;
+  int tab_strip_padding_;
+
+  const DragAxes drag_axes_;
 
   base::ScopedObservation<views::View, views::ViewObserver>
       host_view_observation_{this};
--- a/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
@@ -7,10 +7,15 @@
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/views/tabs/vertical/tab_collection_animating_layout_manager.h"
 #include "chrome/browser/ui/views/tabs/vertical/tab_collection_node.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_split_tab_view.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_controller.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_tab_view.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/color/color_id.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/views/controls/scroll_view.h"
 #include "ui/views/layout/delegating_layout_manager.h"
 #include "ui/views/layout/layout_types.h"
 #include "ui/views/layout/proposed_layout.h"
@@ -23,15 +28,18 @@ constexpr int kTabPadding = 4;
 
 VerticalPinnedTabContainerView::VerticalPinnedTabContainerView(
     TabCollectionNode* collection_node)
-    : collection_node_(collection_node) {
-  auto* layout_manager =
-      SetLayoutManager(std::make_unique<TabCollectionAnimatingLayoutManager>(
+    : VerticalDraggedTabsContainer(
+          static_cast<views::View&>(*this),
+          VerticalDraggedTabsContainer::DragAxes::kBoth),
+      collection_node_(collection_node),
+      layout_manager_(*SetLayoutManager(std::make_unique<
+                                        TabCollectionAnimatingLayoutManager>(
           std::make_unique<views::DelegatingLayoutManager>(this),
           /*delegate=*/nullptr,
-          TabCollectionAnimatingLayoutManager::AnimationAxis::kHorizontal));
+          TabCollectionAnimatingLayoutManager::AnimationAxis::kHorizontal))) {
   collection_node->set_remove_child_from_node(base::BindRepeating(
       &TabCollectionAnimatingLayoutManager::AnimateAndDestroyChildView,
-      base::Unretained(layout_manager)));
+      base::Unretained(base::to_address(layout_manager_))));
 
   node_destroyed_subscription_ = collection_node_->RegisterWillDestroyCallback(
       base::BindOnce(&VerticalPinnedTabContainerView::ResetCollectionNode,
@@ -71,8 +79,7 @@ views::ProposedLayout VerticalPinnedTabC
   // Since all children are allocated the same width this will be the same for
   // every row.
   if (size_bounds.width().is_bounded() && size_bounds.width().value() > 0) {
-    auto* controller = collection_node_->GetController();
-    bool is_collapsed = controller && controller->IsCollapsed();
+    bool is_collapsed = IsTabStripCollapsed();
     const int region_horizontal_padding = GetLayoutConstant(
         is_collapsed ? LayoutConstant::kVerticalTabStripCollapsedPadding
                      : LayoutConstant::kVerticalTabStripUncollapsedPadding);
@@ -99,8 +106,8 @@ views::ProposedLayout VerticalPinnedTabC
     if (row_index != 0) {
       x += kTabPadding;
     }
-    bounds.set_x(x);
-    bounds.set_y(y);
+    bounds.set_x(GetXForDraggedTabBounds(*child).value_or(x));
+    bounds.set_y(GetYForDraggedTabBounds(*child).value_or(y));
     x += bounds.width();
     total_width = std::max(total_width, x);
     total_height = std::max(total_height, (y + bounds.height()));
@@ -120,5 +127,50 @@ void VerticalPinnedTabContainerView::Res
   collection_node_ = nullptr;
 }
 
+VerticalTabDragHandler& VerticalPinnedTabContainerView::GetDragHandler() {
+  return const_cast<VerticalTabDragHandler&>(
+      std::as_const(*this).GetDragHandler());
+}
+
+const VerticalTabDragHandler& VerticalPinnedTabContainerView::GetDragHandler()
+    const {
+  CHECK(collection_node_);
+  CHECK(collection_node_->GetController());
+  return collection_node_->GetController()->GetDragHandler();
+}
+
+bool VerticalPinnedTabContainerView::IsTabStripCollapsed() const {
+  const auto* controller =
+      collection_node_ ? collection_node_->GetController() : nullptr;
+  return controller && controller->IsCollapsed();
+}
+
+views::ScrollView* VerticalPinnedTabContainerView::GetScrollViewForContainer()
+    const {
+  return views::ScrollView::GetScrollViewForContents(
+      const_cast<VerticalPinnedTabContainerView*>(this));
+}
+
+void VerticalPinnedTabContainerView::UpdateLayoutForDrag() {
+  layout_manager_->ResetToTargetLayout();
+}
+
+void VerticalPinnedTabContainerView::HandleTabDragInContainer(
+    const gfx::Point point_in_container) {
+  const views::ProposedLayout& target_layout = layout_manager_->target_layout();
+  views::View* view_at_point =
+      GetViewAtPoint(target_layout, point_in_container);
+  const TabCollectionNode* node = nullptr;
+  if (auto* tab_view = views::AsViewClass<VerticalTabView>(view_at_point)) {
+    node = tab_view->collection_node();
+  } else if (auto* split_tab_view =
+                 views::AsViewClass<VerticalSplitTabView>(view_at_point)) {
+    node = split_tab_view->collection_node();
+  }
+  if (node) {
+    GetDragHandler().HandleDraggedTabsOverNode(*node);
+  }
+}
+
 BEGIN_METADATA(VerticalPinnedTabContainerView)
 END_METADATA
--- a/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.h
@@ -6,6 +6,8 @@
 #define CHROME_BROWSER_UI_VIEWS_TABS_VERTICAL_VERTICAL_PINNED_TAB_CONTAINER_VIEW_H_
 
 #include "base/callback_list.h"
+#include "chrome/browser/ui/views/tabs/vertical/tab_collection_animating_layout_manager.h"
+#include "chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h"
 #include "ui/base/metadata/metadata_header_macros.h"
 #include "ui/views/layout/delegating_layout_manager.h"
 #include "ui/views/view.h"
@@ -14,7 +16,8 @@ class TabCollectionNode;
 
 // Container for the vertical tabstrip's pinned tabs.
 class VerticalPinnedTabContainerView : public views::View,
-                                       public views::LayoutDelegate {
+                                       public views::LayoutDelegate,
+                                       public VerticalDraggedTabsContainer {
   METADATA_HEADER(VerticalPinnedTabContainerView, views::View)
 
  public:
@@ -30,9 +33,18 @@ class VerticalPinnedTabContainerView : p
       const views::SizeBounds& size_bounds) const override;
 
  private:
+  // VerticalDraggedTabsContainer:
+  VerticalTabDragHandler& GetDragHandler() override;
+  const VerticalTabDragHandler& GetDragHandler() const override;
+  bool IsTabStripCollapsed() const override;
+  views::ScrollView* GetScrollViewForContainer() const override;
+  void UpdateLayoutForDrag() override;
+  void HandleTabDragInContainer(const gfx::Point point_in_container) override;
+
   void ResetCollectionNode();
 
   raw_ptr<TabCollectionNode> collection_node_;
+  const raw_ref<TabCollectionAnimatingLayoutManager> layout_manager_;
 
   base::CallbackListSubscription node_destroyed_subscription_;
 };
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -23,6 +23,7 @@
 #include "components/tabs/public/tab_group_tab_collection.h"
 #include "components/tabs/public/tab_interface.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
+#include "ui/base/models/list_selection_model.h"
 #include "ui/compositor/layer.h"
 #include "ui/views/view_utils.h"
 
@@ -83,31 +84,44 @@ void VerticalTabDragHandlerImpl::Initial
   const auto& selected_tabs =
       tab_strip_model_->selection_model().selected_tabs();
 
-  std::vector<TabSlotView*> dragged_views(selected_tabs.size());
-  size_t next_dragged_view_idx = 0;
+  std::vector<TabSlotView*> dragged_views;
+  dragged_views.reserve(selected_tabs.size());
 
   TabSlotView* source_dragged_view = nullptr;
 
+  CHECK_EQ(node.type(), TabCollectionNode::Type::TAB);
+  const auto* source_tab =
+      std::get<const tabs::TabInterface*>(node.GetNodeData());
+
   // Track the node and build a shim view for each selected node.
+  ui::ListSelectionModel list_selection_model;
   for (tabs::TabInterface* tab : selected_tabs) {
-    CHECK(tab);
+    // Filter out selections that don't match the pinned state of the latest
+    // selected tab.
+    if (source_tab->IsPinned() != tab->IsPinned()) {
+      continue;
+    }
+    size_t index = tab_strip_model_->GetIndexOfTab(tab);
+    list_selection_model.AddIndexToSelection(index);
     TabCollectionNode* selected_node =
         root_node_->GetNodeForHandle(tab->GetHandle());
     CHECK(selected_node);
     auto* slot_view = &GetOrCreateSlotViewForNode(*selected_node);
     slot_view->SetBoundsRect(selected_node->view()->GetLocalBounds());
-    dragged_views[next_dragged_view_idx++] = slot_view;
+    dragged_views.push_back(slot_view);
     if (selected_node == &node) {
       source_dragged_view = slot_view;
+      list_selection_model.set_active(index);
     }
   }
+  dragged_views.shrink_to_fit();
+
   CHECK(source_dragged_view);
 
   const gfx::Point offset_from_source = event.location();
-  if (drag_controller_->Init(
-          this, source_dragged_view, dragged_views, offset_from_source,
-          tab_strip_model_->selection_model().GetListSelectionModel(),
-          EventSourceFromEvent(event)) ==
+  if (drag_controller_->Init(this, source_dragged_view, dragged_views,
+                             offset_from_source, list_selection_model,
+                             EventSourceFromEvent(event)) ==
       TabDragController::Liveness::kDeleted) {
     ResetDragState();
   }
@@ -275,6 +289,15 @@ bool VerticalTabDragHandlerImpl::IsViewD
   return false;
 }
 
+bool VerticalTabDragHandlerImpl::IsDraggingPinnedTabs() const {
+  if (!drag_controller_) {
+    return false;
+  }
+  const auto& drag_data = drag_controller_->GetSessionData().tab_drag_data_;
+  return std::any_of(drag_data.cbegin(), drag_data.cend(),
+                     [](const auto& tab_data) { return tab_data.pinned; });
+}
+
 views::View* VerticalTabDragHandlerImpl::ViewFromTabSlot(
     TabSlotView* view) const {
   auto* slot_view = views::AsViewClass<VerticalTabSlotView>(view);
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.h
@@ -44,6 +44,9 @@ class VerticalTabDragHandler {
   // dragged.
   virtual bool IsViewDragging(const views::View& view) const = 0;
 
+  // Returns true if there is an ongoing drag that includes a pinned tab.
+  virtual bool IsDraggingPinnedTabs() const = 0;
+
   // For vertical tabs, `TabSlotView` doesn't represent the actual tab
   // view. This method converts `view` to its actual tab view, or nullptr
   // if this handler doesn't manage it.
@@ -59,8 +62,8 @@ class VerticalTabDragHandlerImpl : publi
                                    public TabDragContext {
   METADATA_HEADER(VerticalTabDragHandlerImpl, TabDragContext)
  public:
-  VerticalTabDragHandlerImpl(TabStripModel& tab_strip_model,
-                             TabCollectionNode& root_node);
+  explicit VerticalTabDragHandlerImpl(TabStripModel& tab_strip_model,
+                                      TabCollectionNode& root_node);
   ~VerticalTabDragHandlerImpl() override;
   VerticalTabDragHandlerImpl(const VerticalTabDragHandlerImpl&) = delete;
   VerticalTabDragHandlerImpl& operator=(const VerticalTabDragHandlerImpl&) =
@@ -75,6 +78,7 @@ class VerticalTabDragHandlerImpl : publi
   void HandleDraggedTabsOverNode(const TabCollectionNode& node) override;
   TabDragContext* GetDragContext() override;
   bool IsViewDragging(const views::View& view) const override;
+  bool IsDraggingPinnedTabs() const override;
   views::View* ViewFromTabSlot(TabSlotView* view) const override;
 
   // TabDragContext
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
@@ -6,6 +6,7 @@
 #include "base/functional/callback_forward.h"
 #include "base/test/bind.h"
 #include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_element_identifiers.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_window/public/browser_window_interface.h"
@@ -37,6 +38,7 @@ namespace {
 using URL = std::string_view;
 using TabGroupURLs = std::vector<URL>;
 using URLs = std::vector<std::variant<URL, TabGroupURLs>>;
+using PinnedURLs = std::vector<URL>;
 
 int TabSelectModifier() {
 #if BUILDFLAG(IS_MAC)
@@ -75,6 +77,22 @@ base::RepeatingCallback<URLs()> GetTabOr
       model);
 }
 
+base::RepeatingCallback<PinnedURLs()> GetPinnedTabOrder(TabStripModel* model) {
+  return base::BindRepeating(
+      [](TabStripModel* model) {
+        PinnedURLs urls;
+        for (auto i = 0; i < model->count(); ++i) {
+          tabs::TabInterface* tab = model->GetTabAtIndex(i);
+          if (!tab->IsPinned()) {
+            break;
+          }
+          urls.push_back(tab->GetContents()->GetURL().spec());
+        }
+        return urls;
+      },
+      model);
+}
+
 base::RepeatingCallback<size_t()> GetBrowserCount() {
   return base::BindRepeating([]() { return chrome::GetTotalBrowserCount(); });
 }
@@ -160,6 +178,12 @@ class VerticalTabDragHandlerTest
                             TabSelectModifier()));
   }
 
+  auto PinTabAt(int tab_index) {
+    return Do([&, tab_index]() {
+      browser()->tab_strip_model()->SetTabPinned(tab_index, true);
+    });
+  }
+
   BrowserView& GetBrowserView() {
     BrowserView* browser_view =
         BrowserView::GetBrowserViewForBrowser(browser());
@@ -186,6 +210,8 @@ DEFINE_LOCAL_STATE_IDENTIFIER_VALUE(ui::
                                     kDragStatePoller);
 DEFINE_LOCAL_STATE_IDENTIFIER_VALUE(ui::test::PollingStateObserver<URLs>,
                                     kTabOrderPoller);
+DEFINE_LOCAL_STATE_IDENTIFIER_VALUE(ui::test::PollingStateObserver<PinnedURLs>,
+                                    kPinnedTabOrderPoller);
 
 // TODO(crbug.com/40249472): Tab DnD tests not working on ChromeOS and Mac, and
 // flakes on Wayland
@@ -714,3 +740,167 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                   tab_strip_model->GetWebContentsAt(2)->GetURL());
       }));
 }
+
+// TODO(crbug.com/40249472): Tab DnD tests not working on ChromeOS and Mac, and
+// flakes on Wayland
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND) && !BUILDFLAG(IS_WIN)
+#define MAYBE_DragPinnedTabWithinContainer DragPinnedTabWithinContainer
+#else
+#define MAYBE_DragPinnedTabWithinContainer DISABLED_DragPinnedTabWithinContainer
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest,
+                       MAYBE_DragPinnedTabWithinContainer) {
+  DEFINE_LOCAL_ELEMENT_IDENTIFIER_VALUE(kFourthTab);
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      AddInstrumentedTab(kFourthTab, GURL(chrome::kChromeUIVersionURL), 3),
+      PinTabAt(0), PinTabAt(1), PinTabAt(2), PinTabAt(3), SelectTabAt(0),
+      SelectTabAt(2),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(3); },
+          true),
+      CheckResult(
+          [this]() { return browser()->tab_strip_model()->IsTabSelected(2); },
+          true),
+      DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      PollState(kDragStatePoller, GetDragActive()),
+      WaitForState(kDragStatePoller, true),
+
+      PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
+
+      MoveMouseToTabAsync(0),
+      WaitForState(kPinnedTabOrderPoller, PinnedURLs({
+                                              chrome::kChromeUISettingsURL,
+                                              chrome::kChromeUIVersionURL,
+                                              url::kAboutBlankURL,
+                                              chrome::kChromeUIBookmarksURL,
+                                          })),
+      MoveMouseToTabAsync(2),
+      WaitForState(kPinnedTabOrderPoller, PinnedURLs({
+                                              url::kAboutBlankURL,
+                                              chrome::kChromeUISettingsURL,
+                                              chrome::kChromeUIVersionURL,
+                                              chrome::kChromeUIBookmarksURL,
+                                          })),
+      ReleaseMouseAsync());
+}
+
+// TODO(crbug.com/40249472): Tab DnD tests not working on ChromeOS and Mac, and
+// flakes on Wayland
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND) && !BUILDFLAG(IS_WIN)
+#define MAYBE_DragSplitWithinPinnedContainer DragSplitWithinPinnedContainer
+#else
+#define MAYBE_DragSplitWithinPinnedContainer \
+  DISABLED_DragSplitWithinPinnedContainer
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest,
+                       MAYBE_DragSplitWithinPinnedContainer) {
+  DEFINE_LOCAL_ELEMENT_IDENTIFIER_VALUE(kFourthTab);
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      AddInstrumentedTab(kFourthTab, GURL(chrome::kChromeUIVersionURL), 3),
+      PinTabAt(0), PinTabAt(1), PinTabAt(2), PinTabAt(3), Do([&]() {
+        tab_strip_model->ActivateTabAt(
+            2, TabStripUserGestureDetails(
+                   TabStripUserGestureDetails::GestureType::kOther));
+        tab_strip_model->AddToNewSplit(
+            {3}, {}, split_tabs::SplitTabCreatedSource::kTabContextMenu);
+      }),
+      DragTabTo(3, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+      PollState(kDragStatePoller, GetDragActive()),
+      WaitForState(kDragStatePoller, true),
+
+      PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
+      MoveMouseToTabAsync(0),
+      WaitForState(kPinnedTabOrderPoller, PinnedURLs({
+                                              chrome::kChromeUISettingsURL,
+                                              chrome::kChromeUIVersionURL,
+                                              url::kAboutBlankURL,
+                                              chrome::kChromeUIBookmarksURL,
+                                          })),
+      MoveMouseToTabAsync(2),
+      WaitForState(kPinnedTabOrderPoller, PinnedURLs({
+                                              url::kAboutBlankURL,
+                                              chrome::kChromeUISettingsURL,
+                                              chrome::kChromeUIVersionURL,
+                                              chrome::kChromeUIBookmarksURL,
+                                          })),
+      ReleaseMouseAsync());
+}
+
+// TODO(crbug.com/40249472): Tab DnD tests not working on ChromeOS and Mac, and
+// flakes on Wayland
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND) && !BUILDFLAG(IS_WIN)
+#define MAYBE_DetachPinnedTab DetachPinnedTab
+#else
+#define MAYBE_DetachPinnedTab DISABLED_DetachPinnedTab
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest, MAYBE_DetachPinnedTab) {
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      PinTabAt(0), PinTabAt(1),
+      DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+
+      PollState(kBrowserCountPoller, GetBrowserCount()),
+      WaitForState(kBrowserCountPoller, 2), ReleaseMouseAsync(),
+      PollState(kDragStatePoller, GetDragActive()),
+      WaitForState(kDragStatePoller, false), Do([&]() {
+        TabStripModel* new_tab_strip_model =
+            GetLatestBrowser().GetTabStripModel();
+        ASSERT_NE(nullptr, new_tab_strip_model);
+        EXPECT_EQ(GURL(chrome::kChromeUIBookmarksURL),
+                  new_tab_strip_model->GetWebContentsAt(0)->GetURL());
+        EXPECT_EQ(2, browser()->GetTabStripModel()->count());
+      }));
+}
+
+// TODO(crbug.com/40249472): Tab DnD tests not working on ChromeOS and Mac, and
+// flakes on Wayland
+#if !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_CHROMEOS) && \
+    !BUILDFLAG(IS_OZONE_WAYLAND) && !BUILDFLAG(IS_WIN)
+#define MAYBE_DragFromPinnedToUnpinnedContainer \
+  DragFromPinnedToUnpinnedContainer
+#else
+#define MAYBE_DragFromPinnedToUnpinnedContainer \
+  DISABLED_DragFromPinnedToUnpinnedContainer
+#endif
+IN_PROC_BROWSER_TEST_F(VerticalTabDragHandlerTest,
+                       MAYBE_DragFromPinnedToUnpinnedContainer) {
+  TabStripModel* tab_strip_model = browser()->GetTabStripModel();
+  ASSERT_NE(nullptr, tab_strip_model);
+  RunTestSequence(
+      AddInstrumentedTab(kSecondTab, GURL(chrome::kChromeUIBookmarksURL), 1),
+      AddInstrumentedTab(kThirdTab, GURL(chrome::kChromeUISettingsURL), 2),
+      PinTabAt(0),
+      DragTabTo(0, GetBrowserView().GetBoundsInScreen().top_right() +
+                       gfx::Vector2d(50, 50)),
+
+      PollState(kBrowserCountPoller, GetBrowserCount()),
+      WaitForState(kBrowserCountPoller, 2),
+
+      // Drag the detached pinned tab over the second unpinned tab in the
+      // original window, the pinned tab should remain pinned.
+      MoveMouseToTabAsync(1),
+      PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
+      PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
+      WaitForState(kPinnedTabOrderPoller, PinnedURLs({url::kAboutBlankURL})),
+      WaitForState(kTabOrderPoller, URLs({
+                                        url::kAboutBlankURL,
+                                        chrome::kChromeUIBookmarksURL,
+                                        chrome::kChromeUISettingsURL,
+                                    })),
+      ReleaseMouseAsync());
+}
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
@@ -54,7 +54,8 @@ const TabGroup* GetTabGroupFromNode(TabC
 }  // namespace
 
 VerticalTabGroupView::VerticalTabGroupView(TabCollectionNode* collection_node)
-    : VerticalDraggedTabsContainer(static_cast<views::View&>(*this)),
+    : VerticalDraggedTabsContainer(static_cast<views::View&>(*this),
+                                   DragAxes::kVerticalOnly),
       collection_node_(collection_node),
       tab_group_visual_data_(
           *GetTabGroupFromNode(collection_node_)->visual_data()),
@@ -95,9 +96,7 @@ views::ProposedLayout VerticalTabGroupVi
   views::ProposedLayout layouts;
   int width = 0;
   int height = kGroupHeaderVerticalMargin;
-  auto* controller =
-      collection_node_ ? collection_node_->GetController() : nullptr;
-  bool is_tab_strip_collapsed = controller && controller->IsCollapsed();
+  bool is_tab_strip_collapsed = IsTabStripCollapsed();
 
   gfx::Rect header_bounds;
   gfx::Rect group_line_bounds;
@@ -180,9 +179,7 @@ void VerticalTabGroupView::ToggleCollaps
 
 views::Widget* VerticalTabGroupView::ShowGroupEditorBubble(
     bool stop_context_menu_propagation) {
-  auto* controller =
-      collection_node_ ? collection_node_->GetController() : nullptr;
-  bool is_tab_strip_collapsed = controller && controller->IsCollapsed();
+  bool is_tab_strip_collapsed = IsTabStripCollapsed();
   // When the tab strip is collapsed, anchor to the group header, otherwise
   // anchor to the editor bubble button.
   views::View* anchor_view =
@@ -247,6 +244,12 @@ const VerticalTabDragHandler& VerticalTa
   return collection_node_->GetController()->GetDragHandler();
 }
 
+bool VerticalTabGroupView::IsTabStripCollapsed() const {
+  const auto* controller =
+      collection_node_ ? collection_node_->GetController() : nullptr;
+  return controller && controller->IsCollapsed();
+}
+
 views::ScrollView* VerticalTabGroupView::GetScrollViewForContainer() const {
   return views::ScrollView::GetScrollViewForContents(
       const_cast<views::View*>(parent()));
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.h
@@ -60,6 +60,7 @@ class VerticalTabGroupView
   // VerticalDraggedTabsContainer:
   VerticalTabDragHandler& GetDragHandler() override;
   const VerticalTabDragHandler& GetDragHandler() const override;
+  bool IsTabStripCollapsed() const override;
   views::ScrollView* GetScrollViewForContainer() const override;
   void UpdateLayoutForDrag() override;
   void HandleTabDragInContainer(const gfx::Point point_in_container) override;
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
@@ -53,7 +53,8 @@ class VerticalUnpinnedTabContainerViewTa
 
 VerticalUnpinnedTabContainerView::VerticalUnpinnedTabContainerView(
     TabCollectionNode* collection_node)
-    : VerticalDraggedTabsContainer(static_cast<views::View&>(*this)),
+    : VerticalDraggedTabsContainer(static_cast<views::View&>(*this),
+                                   DragAxes::kVerticalOnly),
       collection_node_(collection_node),
       layout_manager_(*SetLayoutManager(
           std::make_unique<TabCollectionAnimatingLayoutManager>(
@@ -80,8 +81,7 @@ views::ProposedLayout VerticalUnpinnedTa
   views::ProposedLayout layouts;
   int width = 0;
   int height = 0;
-  auto* controller = collection_node_->GetController();
-  bool is_collapsed = controller && controller->IsCollapsed();
+  bool is_collapsed = IsTabStripCollapsed();
 
   const int horizontal_padding = GetLayoutConstant(
       is_collapsed ? LayoutConstant::kVerticalTabStripCollapsedPadding
@@ -150,6 +150,12 @@ const VerticalTabDragHandler& VerticalUn
   return collection_node_->GetController()->GetDragHandler();
 }
 
+bool VerticalUnpinnedTabContainerView::IsTabStripCollapsed() const {
+  const auto* controller =
+      collection_node_ ? collection_node_->GetController() : nullptr;
+  return controller && controller->IsCollapsed();
+}
+
 views::ScrollView* VerticalUnpinnedTabContainerView::GetScrollViewForContainer()
     const {
   return views::ScrollView::GetScrollViewForContents(
@@ -179,5 +185,28 @@ void VerticalUnpinnedTabContainerView::H
   GetDragHandler().HandleDraggedTabsOverNode(*node);
 }
 
+VerticalDraggedTabsContainer&
+VerticalUnpinnedTabContainerView::GetTabDragTarget(
+    const gfx::Point& point_in_screen) {
+  gfx::Point point_in_container =
+      views::View::ConvertPointFromScreen(this, point_in_screen);
+  // Use the center of the bounds so views with padding are still targetable
+  // from the sides of the tabstrip.
+  point_in_container.set_x(bounds().x() + bounds().width() / 2);
+
+  for (views::View* child : children()) {
+    if (!child->GetVisible() || !child->bounds().Contains(point_in_container) ||
+        IsViewDragging(*child)) {
+      continue;
+    }
+    if (auto* group_view = views::AsViewClass<VerticalTabGroupView>(child)) {
+      if (!group_view->IsCollapsed()) {
+        return *group_view;
+      }
+    }
+  }
+  return *this;
+}
+
 BEGIN_METADATA(VerticalUnpinnedTabContainerView)
 END_METADATA
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.h
@@ -39,10 +39,15 @@ class VerticalUnpinnedTabContainerView
   // TabCollectionAnimatingLayoutManager::Delegate:
   bool IsViewDragging(const views::View& child_view) const override;
 
+  // VerticalDraggedTabsContainer:
+  VerticalDraggedTabsContainer& GetTabDragTarget(
+      const gfx::Point& point_in_screen) override;
+
  private:
   // VerticalDraggedTabsContainer:
   VerticalTabDragHandler& GetDragHandler() override;
   const VerticalTabDragHandler& GetDragHandler() const override;
+  bool IsTabStripCollapsed() const override;
   views::ScrollView* GetScrollViewForContainer() const override;
   void UpdateLayoutForDrag() override;
   void HandleTabDragInContainer(const gfx::Point point_in_container) override;
