From b9abc8188441e3e54254be17d4ebb08179f20a12 Mon Sep 17 00:00:00 2001
From: jj <jj@imput.net>
Date: Sat, 14 Feb 2026 23:13:37 +0000
Subject: [PATCH] [Vertical Tabs] Keep vertical drag alive across capture handoff

On Linux, dragging into another tab strip can transfer capture while
TabDragController is in DragState::kDraggingWindow.

VerticalTabDragHandlerImpl::EndDrag() always called ResetDragState(),
which destroyed the controller during SetCapture(target_context).

Fix this by not force-resetting the vertical handler's drag state from
EndDrag(), delegating the decision to TabDragController, and letting it
destroy itself via the owning context when appropriate.

Fixed: 484520102
Change-Id: Ia851895e7375110a48ed72117d2e911b91b543e0
---

--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -238,10 +238,16 @@ bool VerticalTabDragHandlerImpl::Continu
 void VerticalTabDragHandlerImpl::EndDrag(EndDragReason reason) {
   if (TabDragController::IsSystemDnDSessionRunning()) {
     TabDragController::OnSystemDnDEnded();
-  } else if (drag_controller_ && drag_controller_->started_drag()) {
+    ResetDragState();
+    return;
+  }
+
+  // Let TabDragController decide whether this reason should actually end the
+  // drag (e.g. capture loss while dragging a detached window) and destroy
+  // itself when appropriate.
+  if (drag_controller_) {
     drag_controller_->EndDrag(reason);
   }
-  ResetDragState();
 }
 
 void VerticalTabDragHandlerImpl::HandleDraggedTabsOverNode(
