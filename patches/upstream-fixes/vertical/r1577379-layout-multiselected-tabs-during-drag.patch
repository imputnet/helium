From e7d13d87bbe6a7afb3f6b8160e1cb7ad47b222a7 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@chromium.org>
Date: Fri, 30 Jan 2026 10:29:32 -0800
Subject: [PATCH] Implement laying out of multi-selected vertical tabs during drag

Adds support for laying out dragged tabs, either stacked vertically or
squashed over each other.

This is achieved by having VerticalDraggedTabsContainer calculate the
bounding box of all dragged views, and tracking each dragged view's
offset within it. Position is determined by calculating the bounding
box's position relative to the drag point, then applying the offset of
each dragged view.

Bug: 476084253
Change-Id: I8a77f999e7690d85b31a5d22377bf729cf7b84d0
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7533636
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1577379}
---

--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -6,8 +6,10 @@
 
 #include "base/callback_list.h"
 #include "base/containers/flat_set.h"
+#include "base/notreached.h"
 #include "base/types/to_address.h"
 #include "chrome/browser/ui/layout_constants.h"
+#include "chrome/browser/ui/views/tabs/dragging/drag_session_data.h"
 #include "chrome/browser/ui/views/tabs/dragging/tab_drag_target.h"
 #include "chrome/browser/ui/views/tabs/tab_slot_view.h"
 #include "chrome/browser/ui/views/tabs/vertical/tab_collection_node.h"
@@ -16,6 +18,9 @@
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_controller.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_tab_view.h"
 #include "chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.h"
+#include "ui/compositor/layer.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/vector2d.h"
 #include "ui/views/controls/scroll_view.h"
 #include "ui/views/layout/proposed_layout.h"
 #include "ui/views/view.h"
@@ -23,42 +28,50 @@
 
 namespace {
 
-// Returns the expected Y coordinate for the view of a tab being dragged at
-// `point`. Clamps to `drag_clamp_min_y` and `drag_clamp_max_y`.
-int GetYForDraggedTab(const views::View& dragging_view,
-                      const gfx::Point& point,
-                      int drag_clamp_min_y,
-                      int drag_clamp_max_y) {
-  if (dragging_view.height() > drag_clamp_max_y - drag_clamp_min_y) {
-    return drag_clamp_min_y;
-  }
-  return std::clamp(
-      point.y() - (dragging_view.height() * 0.5f),
-      static_cast<float>(drag_clamp_min_y),
-      static_cast<float>(drag_clamp_max_y) - dragging_view.height());
-}
-
-// Returns the expected X coordinate for the view of a tab being dragged at
-// `point`. Clamps to `drag_clamp_min_x` and `drag_clamp_max_x`.
-int GetXForDraggedTab(const views::View& dragging_view,
-                      const gfx::Point& point,
-                      int drag_clamp_min_x,
-                      int drag_clamp_max_x) {
-  if (dragging_view.width() > drag_clamp_max_x - drag_clamp_min_x) {
-    return drag_clamp_min_x;
-  }
-  return std::clamp(
-      point.x() - (dragging_view.width() * 0.5f),
-      static_cast<float>(drag_clamp_min_x),
-      static_cast<float>(drag_clamp_max_x) - dragging_view.width());
-}
+// Returns drag data sorted by index in the source tab strip model.
+// TODO(crbug.com/476084253): Update `DragSessionData` to ensure the tab drag
+// data is already sorted.
+std::vector<TabDragData> GetSortedTabDragData(
+    const DragSessionData& session_data) {
+  std::vector<TabDragData> drag_data = session_data.tab_drag_data_;
+  std::sort(drag_data.begin(), drag_data.end(),
+            [](const TabDragData& a, const TabDragData& b) {
+              return a.source_model_index < b.source_model_index;
+            });
+  return drag_data;
+}
+
+// Calculates the offset of the source dragged view (i.e. the main view being
+// dragged) from the mouse.
+gfx::Vector2d GetSourceViewOffsetFromMouse(
+    views::View& source_dragged_view,
+    const DragSessionData& session_data) {
+  views::View* source_slot_view =
+      session_data.source_view_drag_data()->attached_view;
+
+  // The view that initiated the drag may not be the same as the view that
+  // is being dragged (e.g. dragging a tab group header).
+  gfx::Vector2d slot_view_offset_to_source =
+      views::View::ConvertPointToTarget(source_slot_view, &source_dragged_view,
+                                        source_slot_view->bounds().origin())
+          .OffsetFromOrigin();
+  gfx::Vector2d dragged_view_bounds_offset_from_bounds;
+  dragged_view_bounds_offset_from_bounds -= slot_view_offset_to_source;
+  dragged_view_bounds_offset_from_bounds -=
+      {static_cast<int>(session_data.mouse_offset_to_size_ratios.x() *
+                        source_slot_view->width()),
+       static_cast<int>(session_data.mouse_offset_to_size_ratios.y() *
+                        source_slot_view->height())};
 
+  return dragged_view_bounds_offset_from_bounds;
+}
 }  // namespace
 
 VerticalDraggedTabsContainer::VerticalDraggedTabsContainer(
     views::View& host_view,
-    DragAxes drag_axes)
-    : host_view_(host_view), drag_axes_(drag_axes) {
+    DragAxes drag_axes,
+    DragLayout drag_layout)
+    : host_view_(host_view), drag_axes_(drag_axes), drag_layout_(drag_layout) {
   host_view_observation_.Observe(&host_view);
 }
 
@@ -138,30 +151,97 @@ void VerticalDraggedTabsContainer::OnVie
       base::to_address(host_view_), last_drag_point_in_screen_));
 }
 
-// TODO(crbug.com/476084253): Animate selected dragged tabs into the container.
+// TODO(crbug.com/476084253): Animate selected tabs into a contiguous layout.
+// Currently, they snap into contiguous order.
 void VerticalDraggedTabsContainer::InitializeDragState(
     TabDragTarget::DragController& controller) {
-  tab_strip_padding_ = GetLayoutConstant(
-      IsTabStripCollapsed()
-          ? LayoutConstant::kVerticalTabStripCollapsedPadding
-          : LayoutConstant::kVerticalTabStripUncollapsedPadding);
-  // Move each dragged tab to the origin position. Transformations will be used
-  // to render them during the drag.
-  for (TabSlotView* slot_view : controller.GetSessionData().attached_views()) {
-    auto* tab_view = GetDragHandler().ViewFromTabSlot(slot_view);
-    CHECK(tab_view);
-    if (tab_view->parent() == base::to_address(host_view_)) {
-      dragging_views_.insert(tab_view);
+  CHECK(dragging_views_.empty());
+
+  const auto& session_data = controller.GetSessionData();
+  BuildDragLayout(session_data);
+}
+
+void VerticalDraggedTabsContainer::BuildDragLayout(
+    const DragSessionData& session_data) {
+  auto* source_dragged_view = GetDragHandler().ViewFromTabSlot(
+      session_data.source_view_drag_data()->attached_view);
+  CHECK(source_dragged_view);
+  CHECK_EQ(dragging_views_bounds_, gfx::Rect());
+
+  dragging_views_bounds_.Offset(
+      GetSourceViewOffsetFromMouse(*source_dragged_view, session_data));
+
+  for (const auto& datum : GetSortedTabDragData(session_data)) {
+    auto* dragging_view = GetDragHandler().ViewFromTabSlot(datum.attached_view);
+    CHECK(dragging_view);
+
+    if (dragging_view->parent() != base::to_address(host_view_)) {
+      continue;
+    }
+    if (dragging_views_.contains(dragging_view)) {
+      // It's possible that multiple dragged tabs map to the same dragged view
+      // (e.g., split tabs). Skip the duplicates.
+      continue;
     }
+
+    const bool is_source_view = dragging_view == source_dragged_view;
+
+    switch (drag_layout_) {
+      case DragLayout::kVertical:
+        CHECK(!IsHorizontalDragSupported());
+        AddViewToVerticalDragLayout(dragging_view, is_source_view);
+        break;
+      case DragLayout::kSquash:
+        AddViewToSquashedDragLayout(dragging_view, is_source_view);
+        break;
+      default:
+        NOTREACHED();
+    }
+  }
+
+  // If no dragged views are parented under this container yet (e.g. during
+  // pinned-tab reparenting), keep bounds empty so initialization can retry on
+  // the next drag update.
+  if (dragging_views_.empty()) {
+    dragging_views_bounds_ = gfx::Rect();
+  }
+}
+
+void VerticalDraggedTabsContainer::AddViewToVerticalDragLayout(
+    views::View* dragging_view,
+    bool is_source_dragged_view) {
+  gfx::Rect bounds = gfx::Rect(dragging_view->GetPreferredSize({}));
+  bounds.set_y(dragging_views_bounds_.height());
+  dragging_views_.insert({dragging_view, bounds.OffsetFromOrigin()});
+
+  static constexpr int kDraggedViewVerticalPadding = 2;
+  dragging_views_bounds_.set_height(dragging_views_bounds_.height() +
+                                    bounds.height() +
+                                    kDraggedViewVerticalPadding);
+
+  if (is_source_dragged_view) {
+    dragging_views_bounds_.Offset({-1 * bounds.x(), -1 * bounds.y()});
+  }
+}
+
+void VerticalDraggedTabsContainer::AddViewToSquashedDragLayout(
+    views::View* dragging_view,
+    bool is_source_dragged_view) {
+  dragging_views_.insert({dragging_view, {0, 0}});
+  if (is_source_dragged_view) {
+    dragging_views_bounds_.set_size(dragging_view->bounds().size());
+  } else {
+    dragging_view->layer()->SetVisible(false);
   }
 }
 
 void VerticalDraggedTabsContainer::ResetDragState() {
-  for (auto view : dragging_views_) {
+  for (auto& [view, _] : dragging_views_) {
     view->SetTransform(gfx::Transform());
   }
   UpdateLayoutForDrag();
   dragging_views_.clear();
+  dragging_views_bounds_ = gfx::Rect();
 }
 
 // TODO(crbug.com/476084253): Support laying out with multiple dragged tabs.
@@ -169,74 +249,58 @@ void VerticalDraggedTabsContainer::Reset
 // the space at their expected tab slot.
 void VerticalDraggedTabsContainer::UpdateDraggingViewTransforms(
     const gfx::Point& point_in_container) {
-  const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
-  for (views::View* tab_view : dragging_views_) {
+  const gfx::Rect bounding_box_for_point =
+      GetDraggingViewsBoundsAtPoint(point_in_container);
+  for (auto& [dragged_view, offset] : dragging_views_) {
     // Use a transformation to render the dragged views, offset from the
     // container's origin.
     gfx::Transform transform;
-
     transform.Translate(IsHorizontalDragSupported()
-                            ? GetXForDraggedTab(*tab_view, point_in_container,
-                                                drag_bounds_to_clamp.x(),
-                                                drag_bounds_to_clamp.right())
+                            ? bounding_box_for_point.x() + offset.x()
+
                             : 0,
-                        GetYForDraggedTab(*tab_view, point_in_container,
-                                          drag_bounds_to_clamp.y(),
-                                          drag_bounds_to_clamp.bottom()));
-    tab_view->SetTransform(transform);
+                        bounding_box_for_point.y() + offset.y());
+    dragged_view->SetTransform(transform);
   }
 }
 
-gfx::Rect VerticalDraggedTabsContainer::GetBoundsForDragToClamp() const {
+gfx::Rect VerticalDraggedTabsContainer::GetDraggingViewsBoundsAtPoint(
+    const gfx::Point& point_in_container) const {
   const auto* scroll_view = GetScrollViewForContainer();
   CHECK(scroll_view);
-  gfx::Rect bounds = views::View::ConvertRectToTarget(
+  gfx::Rect clamping_bounds = views::View::ConvertRectToTarget(
       scroll_view, base::to_address(host_view_), scroll_view->GetLocalBounds());
+  clamping_bounds.set_width(clamping_bounds.width() - tab_strip_padding_);
 
-  bounds.set_width(bounds.width() - tab_strip_padding_);
-  return bounds;
-}
-
-std::optional<int> VerticalDraggedTabsContainer::GetYForDraggedTabBounds(
-    const views::View& view) const {
-  if (!dragging_views_.contains(&view)) {
-    return std::nullopt;
-  }
-  if (view.GetTransform().IsIdentity()) {
-    const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
-    // If a drag recently ended the child will still be in
-    // `dragging_views_` but will not have a transformation, which let's
-    // the tab view animate into its correct slot.
-    return GetYForDraggedTab(
-        view,
-        views::View::ConvertPointFromScreen(base::to_address(host_view_),
-                                            last_drag_point_in_screen_),
-        drag_bounds_to_clamp.y(), drag_bounds_to_clamp.bottom());
-  }
-  // If the tab is being dragged, then it is rendered using
-  // transformations, offset from the container's origin.
-  return 0;
+  gfx::Rect bounding_box_for_point = dragging_views_bounds_;
+  bounding_box_for_point.Offset(point_in_container.OffsetFromOrigin());
+  bounding_box_for_point.AdjustToFit(clamping_bounds);
+  return bounding_box_for_point;
 }
 
-std::optional<int> VerticalDraggedTabsContainer::GetXForDraggedTabBounds(
+std::optional<gfx::Point>
+VerticalDraggedTabsContainer::GetOriginForDraggedTabBounds(
     const views::View& view) const {
-  if (!dragging_views_.contains(&view) || !IsHorizontalDragSupported()) {
+  auto it = dragging_views_.find(&view);
+  if (it == dragging_views_.end()) {
     return std::nullopt;
   }
   if (view.GetTransform().IsIdentity()) {
-    const gfx::Rect drag_bounds_to_clamp = GetBoundsForDragToClamp();
     // If a drag recently ended the child will still be in
     // `dragging_views_` but will not have a transformation, which let's
     // the tab view animate into its correct slot.
-    return GetXForDraggedTab(
-        view,
-        views::View::ConvertPointFromScreen(base::to_address(host_view_),
-                                            last_drag_point_in_screen_),
-        drag_bounds_to_clamp.x(), drag_bounds_to_clamp.right());
+    const gfx::Point point_in_container = views::View::ConvertPointFromScreen(
+        base::to_address(host_view_), last_drag_point_in_screen_);
+    const gfx::Rect bounding_box_for_point =
+        GetDraggingViewsBoundsAtPoint(point_in_container);
+    return gfx::Point(IsHorizontalDragSupported()
+                          ? bounding_box_for_point.x() + it->second.x()
+                          : 0,
+                      bounding_box_for_point.y() + it->second.y());
   }
   // If the tab is being dragged, then it is rendered using
   // transformations, offset from the container's origin.
-  return 0;
+  return gfx::Point();
 }
 
 views::View* VerticalDraggedTabsContainer::GetViewAtPoint(
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
@@ -5,11 +5,12 @@
 #ifndef CHROME_BROWSER_UI_VIEWS_TABS_VERTICAL_VERTICAL_DRAGGED_TABS_CONTAINER_H_
 #define CHROME_BROWSER_UI_VIEWS_TABS_VERTICAL_VERTICAL_DRAGGED_TABS_CONTAINER_H_
 
-#include "base/containers/flat_set.h"
+#include "base/containers/flat_map.h"
 #include "base/memory/raw_ref.h"
 #include "base/scoped_observation.h"
 #include "chrome/browser/ui/views/tabs/dragging/tab_drag_target.h"
 #include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/vector2d.h"
 #include "ui/views/view_observer.h"
 
 class VerticalTabDragHandler;
@@ -28,12 +29,15 @@ class ScrollView;
 class VerticalDraggedTabsContainer : public TabDragTarget,
                                      public views::ViewObserver {
  public:
-  enum class DragAxes {
-    kVerticalOnly,
-    kBoth,
-  };
+  // The axes that the dragged tabs can move on.
+  enum class DragAxes { kVerticalOnly, kBoth };
 
-  VerticalDraggedTabsContainer(views::View& host_view, DragAxes drag_axis);
+  // How the dragged tabs should be laid out.
+  enum class DragLayout { kVertical, kSquash };
+
+  VerticalDraggedTabsContainer(views::View& host_view,
+                               DragAxes drag_axis,
+                               DragLayout drag_layout);
   VerticalDraggedTabsContainer(const VerticalDraggedTabsContainer& other) =
       delete;
   VerticalDraggedTabsContainer& operator=(const VerticalDraggedTabsContainer&) =
@@ -60,10 +64,12 @@ class VerticalDraggedTabsContainer : pub
   void OnViewBoundsChanged(views::View* observed_view) override;
 
  protected:
-  // Returns the expected X/Y coordinate for a dragged tab view's bounds, or
+  // Returns the expected coordinates for a dragged tab view's bounds, or
   // null if the view isn't being dragged in this.
-  std::optional<int> GetXForDraggedTabBounds(const views::View& view) const;
-  std::optional<int> GetYForDraggedTabBounds(const views::View& view) const;
+  // A value of 0 is used by default for the X-coordinate if dragging along the
+  // x-axis is not supported.
+  std::optional<gfx::Point> GetOriginForDraggedTabBounds(
+      const views::View& view) const;
 
   // Helper for getting the view at a given point, excluding dragged views.
   views::View* GetViewAtPoint(const views::ProposedLayout& layout,
@@ -91,6 +97,14 @@ class VerticalDraggedTabsContainer : pub
   // starts handling a drag.
   void InitializeDragState(TabDragTarget::DragController& controller);
 
+  // Builds `dragging_views_` and `dragging_views_bounds_` for the given
+  // drag data.
+  void BuildDragLayout(const DragSessionData& drag_data);
+  void AddViewToVerticalDragLayout(views::View* dragging_view,
+                                   bool is_source_dragged_view);
+  void AddViewToSquashedDragLayout(views::View* dragging_view,
+                                   bool is_source_dragged_view);
+
   // Clears drag state and removes the transformations that were being used for
   // the drag.
   void ResetDragState();
@@ -99,20 +113,28 @@ class VerticalDraggedTabsContainer : pub
   // the last drag point.
   void UpdateDraggingViewTransforms(const gfx::Point& point_in_container);
 
-  // Returns the bounds to clamp the transformation applied to the
-  // drag view. This is to ensure the dragged view transform doesn't clip.
-  gfx::Rect GetBoundsForDragToClamp() const;
+  // Returns the bounds of the box containing all dragged views, adjusted to
+  // the point `point_in_container`, and clamped to the bounds of the
+  // container.
+  gfx::Rect GetDraggingViewsBoundsAtPoint(
+      const gfx::Point& point_in_container) const;
 
   bool IsHorizontalDragSupported() const;
 
   const raw_ref<const views::View> host_view_;
+  int tab_strip_padding_;
 
-  // Child views that are being dragged.
-  base::flat_set<raw_ptr<views::View>> dragging_views_;
   gfx::Point last_drag_point_in_screen_;
-  int tab_strip_padding_;
+
+  // The bounding box of all the dragged views, relative to the drag point.
+  gfx::Rect dragging_views_bounds_;
+
+  // Child views that are being dragged, mapped to their offset within
+  // `dragging_views_bounds_`.
+  base::flat_map<raw_ptr<views::View>, gfx::Vector2d> dragging_views_;
 
   const DragAxes drag_axes_;
+  const DragLayout drag_layout_;
 
   base::ScopedObservation<views::View, views::ViewObserver>
       host_view_observation_{this};
--- a/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
@@ -28,9 +28,9 @@ constexpr int kTabPadding = 4;
 
 VerticalPinnedTabContainerView::VerticalPinnedTabContainerView(
     TabCollectionNode* collection_node)
-    : VerticalDraggedTabsContainer(
-          static_cast<views::View&>(*this),
-          VerticalDraggedTabsContainer::DragAxes::kBoth),
+    : VerticalDraggedTabsContainer(static_cast<views::View&>(*this),
+                                   DragAxes::kBoth,
+                                   DragLayout::kSquash),
       collection_node_(collection_node),
       layout_manager_(*SetLayoutManager(std::make_unique<
                                         TabCollectionAnimatingLayoutManager>(
@@ -106,8 +106,7 @@ views::ProposedLayout VerticalPinnedTabC
     if (row_index != 0) {
       x += kTabPadding;
     }
-    bounds.set_x(GetXForDraggedTabBounds(*child).value_or(x));
-    bounds.set_y(GetYForDraggedTabBounds(*child).value_or(y));
+    bounds.set_origin(GetOriginForDraggedTabBounds(*child).value_or({x, y}));
     x += bounds.width();
     total_width = std::max(total_width, x);
     total_height = std::max(total_height, (y + bounds.height()));
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
@@ -55,7 +55,8 @@ const TabGroup* GetTabGroupFromNode(TabC
 
 VerticalTabGroupView::VerticalTabGroupView(TabCollectionNode* collection_node)
     : VerticalDraggedTabsContainer(static_cast<views::View&>(*this),
-                                   DragAxes::kVerticalOnly),
+                                   DragAxes::kVerticalOnly,
+                                   DragLayout::kVertical),
       collection_node_(collection_node),
       tab_group_visual_data_(
           *GetTabGroupFromNode(collection_node_)->visual_data()),
@@ -139,7 +140,8 @@ views::ProposedLayout VerticalTabGroupVi
   // fill available width.
   for (auto* child : children) {
     gfx::Rect bounds = gfx::Rect(child->GetPreferredSize());
-    bounds.set_y(GetYForDraggedTabBounds(*child).value_or(height));
+    bounds.set_y(
+        GetOriginForDraggedTabBounds(*child).value_or({0, height}).y());
     // If the tab strip is not collapsed then the groups tabs should be inset.
     bounds.set_x(is_tab_strip_collapsed
                      ? GetLayoutConstant(
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
@@ -54,7 +54,8 @@ class VerticalUnpinnedTabContainerViewTa
 VerticalUnpinnedTabContainerView::VerticalUnpinnedTabContainerView(
     TabCollectionNode* collection_node)
     : VerticalDraggedTabsContainer(static_cast<views::View&>(*this),
-                                   DragAxes::kVerticalOnly),
+                                   DragAxes::kVerticalOnly,
+                                   DragLayout::kVertical),
       collection_node_(collection_node),
       layout_manager_(*SetLayoutManager(
           std::make_unique<TabCollectionAnimatingLayoutManager>(
@@ -103,8 +104,8 @@ views::ProposedLayout VerticalUnpinnedTa
                           {});
     gfx::Rect bounds = gfx::Rect(child->GetPreferredSize(child_bounds));
     bounds.set_x(x);
-
-    bounds.set_y(GetYForDraggedTabBounds(*child).value_or(height));
+    bounds.set_y(
+        GetOriginForDraggedTabBounds(*child).value_or({0, height}).y());
 
     // If width is bounded, child views should respect the width constraints and
     // take up the available width excluding trailing horizontal padding.
