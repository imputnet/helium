From b9558692624b587814260d828512f59a92ae4148 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@chromium.org>
Date: Fri, 06 Feb 2026 06:12:00 -0800
Subject: [PATCH] Use bounds of dragged vertical tabs for targeting

Updates targeting logic to use the bounds of the dragged tabs instead of
the point of the drag to determine which tabs/groups are interacted
with.

Demo: https://screencast.googleplex.com/cast/NTkyNjU4MDIzMTYwMjE3NnxmNGIyYWE5Yi1lNQ
Change-Id: If40234b92e7e4645d328062f5f89ae145ebe18d6
Bug: 476509652
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7547257
Reviewed-by: David Pennington <dpenning@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1580788}
---

--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.cc
@@ -101,14 +101,12 @@ TabDragContext* VerticalDraggedTabsConta
     return GetDragHandler().GetDragContext();
   }
 
-  // Hit-test against the target layout instead of the current one to prevent
-  // bouncing between targets while mid-animation.
-  // TODO(crbug.com/439963720): Finetune hit testing, using the bounds of the
-  // dragged tabs.
   gfx::Point point_in_container = views::View::ConvertPointFromScreen(
       base::to_address(host_view_), point_in_screen);
 
-  HandleTabDragInContainer(point_in_container);
+  gfx::Rect dragged_bounds_in_container =
+      GetDraggingViewsBoundsAtPoint(point_in_container);
+  HandleTabDragInContainer(dragged_bounds_in_container);
 
   // Used to determine whether the layout should snap into position without
   // animating at the end of this drag cycle.
@@ -155,7 +153,7 @@ void VerticalDraggedTabsContainer::OnVie
   // The transformation coordinates are relative to the host view's coordinates,
   // so they must be updated as the bounds change to ensure the dragged tabs
   // remain at the same point in the screen.
-  if (!dragging_views_.empty()) {
+  if (IsHandlingDrag()) {
     UpdateDraggingViewTransforms(views::View::ConvertPointFromScreen(
         base::to_address(host_view_), last_drag_point_in_screen_));
   }
@@ -271,7 +269,7 @@ void VerticalDraggedTabsContainer::Reset
 void VerticalDraggedTabsContainer::UpdateDraggingViewTransforms(
     const gfx::Point& point_in_container) {
   const gfx::Rect bounding_box_for_point =
-      GetDraggingViewsBoundsAtPoint(point_in_container);
+      GetDraggingViewsBoundsAtPointClamped(point_in_container);
   for (auto& [dragged_view, visual_data] : dragging_views_) {
     if (visual_data.should_hide) {
       continue;
@@ -291,15 +289,23 @@ void VerticalDraggedTabsContainer::Updat
 
 gfx::Rect VerticalDraggedTabsContainer::GetDraggingViewsBoundsAtPoint(
     const gfx::Point& point_in_container) const {
+  gfx::Rect bounding_box_for_point = dragging_views_bounds_;
+  bounding_box_for_point.Offset(point_in_container.OffsetFromOrigin());
+  return bounding_box_for_point;
+}
+
+gfx::Rect VerticalDraggedTabsContainer::GetDraggingViewsBoundsAtPointClamped(
+    const gfx::Point& point_in_container) const {
+  gfx::Rect bounding_box_for_point =
+      GetDraggingViewsBoundsAtPoint(point_in_container);
+
   const auto* scroll_view = GetScrollViewForContainer();
   CHECK(scroll_view);
   gfx::Rect clamping_bounds = views::View::ConvertRectToTarget(
       scroll_view, base::to_address(host_view_), scroll_view->GetLocalBounds());
   clamping_bounds.set_width(clamping_bounds.width() - tab_strip_padding_);
-
-  gfx::Rect bounding_box_for_point = dragging_views_bounds_;
-  bounding_box_for_point.Offset(point_in_container.OffsetFromOrigin());
   bounding_box_for_point.AdjustToFit(clamping_bounds);
+
   return bounding_box_for_point;
 }
 
@@ -317,7 +323,7 @@ VerticalDraggedTabsContainer::GetVisualD
     const gfx::Point point_in_container = views::View::ConvertPointFromScreen(
         base::to_address(host_view_), last_drag_point_in_screen_);
     const gfx::Rect bounding_box_for_point =
-        GetDraggingViewsBoundsAtPoint(point_in_container);
+        GetDraggingViewsBoundsAtPointClamped(point_in_container);
     return std::make_optional(DraggedViewVisualData{
         .offset = gfx::Vector2d(
             IsHorizontalDragSupported()
@@ -333,18 +339,58 @@ VerticalDraggedTabsContainer::GetVisualD
                                .should_hide = it->second.should_hide};
 }
 
-views::View* VerticalDraggedTabsContainer::GetViewAtPoint(
+views::View* VerticalDraggedTabsContainer::GetViewForDragBounds(
     const views::ProposedLayout& layout,
-    const gfx::Point& point) {
+    const gfx::Rect& dragged_tab_bounds) {
   for (const auto& child_layout : layout.child_layouts) {
-    if (child_layout.visible && child_layout.bounds.Contains(point) &&
-        !GetDragHandler().IsViewDragging(*child_layout.child_view)) {
+    if (!child_layout.visible ||
+        GetDragHandler().IsViewDragging(*child_layout.child_view)) {
+      continue;
+    }
+
+    if (HasMinimumOverlap(
+            dragged_tab_bounds, child_layout.bounds,
+            IsHorizontalDragSupported()
+                ? std::make_optional(child_layout.bounds.width() * 0.5)
+                : std::nullopt,
+            child_layout.bounds.height() * 0.5)) {
       return child_layout.child_view;
     }
   }
+
   return nullptr;
 }
 
 bool VerticalDraggedTabsContainer::IsHorizontalDragSupported() const {
   return drag_axes_ != DragAxes::kVerticalOnly;
 }
+
+bool VerticalDraggedTabsContainer::HasMinimumOverlap(
+    const gfx::Rect& a,
+    const gfx::Rect& b,
+    std::optional<int> min_x_overlap,
+    std::optional<int> min_y_overlap) const {
+  if (min_y_overlap) {
+    gfx::RangeF vertical_overlap =
+        gfx::RangeF(a.y(), a.bottom())
+            .Intersect(gfx::RangeF(b.y(), b.bottom()));
+    if (vertical_overlap.length() < *min_y_overlap) {
+      return false;
+    }
+  }
+
+  if (min_x_overlap) {
+    gfx::RangeF horizontal_overlap =
+        gfx::RangeF(a.x(), a.right()).Intersect(gfx::RangeF(b.x(), b.right()));
+    if (horizontal_overlap.length() < *min_x_overlap) {
+      return false;
+    }
+  }
+
+  // Neither checks failed, so return `true`.
+  return true;
+}
+
+bool VerticalDraggedTabsContainer::IsHandlingDrag() const {
+  return !dragging_views_.empty();
+}
--- a/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_dragged_tabs_container.h
@@ -63,6 +63,15 @@ class VerticalDraggedTabsContainer : pub
   // ViewObserver
   void OnViewBoundsChanged(views::View* observed_view) override;
 
+  // Whether this container is currently handling a drag.
+  bool IsHandlingDrag() const;
+
+  // Returns the bounds of the box containing all dragged views, adjusted to
+  // the point `point_in_container`. The returned bounds are not clamped to
+  // the container bounds.
+  gfx::Rect GetDraggingViewsBoundsAtPoint(
+      const gfx::Point& point_in_container) const;
+
  protected:
   struct DraggedViewVisualData {
     gfx::Vector2d offset;
@@ -74,15 +83,21 @@ class VerticalDraggedTabsContainer : pub
   std::optional<DraggedViewVisualData> GetVisualDataForDraggedView(
       const views::View& view) const;
 
-  // Returns the bounds of the box containing all dragged views, adjusted to
-  // the point `point_in_container`, and clamped to the bounds of the
-  // container.
-  gfx::Rect GetDraggingViewsBoundsAtPoint(
-      const gfx::Point& point_in_container) const;
-
-  // Helper for getting the view at a given point, excluding dragged views.
-  views::View* GetViewAtPoint(const views::ProposedLayout& layout,
-                              const gfx::Point& point);
+  // Helper for getting the target view for the given drag bounds, excluding
+  // dragged views.
+  views::View* GetViewForDragBounds(const views::ProposedLayout& layout,
+                                    const gfx::Rect& dragged_tab_bounds);
+
+  // Returns whether the two rects overlap by at least the provided minimums for
+  // each axis.
+  // E.g, if only `min_x_overlap` is provided, then this will return true
+  // iff the range of [a.x(), a.right()] overlaps with the range [b.x(),
+  // b.right()]. If both axes are specified, then this must be true for each
+  // respective axis.
+  bool HasMinimumOverlap(const gfx::Rect& a,
+                         const gfx::Rect& b,
+                         std::optional<int> min_x_overlap,
+                         std::optional<int> min_y_overlap) const;
 
  private:
   virtual VerticalTabDragHandler& GetDragHandler() = 0;
@@ -100,7 +115,7 @@ class VerticalDraggedTabsContainer : pub
   // Handles a dragged tab that is parented within this target.
   // `point_in_container` is a point relative to this target's view.
   virtual void HandleTabDragInContainer(
-      const gfx::Point& point_in_container) = 0;
+      const gfx::Rect& dragged_tab_bounds) = 0;
 
   // Updates state related to dragging tabs, to be used when this container
   // starts handling a drag.
@@ -124,6 +139,13 @@ class VerticalDraggedTabsContainer : pub
 
   bool IsHorizontalDragSupported() const;
 
+  // Returns the bounds of the box containing all dragged views, adjusted to
+  // the point `point_in_container` and clamped to the bounds of the
+  // scroll view, which should be used for visual representation of the dragged
+  // views.
+  gfx::Rect GetDraggingViewsBoundsAtPointClamped(
+      const gfx::Point& point_in_container) const;
+
   const raw_ref<const views::View> host_view_;
   int tab_strip_padding_;
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.cc
@@ -166,10 +166,10 @@ void VerticalPinnedTabContainerView::Upd
 }
 
 void VerticalPinnedTabContainerView::HandleTabDragInContainer(
-    const gfx::Point& point_in_container) {
+    const gfx::Rect& dragged_tab_bounds) {
   const views::ProposedLayout& target_layout = layout_manager_->target_layout();
   views::View* view_at_point =
-      GetViewAtPoint(target_layout, point_in_container);
+      GetViewForDragBounds(target_layout, dragged_tab_bounds);
   const TabCollectionNode* node = nullptr;
   if (auto* tab_view = views::AsViewClass<VerticalTabView>(view_at_point)) {
     node = tab_view->collection_node();
--- a/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_pinned_tab_container_view.h
@@ -39,7 +39,7 @@ class VerticalPinnedTabContainerView : p
   bool IsTabStripCollapsed() const override;
   views::ScrollView* GetScrollViewForContainer() const override;
   void UpdateLayoutForDrag() override;
-  void HandleTabDragInContainer(const gfx::Point& point_in_container) override;
+  void HandleTabDragInContainer(const gfx::Rect& dragged_tab_bounds) override;
 
   void ResetCollectionNode();
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_interactive_uitest.cc
@@ -37,6 +37,8 @@
 
 namespace {
 
+enum class DragPosition { kAbove, kBelow };
+
 using URL = std::string_view;
 using TabGroupURLs = std::vector<URL>;
 using URLs = std::vector<std::variant<URL, TabGroupURLs>>;
@@ -201,15 +203,19 @@ class VerticalTabDragHandlerTest
         }));
   }
 
-  auto MoveMouseToTabAsync(int tab_index) {
+  auto MoveMouseToTabAsync(int tab_index, DragPosition position) {
     const char kTabToMoveMouseTo[] = "Tab to move mouse to";
-    return Steps(
-        NameTabViewAt(kTabToMoveMouseTo, tab_index),
-        WithView(
-            kTabToMoveMouseTo, base::BindOnce([](views::View* view) {
-              const gfx::Point point = view->GetBoundsInScreen().CenterPoint();
-              ASSERT_TRUE(ui_controls::SendMouseMove(point.x(), point.y()));
-            })));
+    int offset = 5 * (position == DragPosition::kAbove ? -1 : 1);
+    return Steps(NameTabViewAt(kTabToMoveMouseTo, tab_index),
+                 WithView(kTabToMoveMouseTo,
+                          base::BindOnce(
+                              [](int offset, views::View* view) {
+                                const gfx::Point point =
+                                    view->GetBoundsInScreen().CenterPoint();
+                                ASSERT_TRUE(ui_controls::SendMouseMove(
+                                    point.x(), point.y() + offset));
+                              },
+                              offset)));
   }
 
   auto AddTabsToNewGroup(const std::vector<int>& indices) {
@@ -331,7 +337,8 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
       PollState(kBrowserCountPoller, GetBrowserCount()),
-      WaitForState(kBrowserCountPoller, 2), MoveMouseToTabAsync(1),
+      WaitForState(kBrowserCountPoller, 2),
+      MoveMouseToTabAsync(1, DragPosition::kAbove),
       WaitForState(kBrowserCountPoller, 1), ReleaseMouseAsync(),
       PollState(kDragStatePoller, GetDragActive()),
       WaitForState(kDragStatePoller, false), Do([&]() {
@@ -362,12 +369,12 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       WaitForState(kDragStatePoller, true),
       PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
 
-      MoveMouseToTabAsync(1),
+      MoveMouseToTabAsync(1, DragPosition::kBelow),
       WaitForState(kTabOrderPoller,
                    URLs({url::kAboutBlankURL, chrome::kChromeUISettingsURL,
                          chrome::kChromeUIBookmarksURL})),
 
-      MoveMouseToTabAsync(0),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller,
                    URLs({chrome::kChromeUISettingsURL, url::kAboutBlankURL,
                          chrome::kChromeUIBookmarksURL})),
@@ -453,14 +460,15 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
-      PollState(kDragStatePoller, GetDragActive()), MoveMouseToTabAsync(0),
+      PollState(kDragStatePoller, GetDragActive()),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         chrome::kChromeUISettingsURL,
                                         chrome::kChromeUIVersionURL,
                                         url::kAboutBlankURL,
                                         chrome::kChromeUIBookmarksURL,
                                     })),
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         chrome::kChromeUISettingsURL,
@@ -499,7 +507,8 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
-      PollState(kDragStatePoller, GetDragActive()), MoveMouseToTabAsync(0),
+      PollState(kDragStatePoller, GetDragActive()),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         chrome::kChromeUIBookmarksURL,
                                         url::kAboutBlankURL,
@@ -508,7 +517,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       // Dragging from index 0 to index 2 (split) should put the dragged tab to
       // index 3.
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         chrome::kChromeUISettingsURL,
@@ -517,7 +526,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       // Dragging from index 3 to index 2 (split) should put the dragged tab to
       // index 1.
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         chrome::kChromeUIBookmarksURL,
@@ -559,7 +568,8 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
-      PollState(kDragStatePoller, GetDragActive()), MoveMouseToTabAsync(0),
+      PollState(kDragStatePoller, GetDragActive()),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         chrome::kChromeUIBookmarksURL,
                                         url::kAboutBlankURL,
@@ -570,7 +580,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       // Dragging from index 0 to index 2 (split) should put the dragged tab to
       // index 3.
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         TabGroupURLs({
@@ -581,7 +591,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                     })),
       // Dragging from index 3 to index 2 (split) should put the dragged tab to
       // index 1.
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         TabGroupURLs({
@@ -648,9 +658,9 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       CheckResult(
           [this]() { return browser()->tab_strip_model()->IsTabSelected(2); },
           true),
-      DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
+      DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
-      MoveMouseToTabAsync(0),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
       WaitForState(kTabOrderPoller, URLs({
                                         chrome::kChromeUIBookmarksURL,
@@ -689,7 +699,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
           true),
       DragTabTo(2, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
-      MoveMouseToTabAsync(1),
+      MoveMouseToTabAsync(1, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         url::kAboutBlankURL,
                                         TabGroupURLs({
@@ -698,7 +708,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
                                             chrome::kChromeUIBookmarksURL,
                                         }),
                                     })),
-      MoveMouseToTabAsync(0),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         chrome::kChromeUISettingsURL,
                                         chrome::kChromeUIVersionURL,
@@ -732,7 +742,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       WaitForState(kDragStatePoller, true),
       WaitForState(kBrowserCountPoller, 2),
 
-      MoveMouseToTabAsync(1),
+      MoveMouseToTabAsync(1, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({TabGroupURLs({
                                         url::kAboutBlankURL,
                                         chrome::kChromeUISettingsURL,
@@ -768,7 +778,8 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       DragTabTo(1, GetBrowserView().GetBoundsInScreen().top_right() +
                        gfx::Vector2d(50, 50)),
       PollState(kDragStatePoller, GetDragActive()),
-      WaitForState(kDragStatePoller, true), MoveMouseToTabAsync(2),
+      WaitForState(kDragStatePoller, true),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kTabOrderPoller, URLs({
                                         TabGroupURLs({
                                             url::kAboutBlankURL,
@@ -819,14 +830,14 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
 
       PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
 
-      MoveMouseToTabAsync(0),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kPinnedTabOrderPoller, PinnedURLs({
                                               chrome::kChromeUISettingsURL,
                                               chrome::kChromeUIVersionURL,
                                               url::kAboutBlankURL,
                                               chrome::kChromeUIBookmarksURL,
                                           })),
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kPinnedTabOrderPoller, PinnedURLs({
                                               url::kAboutBlankURL,
                                               chrome::kChromeUISettingsURL,
@@ -867,14 +878,14 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       WaitForState(kDragStatePoller, true),
 
       PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
-      MoveMouseToTabAsync(0),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kPinnedTabOrderPoller, PinnedURLs({
                                               chrome::kChromeUISettingsURL,
                                               chrome::kChromeUIVersionURL,
                                               url::kAboutBlankURL,
                                               chrome::kChromeUIBookmarksURL,
                                           })),
-      MoveMouseToTabAsync(2),
+      MoveMouseToTabAsync(2, DragPosition::kAbove),
       WaitForState(kPinnedTabOrderPoller, PinnedURLs({
                                               url::kAboutBlankURL,
                                               chrome::kChromeUISettingsURL,
@@ -939,7 +950,7 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
 
       // Drag the detached pinned tab over the second unpinned tab in the
       // original window, the pinned tab should remain pinned.
-      MoveMouseToTabAsync(1),
+      MoveMouseToTabAsync(1, DragPosition::kAbove),
       PollState(kPinnedTabOrderPoller, GetPinnedTabOrder(tab_strip_model)),
       PollState(kTabOrderPoller, GetTabOrder(tab_strip_model)),
       WaitForState(kPinnedTabOrderPoller, PinnedURLs({url::kAboutBlankURL})),
@@ -981,13 +992,15 @@ IN_PROC_BROWSER_TEST_F(VerticalTabDragHa
       PollState(kDragStatePoller, GetDragActive()),
       WaitForState(kDragStatePoller, true),
 
-      Log("Moving tabs to index 0"), MoveMouseToTabAsync(0),
+      Log("Moving tabs to index 0"),
+      MoveMouseToTabAsync(0, DragPosition::kAbove),
       WaitForState(kTabOrderPoller,
                    URLs({TabGroupURLs({chrome::kChromeUIBookmarksURL,
                                        chrome::kChromeUISettingsURL}),
                          url::kAboutBlankURL, chrome::kChromeUIVersionURL})),
 
-      Log("Moving tabs to index 3"), MoveMouseToTabAsync(3),
+      Log("Moving tabs to index 3"),
+      MoveMouseToTabAsync(3, DragPosition::kAbove),
       WaitForState(kTabOrderPoller,
                    URLs({url::kAboutBlankURL, chrome::kChromeUIVersionURL,
                          TabGroupURLs({chrome::kChromeUIBookmarksURL,
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.cc
@@ -190,15 +190,8 @@ void VerticalTabGroupView::ToggleCollaps
 
 views::Widget* VerticalTabGroupView::ShowGroupEditorBubble(
     bool stop_context_menu_propagation) {
-  bool is_tab_strip_collapsed = IsTabStripCollapsed();
-  // When the tab strip is collapsed, anchor to the group header, otherwise
-  // anchor to the editor bubble button.
-  views::View* anchor_view =
-      is_tab_strip_collapsed
-          ? static_cast<views::View*>(group_header_)
-          : static_cast<views::View*>(group_header_->editor_bubble_button());
    return collection_node_->GetController()->ShowGroupEditorBubble(
-      GetTabGroupFromNode(collection_node_)->id(), anchor_view,
+      GetTabGroupFromNode(collection_node_)->id(), group_header_,
       stop_context_menu_propagation);
 }
 
@@ -278,9 +271,9 @@ void VerticalTabGroupView::UpdateLayoutF
 }
 
 void VerticalTabGroupView::HandleTabDragInContainer(
-    const gfx::Point& point_in_container) {
-  views::View* view_at_point =
-      GetViewAtPoint(layout_manager_->target_layout(), point_in_container);
+    const gfx::Rect& dragged_tab_bounds) {
+  views::View* view_at_point = GetViewForDragBounds(
+      layout_manager_->target_layout(), dragged_tab_bounds);
   const TabCollectionNode* node = collection_node_;
   if (auto* tab_view = views::AsViewClass<VerticalTabView>(view_at_point)) {
     node = tab_view->collection_node();
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_group_view.h
@@ -58,6 +58,9 @@ class VerticalTabGroupView
   const TabCollectionNode* collection_node() const { return collection_node_; }
 
   VerticalTabGroupHeaderView* group_header() { return group_header_; }
+  const VerticalTabGroupHeaderView* group_header() const {
+    return group_header_;
+  }
 
  private:
   // VerticalDraggedTabsContainer:
@@ -66,7 +69,7 @@ class VerticalTabGroupView
   bool IsTabStripCollapsed() const override;
   views::ScrollView* GetScrollViewForContainer() const override;
   void UpdateLayoutForDrag() override;
-  void HandleTabDragInContainer(const gfx::Point& point_in_container) override;
+  void HandleTabDragInContainer(const gfx::Rect& dragged_tab_bounds) override;
   void OnTabDragExited(const gfx::Point& point_in_screen) override;
 
   void ResetCollectionNode();
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.cc
@@ -27,6 +27,25 @@
 namespace {
 constexpr int kTabVerticalPadding = 2;
 
+// The following are percentages used to determine the amount that dragged
+// tabs must be peeking into/out of a tab group view in order for the handling
+// drag container to change.
+//
+// If the group is handling the drag, then the dragged tabs should
+// exit the group if 10% of the header's height is peeking out of the
+// group.
+//
+// If this (the unpinned tabs container) is handling the drag, then
+// the dragged tabs should enter the group if 40% of the header's height
+// is peeking into the group.
+//
+// The latter percentage should be greater than the former
+// to make it easy to place dragged tabs between two groups.
+constexpr float kMinHeaderHeightPctForGroupExit = 0.1;
+constexpr float kMinHeaderHeightPctForGroupEntry = 0.4;
+static_assert(kMinHeaderHeightPctForGroupExit <
+              kMinHeaderHeightPctForGroupEntry);
+
 class VerticalUnpinnedTabContainerViewTargeter
     : public views::ViewTargeterDelegate {
  public:
@@ -170,10 +189,10 @@ void VerticalUnpinnedTabContainerView::U
 }
 
 void VerticalUnpinnedTabContainerView::HandleTabDragInContainer(
-    const gfx::Point& point_in_container) {
+    const gfx::Rect& dragged_tab_bounds) {
   const views::ProposedLayout& target_layout = layout_manager_->target_layout();
   views::View* view_at_point =
-      GetViewAtPoint(target_layout, point_in_container);
+      GetViewForDragBounds(target_layout, dragged_tab_bounds);
   const TabCollectionNode* node = nullptr;
   if (auto* tab_view = views::AsViewClass<VerticalTabView>(view_at_point)) {
     node = tab_view->collection_node();
@@ -184,14 +203,7 @@ void VerticalUnpinnedTabContainerView::H
     if (group_view->IsCollapsed()) {
       node = group_view->collection_node();
     } else if (GetDragHandler().IsDraggingGroups()) {
-      // For group drag check if the point overlaps with the group's header.
-      auto* group_layout = target_layout.GetLayoutFor(group_view);
-      CHECK(group_layout);
-      if (gfx::Point point_in_group =
-              point_in_container - group_layout->bounds.OffsetFromOrigin();
-          group_view->group_header()->bounds().Contains(point_in_group)) {
-        node = group_view->collection_node();
-      }
+      node = group_view->collection_node();
     }
   } else if (auto* split_tab_view =
                  views::AsViewClass<VerticalSplitTabView>(view_at_point)) {
@@ -213,25 +225,72 @@ VerticalUnpinnedTabContainerView::GetTab
 
   gfx::Point point_in_container =
       views::View::ConvertPointFromScreen(this, point_in_screen);
-  // Use the center of the bounds so views with padding are still targetable
-  // from the sides of the tabstrip.
-  point_in_container.set_x(bounds().x() + bounds().width() / 2);
-
+  std::optional<gfx::Rect> dragging_view_bounds =
+      IsHandlingDrag() ? std::make_optional(
+                             GetDraggingViewsBoundsAtPoint(point_in_container))
+                       : std::nullopt;
   const views::ProposedLayout& target_layout = layout_manager_->target_layout();
   for (const views::ChildLayout& layout : target_layout.child_layouts) {
-    if (!layout.visible || !layout.bounds.Contains(point_in_container) ||
-        IsViewDragging(*layout.child_view)) {
+    if (!layout.visible || IsViewDragging(*layout.child_view)) {
       continue;
     }
-    if (auto* group_view =
-            views::AsViewClass<VerticalTabGroupView>(layout.child_view)) {
-      if (!group_view->IsCollapsed()) {
+    auto* group_view =
+        views::AsViewClass<VerticalTabGroupView>(layout.child_view);
+    if (!group_view || group_view->IsCollapsed()) {
+      continue;
+    }
+
+    if (group_view->IsHandlingDrag()) {
+      if (ShouldDragRemainInGroup(*group_view, layout.bounds,
+                                  point_in_screen)) {
         return *group_view;
+      } else {
+        return *this;
       }
     }
+
+    if (dragging_view_bounds) {
+      const auto required_overlap_amount =
+          group_view->group_header()->height() *
+          kMinHeaderHeightPctForGroupEntry;
+      if (HasMinimumOverlap(*dragging_view_bounds, layout.bounds, std::nullopt,
+                            required_overlap_amount)) {
+        return *group_view;
+      }
+    } else if (layout.bounds.Contains(point_in_container)) {
+      // If neither the group or this container are handling a drag and the drag
+      // point falls in the group (e.g. when starting the drag), then use the
+      // group.
+      return *group_view;
+    }
   }
   return *this;
 }
 
+bool VerticalUnpinnedTabContainerView::ShouldDragRemainInGroup(
+    const VerticalTabGroupView& group_view,
+    const gfx::Rect& proposed_group_bounds,
+    const gfx::Point& point_in_screen) const {
+  gfx::Point point_in_group =
+      views::View::ConvertPointFromScreen(&group_view, point_in_screen);
+  auto dragging_view_bounds_in_group =
+      group_view.GetDraggingViewsBoundsAtPoint(point_in_group);
+  auto dragging_view_bounds_from_group = views::View::ConvertRectToTarget(
+      &group_view, this, dragging_view_bounds_in_group);
+
+  // Note, it's possible the size of the group has not been updated to reflect
+  // that a set of dragged tabs were added, meaning it's possible the height of
+  // the dragged tabs is greater than the height of the group.
+  // For this case, the tabs should remain in the group, even if the required
+  // amount is peeking out, until the group has a chance to update its sizing.
+  const auto required_overlap_amount =
+      dragging_view_bounds_from_group.height() -
+      (group_view.group_header()->height() * kMinHeaderHeightPctForGroupExit);
+
+  return HasMinimumOverlap(dragging_view_bounds_from_group,
+                           proposed_group_bounds, std::nullopt,
+                           required_overlap_amount);
+}
+
 BEGIN_METADATA(VerticalUnpinnedTabContainerView)
 END_METADATA
--- a/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_unpinned_tab_container_view.h
@@ -15,6 +15,7 @@
 
 class TabCollectionNode;
 class VerticalTabDragHandler;
+class VerticalTabGroupView;
 
 // Container for the vertical tabstrip's unpinned tabs.
 class VerticalUnpinnedTabContainerView
@@ -50,7 +51,13 @@ class VerticalUnpinnedTabContainerView
   bool IsTabStripCollapsed() const override;
   views::ScrollView* GetScrollViewForContainer() const override;
   void UpdateLayoutForDrag() override;
-  void HandleTabDragInContainer(const gfx::Point& point_in_container) override;
+  void HandleTabDragInContainer(const gfx::Rect& dragged_tab_bounds) override;
+
+  // Returns whether a drag that is currently being handled by the given
+  // `group_view` should continue being handled by it.
+  bool ShouldDragRemainInGroup(const VerticalTabGroupView& group_view,
+                               const gfx::Rect& proposed_group_bounds,
+                               const gfx::Point& point_in_screen) const;
 
   void ResetCollectionNode();
 
