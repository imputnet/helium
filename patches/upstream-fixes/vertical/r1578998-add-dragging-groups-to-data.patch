From 8d73be4e20eabb5cbf3751ab20e8438567396e35 Mon Sep 17 00:00:00 2001
From: Kaan Alsan <alsan@chromium.org>
Date: Tue, 03 Feb 2026 12:38:14 -0800
Subject: [PATCH] Add "dragging_groups" to DragSessionData to tracked dragged tab groups

Adds a field to cache all of the groups being dragged, which may be used
by a TabDragContext (specifical for VT).

Change-Id: I92951cafd1ee991d9156681aee8552e673550415
Bug: 476084254
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7540882
Reviewed-by: Eshwar Stalin <estalin@chromium.org>
Commit-Queue: Kaan Alsan <alsan@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1578998}
---

--- a/chrome/browser/ui/views/tabs/dragging/drag_session_data.h
+++ b/chrome/browser/ui/views/tabs/dragging/drag_session_data.h
@@ -23,7 +23,7 @@ class TabSlotView;
 class TabDragContext;
 
 // Stores the data associated with a group header that is being dragged.
-struct GroupDragData final {
+struct GroupHeaderDragData final {
   // The group that is being dragged.
   tab_groups::TabGroupId group;
 
@@ -32,7 +32,8 @@ struct GroupDragData final {
   // should fall back on activating the first tab during/after the drag.
   int active_tab_index_within_group;
 
-  GroupDragData(tab_groups::TabGroupId group, int active_tab_index_within_group)
+  GroupHeaderDragData(tab_groups::TabGroupId group,
+                      int active_tab_index_within_group)
       : group(group),
         active_tab_index_within_group(active_tab_index_within_group) {}
 };
@@ -85,7 +86,11 @@ struct DragSessionData final {
   // Data related to the dragged tab group, if any. This is only set if the
   // drag originated from a group header, indicating that the entire group is
   // being dragged together.
-  std::optional<GroupDragData> group_drag_data_ = std::nullopt;
+  std::optional<GroupHeaderDragData> group_header_drag_data_ = std::nullopt;
+
+  // Groups that are being dragged, including header-only drags (in which case
+  // the size of this will be one) or by selecting all tabs in a group.
+  std::set<tab_groups::TabGroupId> dragging_groups;
 
   // Index of the source view in `tab_drag_data_`. This is the view that the
   // user started dragging.
@@ -95,9 +100,9 @@ struct DragSessionData final {
   // height.
   gfx::Vector2dF mouse_offset_to_size_ratios;
 
-  std::optional<tab_groups::TabGroupId> group() const {
-    return group_drag_data_.has_value()
-               ? std::make_optional(group_drag_data_.value().group)
+  std::optional<tab_groups::TabGroupId> group_header_id() const {
+    return group_header_drag_data_.has_value()
+               ? std::make_optional(group_header_drag_data_.value().group)
                : std::nullopt;
   }
 
--- a/chrome/browser/ui/views/tabs/dragging/dragging_tabs_session.cc
+++ b/chrome/browser/ui/views/tabs/dragging/dragging_tabs_session.cc
@@ -133,9 +133,9 @@ void DraggingTabsSession::MoveAttachedIm
               base::TimeTicks::Now()));
     }
 
-    if (drag_data_.group_drag_data_.has_value()) {
-      attached_model->MoveGroupTo(drag_data_.group_drag_data_.value().group,
-                                  to_index);
+    if (drag_data_.group_header_drag_data_.has_value()) {
+      attached_model->MoveGroupTo(
+          drag_data_.group_header_drag_data_.value().group, to_index);
     } else {
       attached_model->MoveSelectedTabsTo(
           to_index, CalculateGroupForDraggedTabs(to_index));
--- a/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
+++ b/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.cc
@@ -443,10 +443,10 @@ TabDragController::Liveness TabDragContr
       std::make_unique<SourceTabStripEmptinessTracker>(
           ref->source_context_->GetTabStripModel(), this);
 
+  const TabStripModel* tab_strip_model =
+      ref->source_context_->GetTabStripModel();
   if (source_view->GetTabSlotViewType() ==
       TabSlotView::ViewType::kTabGroupHeader) {
-    const TabStripModel* tab_strip_model =
-        ref->source_context_->GetTabStripModel();
     const tab_groups::TabGroupId group_id = source_view->group().value();
     const std::optional<tab_groups::TabGroupId> active_group_id =
         tab_strip_model->GetActiveTab()->GetGroup();
@@ -457,13 +457,19 @@ TabDragController::Liveness TabDragContr
          !group_range.is_empty())
             ? tab_strip_model->active_index() - group_range.GetMin()
             : 0;
-    ref->drag_data_.group_drag_data_ = std::make_optional<GroupDragData>(
-        group_id, active_tab_index_within_group);
+    ref->drag_data_.group_header_drag_data_ =
+        std::make_optional<GroupHeaderDragData>(group_id,
+                                                active_tab_index_within_group);
   }
 
   for (TabSlotView* dragging_view : dragging_views) {
     ref->drag_data_.tab_drag_data_.emplace_back(source_context_, dragging_view);
+    if (dragging_view->GetTabSlotViewType() ==
+        TabSlotView::ViewType::kTabGroupHeader) {
+      ref->drag_data_.dragging_groups.insert(*dragging_view->group());
+    }
   }
+
   ref->drag_data_.source_view_index_ =
       std::ranges::find(dragging_views, source_view) - dragging_views.begin();
 
@@ -1923,8 +1929,9 @@ void TabDragController::ResetSelection(T
       // b) this was the source view for the drag
       // c) we're in a header drag, and this tab was active before the drag
       if (!has_one_valid_tab || i == drag_data_.source_view_index_ ||
-          (drag_data_.group_drag_data_.has_value() &&
-           (drag_data_.group_drag_data_.value().active_tab_index_within_group +
+          (drag_data_.group_header_drag_data_.has_value() &&
+           (drag_data_.group_header_drag_data_.value()
+                .active_tab_index_within_group +
             1) == static_cast<int>(i))) {
         // Reset the active/lead to the first tab. If the source tab is still
         // valid we'll reset these again later on.
@@ -2194,7 +2201,7 @@ void TabDragController::CompleteDrag() {
     }
   }
 
-  if (drag_data_.group_drag_data_.has_value()) {
+  if (drag_data_.group_header_drag_data_.has_value()) {
     // Manually reset the selection to just the active tab in the group.
     // For multi tab select keep the selection model as the user used it as the
     // original selection.
@@ -2203,8 +2210,8 @@ void TabDragController::CompleteDrag() {
                                : source_context_->GetTabStripModel();
     ui::ListSelectionModel selection;
     // Offset by 1 to account for the group header.
-    const int drag_data_index =
-        1 + drag_data_.group_drag_data_.value().active_tab_index_within_group;
+    const int drag_data_index = 1 + drag_data_.group_header_drag_data_.value()
+                                        .active_tab_index_within_group;
     const int index = model->GetIndexOfWebContents(
         drag_data_.tab_drag_data_[drag_data_index].contents);
 
@@ -2748,7 +2755,7 @@ void TabDragController::NotifyEventIfTab
 }
 
 void TabDragController::MaybePauseTrackingSavedTabGroup() {
-  if (!drag_data_.group_drag_data_.has_value()) {
+  if (!drag_data_.group_header_drag_data_.has_value()) {
     return;
   }
 
@@ -2761,7 +2768,8 @@ void TabDragController::MaybePauseTracki
       tab_groups::TabGroupSyncServiceFactory::GetForProfile(browser->profile());
 
   if (!tab_group_service ||
-      !tab_group_service->GetGroup(drag_data_.group_drag_data_.value().group)) {
+      !tab_group_service->GetGroup(
+          drag_data_.group_header_drag_data_.value().group)) {
     return;
   }
 
@@ -2769,7 +2777,7 @@ void TabDragController::MaybePauseTracki
 }
 
 void TabDragController::MaybeResumeTrackingSavedTabGroup() {
-  if (!drag_data_.group_drag_data_.has_value() || !observation_pauser_) {
+  if (!drag_data_.group_header_drag_data_.has_value() || !observation_pauser_) {
     return;
   }
 
--- a/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.h
+++ b/chrome/browser/ui/views/tabs/dragging/tab_drag_controller.h
@@ -174,8 +174,8 @@ class TabDragController : public views::
   // Returns the tab group being dragged, if any. Will only return a value if
   // the user is dragging a tab group header, not an individual tab or tabs
   // from a group.
-  const std::optional<tab_groups::TabGroupId> group() const {
-    return drag_data_.group();
+  const std::optional<tab_groups::TabGroupId> group_header_id() const {
+    return drag_data_.group_header_id();
   }
 
   bool IsMovingLastTab() const { return is_moving_last_tab_; }
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_drag_handler.cc
@@ -397,7 +397,7 @@ bool VerticalTabDragHandlerImpl::IsDragg
 
 std::optional<tab_groups::TabGroupId>
 VerticalTabDragHandlerImpl::GetDraggingGroupHeaderId() const {
-  return drag_controller_ ? drag_controller_->GetSessionData().group()
+  return drag_controller_ ? drag_controller_->GetSessionData().group_header_id()
                           : std::nullopt;
 }
 
@@ -540,12 +540,12 @@ void VerticalTabDragHandlerImpl::Stopped
   }
 
   const DragSessionData& drag_data = drag_controller_->GetSessionData();
-  if (!drag_data.group_drag_data_.has_value()) {
+  if (!drag_data.group_header_drag_data_.has_value()) {
     return;
   }
   // Offset by 1 to account for the group header.
   const int drag_data_index =
-      1 + drag_data.group_drag_data_->active_tab_index_within_group;
+      1 + drag_data.group_header_drag_data_->active_tab_index_within_group;
   const int index = tab_strip_model_->GetIndexOfWebContents(
       drag_data.tab_drag_data_[drag_data_index].contents);
 
