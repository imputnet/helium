[Backported to Helium M145]

From 5e72d609bbea389eebec4f6e560c5a19bd6c1b6a Mon Sep 17 00:00:00 2001
From: Eshwar Stalin <estalin@chromium.org>
Date: Mon, 19 Jan 2026 12:59:52 -0800
Subject: [PATCH] Improving tab dragging performance on macOS

Based on profiling tab drag performance for vertical tabs, TabMenuBridge
contributes a significant amount of CPU cycles since its processing each
model update and constantly rebuilding the menu. These real time updates
aren't needed and instead moving towards a lazy model where we update
the menu when needed. This eliminates this from the tab drag critical
path while not regressing functionality.

Change-Id: Ifa0e747453efcde29be8067366b9e05c0e65d1e4
Bug: 476495294
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/7489539
Reviewed-by: Avi Drissman <avi@chromium.org>
Commit-Queue: Eshwar Stalin <estalin@chromium.org>
Reviewed-by: David Pennington <dpenning@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1571331}
---

--- a/chrome/browser/app_controller_mac.mm
+++ b/chrome/browser/app_controller_mac.mm
@@ -1069,12 +1069,13 @@ class AppControllerNativeThemeObserver :
     return;
 
   if (browser->is_type_normal()) {
-    _tabMenuBridge = std::make_unique<TabMenuBridge>(
-        browser->tab_strip_model(),
-        [[NSApp mainMenu] itemWithTag:IDC_TAB_MENU]);
-    _tabMenuBridge->BuildMenu();
-  } else {
-    _tabMenuBridge.reset();
+    if (!_tabMenuBridge) {
+      _tabMenuBridge = std::make_unique<TabMenuBridge>(
+          [[NSApp mainMenu] itemWithTag:IDC_TAB_MENU]);
+    }
+    _tabMenuBridge->SetTabStripModel(browser->tab_strip_model());
+  } else if (_tabMenuBridge) {
+    _tabMenuBridge->SetTabStripModel(nullptr);
   }
 
   Profile* profile = browser->profile();
--- a/chrome/browser/ui/cocoa/tab_menu_bridge.h
+++ b/chrome/browser/ui/cocoa/tab_menu_bridge.h
@@ -25,21 +25,24 @@ class TabStripModel;
 //   2) The number of items not in the "dynamic" part does not change after the
 //      TabMenuBridge is constructed
 //
-// To use this class, construct an instance and call BuildMenu() on it.
+// To use this class, construct an instance and call SetTabStripModel() on it.
 class TabMenuBridge : public TabStripModelObserver {
  public:
   // The |menu_item| contains the actual menu this class manages.
-  TabMenuBridge(TabStripModel* model, NSMenuItem* menu_item);
+  explicit TabMenuBridge(NSMenuItem* menu_item);
 
   TabMenuBridge(const TabMenuBridge&) = delete;
   TabMenuBridge& operator=(const TabMenuBridge&) = delete;
 
   ~TabMenuBridge() override;
 
-  // It's legal to call this method more than once - it will clear all the
-  // existing dynamic items added by this instance before adding any new ones,
-  // so multiple calls are idempotent.
-  void BuildMenu();
+  // Called to update with a new tab strip model associated with the active
+  // browser. This method is idempotent. If there is a new model, it will
+  // clear all the existing dynamic items added before adding new ones for
+  // the new model if `model` isn't nullptr.
+  void SetTabStripModel(TabStripModel* model);
+
+  void SetForceRebuildMenuForTesting(bool force);
 
  private:
   FRIEND_TEST_ALL_PREFIXES(TabMenuBridgeTest, ClickingMenuActivatesTab);
@@ -68,7 +71,7 @@ class TabMenuBridge : public TabStripMod
                               int index) override;
   void OnTabStripModelDestroyed(TabStripModel* model) override;
 
-  raw_ptr<TabStripModel> model_;
+  raw_ptr<TabStripModel> model_ = nullptr;
   NSMenuItem* __weak menu_item_;
   TabMenuListener* __strong menu_listener_;
 
@@ -76,6 +79,10 @@ class TabMenuBridge : public TabStripMod
   // non-dynamic section of the menu. This offset is used to map menu items to
   // their underlying tabs.
   int dynamic_items_start_;
+
+  // Test hook to rebuild menu immediately on modal change instead of doing so
+  // during menu show.
+  bool force_rebuild_menu_for_testing_ = false;
 };
 
 #endif  // CHROME_BROWSER_UI_COCOA_TAB_MENU_BRIDGE_H_
--- a/chrome/browser/ui/cocoa/tab_menu_bridge.mm
+++ b/chrome/browser/ui/cocoa/tab_menu_bridge.mm
@@ -87,29 +87,55 @@ void RemoveMenuItems(NSArray* menu_items
 
 }  // namespace
 
-@interface TabMenuListener : NSObject
-- (instancetype)initWithCallback:(MenuItemCallback)callback;
+@interface TabMenuListener : NSObject <NSMenuDelegate>
+@property(nonatomic, readonly, getter=isMenuOpen) BOOL menuOpen;
+@property(nonatomic, assign) BOOL rebuildMenu;
+
+- (instancetype)initWithCallback:(MenuItemCallback)callback
+                 rebuildCallback:
+                     (base::RepeatingCallback<void()>)rebuildCallback;
 - (void)activateTab:(id)sender;
 @end
 
 @implementation TabMenuListener {
   MenuItemCallback _callback;
+  base::RepeatingCallback<void()> _rebuildCallback;
 }
 
-- (instancetype)initWithCallback:(MenuItemCallback)callback {
+@synthesize menuOpen = _menuOpen;
+@synthesize rebuildMenu = _rebuildMenu;
+
+- (instancetype)initWithCallback:(MenuItemCallback)callback
+                 rebuildCallback:
+                     (base::RepeatingCallback<void()>)rebuildCallback {
   if ((self = [super init])) {
     _callback = callback;
+    _rebuildCallback = rebuildCallback;
   }
   return self;
 }
 
+- (void)menuNeedsUpdate:(NSMenu*)menu {
+  if (_rebuildMenu) {
+    _rebuildCallback.Run();
+    _rebuildMenu = NO;
+  }
+}
+
 - (IBAction)activateTab:(id)sender {
   _callback.Run(sender);
 }
+
+- (void)menuWillOpen:(NSMenu*)menu {
+  _menuOpen = YES;
+}
+
+- (void)menuDidClose:(NSMenu*)menu {
+  _menuOpen = NO;
+}
 @end
 
-TabMenuBridge::TabMenuBridge(TabStripModel* model, NSMenuItem* menu_item)
-    : model_(model), menu_item_(menu_item) {
+TabMenuBridge::TabMenuBridge(NSMenuItem* menu_item) : menu_item_(menu_item) {
   menu_listener_ = [[TabMenuListener alloc]
       initWithCallback:base::BindRepeating(
                            &TabMenuBridge::OnDynamicItemChosen,
@@ -117,20 +143,46 @@ TabMenuBridge::TabMenuBridge(TabStripMod
                            // MenuListener, which holds the callback
                            // being constructed here, so the callback
                            // will be destructed before this class.
+                           base::Unretained(this))
+       rebuildCallback:base::BindRepeating(
+                           &TabMenuBridge::AddDynamicItemsFromModel,
+                           // Unretained is safe here: this class owns
+                           // MenuListener, which holds the callback
+                           // being constructed here, so the callback
+                           // will be destructed before this class.
                            base::Unretained(this))];
-  model_->AddObserver(this);
+  [menu_item_.submenu setDelegate:menu_listener_];
 }
 
 TabMenuBridge::~TabMenuBridge() {
+  [menu_item_.submenu setDelegate:nil];
   if (model_) {
     model_->RemoveObserver(this);
   }
   RemoveMenuItems(DynamicMenuItems());
 }
 
-void TabMenuBridge::BuildMenu() {
-  DCHECK(model_);
-  AddDynamicItemsFromModel();
+void TabMenuBridge::SetTabStripModel(TabStripModel* model) {
+  if (model_ == model) {
+    return;
+  }
+
+  if (model_) {
+    model_->RemoveObserver(this);
+  }
+
+  model_ = model;
+
+  if (model_) {
+    model_->AddObserver(this);
+    AddDynamicItemsFromModel();
+  } else {
+    RemoveMenuItems(DynamicMenuItems());
+  }
+}
+
+void TabMenuBridge::SetForceRebuildMenuForTesting(bool force) {
+  force_rebuild_menu_for_testing_ = force;
 }
 
 NSMutableArray* TabMenuBridge::DynamicMenuItems() {
@@ -148,6 +200,10 @@ NSMutableArray* TabMenuBridge::DynamicMe
 }
 
 void TabMenuBridge::AddDynamicItemsFromModel() {
+  if (!model_) {
+    return;
+  }
+
   NSMutableArray* recyclable_items = DynamicMenuItems();
   NSMenu* tabMenu = menu_item_.submenu;
 
@@ -198,6 +254,11 @@ void TabMenuBridge::OnTabStripModelChang
   DCHECK(tab_strip_model);
   DCHECK_EQ(tab_strip_model, model_);
 
+  if (!force_rebuild_menu_for_testing_ && ![menu_listener_ isMenuOpen]) {
+    [menu_listener_ setRebuildMenu:YES];
+    return;
+  }
+
   // If a single WebContents is being replaced, just regenerate that one menu
   // item.
   if (change.type() == TabStripModelChange::kReplaced) {
@@ -222,6 +283,11 @@ void TabMenuBridge::OnTabChangedAt(tabs:
     return;
   }
 
+  if (!force_rebuild_menu_for_testing_ && ![menu_listener_ isMenuOpen]) {
+    [menu_listener_ setRebuildMenu:YES];
+    return;
+  }
+
   int menu_index = index + dynamic_items_start_;
 
   // It might seem like this can't happen but actually it can:
@@ -246,6 +312,11 @@ void TabMenuBridge::OnTabChangedAt(tabs:
 
 // If a tab group is changed, update group indicator for each tab.
 void TabMenuBridge::OnTabGroupChanged(const TabGroupChange& change) {
+  if (!force_rebuild_menu_for_testing_ && ![menu_listener_ isMenuOpen]) {
+    [menu_listener_ setRebuildMenu:YES];
+    return;
+  }
+
   AddDynamicItemsFromModel();
 }
 
@@ -257,6 +328,14 @@ void TabMenuBridge::TabGroupedStateChang
     std::optional<tab_groups::TabGroupId> new_group,
     tabs::TabInterface* tab,
     int index) {
+  DCHECK(tab_strip_model);
+  DCHECK_EQ(tab_strip_model, model_);
+
+  if (!force_rebuild_menu_for_testing_ && ![menu_listener_ isMenuOpen]) {
+    [menu_listener_ setRebuildMenu:YES];
+    return;
+  }
+
   AddDynamicItemsFromModel();
 }
 
