--- a/chrome/browser/ui/views/side_panel/side_panel.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel.cc
@@ -56,13 +56,12 @@ namespace {
 // This thickness includes the solid-color background and the inner round-rect
 // border-color stroke. It does not include the outer-color separator.
 int GetBorderThickness() {
-  return (lens::features::IsLensOverlayEnabled() ? 8 : 16) +
-         views::Separator::kThickness;
+  return 6;
 }
 
 // This is how many units of the toolbar are essentially expected to be
 // background.
-constexpr int kOverlapFromToolbar = 4;
+constexpr int kOverlapFromToolbar = 3;
 
 // We want the border to visually look like GetBorderThickness() units on all
 // sides. On the top side, background is drawn on top of the top-content
--- a/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
@@ -26,14 +26,13 @@ namespace views {
 
 SidePanelResizeHandle::SidePanelResizeHandle(SidePanel* side_panel)
     : side_panel_(side_panel) {
-  gfx::Size preferred_size((lens::features::IsLensOverlayEnabled() ? 4 : 16),
-                           24);
+  gfx::Size preferred_size(2, 24);
   SetPreferredSize(preferred_size);
   SetCanProcessEventsWithinSubtree(false);
   SetFocusBehavior(FocusBehavior::ALWAYS);
   FocusRing::Install(this);
   if (lens::features::IsLensOverlayEnabled()) {
-    const int resize_handle_left_margin = 2;
+    const int resize_handle_left_margin = 1;
     SetProperty(views::kMarginsKey,
                 gfx::Insets().set_left(resize_handle_left_margin));
   } else {
--- a/chrome/browser/ui/views/frame/contents_rounded_corner.cc
+++ b/chrome/browser/ui/views/frame/contents_rounded_corner.cc
@@ -50,8 +50,7 @@ void ContentsRoundedCorner::Layout(PassK
     path.moveTo(0, 0);
     path.lineTo(local_bounds.width(), 0);
     path.lineTo(local_bounds.width(), local_bounds.height());
-    path.lineTo(local_bounds.width() - views::Separator::kThickness,
-                local_bounds.height());
+    path.lineTo(local_bounds.width(), local_bounds.height());
     path.arcTo(corner_radius, corner_radius, 0, SkPath::kSmall_ArcSize,
                SkPathDirection::kCCW, 0, views::Separator::kThickness);
     path.lineTo(0, 0);
@@ -82,6 +81,7 @@ void ContentsRoundedCorner::OnPaint(gfx:
       GetLayoutProvider()->GetCornerRadiusMetric(corner_radius_token_);
   const gfx::Rect local_bounds = GetLocalBounds();
   SkPath path;
+  if ((false)) {
   if (is_right_aligned_callback_.Run()) {
     path.moveTo(local_bounds.width() - views::Separator::kThickness,
                 local_bounds.height());
@@ -93,6 +93,7 @@ void ContentsRoundedCorner::OnPaint(gfx:
                SkPathDirection::kCCW, views::Separator::kThickness,
                local_bounds.height());
   }
+  }
   canvas->DrawPath(path, flags);
 }
 
