--- a/chrome/browser/ui/views/side_panel/side_panel.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel.cc
@@ -60,12 +60,12 @@ namespace {
 // This thickness includes the solid-color background and the inner round-rect
 // border-color stroke. It does not include the outer-color separator.
 int GetBorderThickness() {
-  return 8 + views::Separator::kThickness;
+  return 6;
 }
 
 // This is how many units of the toolbar are essentially expected to be
 // background.
-constexpr int kOverlapFromToolbar = 4;
+constexpr int kOverlapFromToolbar = 3;
 
 // We want the border to visually look like GetBorderThickness() units on all
 // sides except the top. On the top side, background is drawn on top of the
--- a/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel_resize_area.cc
@@ -26,14 +26,13 @@ namespace views {
 
 SidePanelResizeHandle::SidePanelResizeHandle(SidePanel* side_panel)
     : side_panel_(side_panel) {
-  gfx::Size preferred_size((lens::features::IsLensOverlayEnabled() ? 4 : 16),
-                           24);
+  gfx::Size preferred_size(2, 24);
   SetPreferredSize(preferred_size);
   SetCanProcessEventsWithinSubtree(false);
   SetFocusBehavior(FocusBehavior::ALWAYS);
   FocusRing::Install(this);
   if (lens::features::IsLensOverlayEnabled()) {
-    const int resize_handle_left_margin = 2;
+    const int resize_handle_left_margin = 1;
     SetProperty(views::kMarginsKey,
                 gfx::Insets().set_left(resize_handle_left_margin));
   } else {
--- a/chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc
+++ b/chrome/browser/ui/views/frame/layout/browser_view_layout_impl_old.cc
@@ -613,27 +613,6 @@ void BrowserViewLayoutImplOld::LayoutCon
                           !layout_result.side_panel_right_aligned);
     views().left_aligned_side_panel_separator->SetBoundsRect(
         layout_result.separator_bounds);
-
-    SetViewVisibility(views().side_panel_rounded_corner,
-                      layout_result.side_panel_visible);
-    if (layout_result.side_panel_visible) {
-      // Adjust the rounded corner bounds based on the side panel bounds.
-      const int corner_size =
-          views().side_panel_rounded_corner->GetPreferredSize().width();
-
-      const int top_separator_height = views::Separator::kThickness;
-      if (layout_result.contents_container_after_side_panel) {
-        views().side_panel_rounded_corner->SetBounds(
-            layout_result.side_panel_bounds.right(),
-            layout_result.side_panel_bounds.y() - top_separator_height,
-            corner_size, corner_size);
-      } else {
-        views().side_panel_rounded_corner->SetBounds(
-            layout_result.side_panel_bounds.x() - corner_size,
-            layout_result.side_panel_bounds.y() - top_separator_height,
-            corner_size, corner_size);
-      }
-    }
   }
 }
 
// Reduce minimum acceptable side panel content width without changing the default size.
--- a/chrome/browser/ui/views/side_panel/side_panel.cc
+++ b/chrome/browser/ui/views/side_panel/side_panel.cc
@@ -419,8 +419,7 @@ void SidePanel::UpdateWidthOnEntryChange
   // 1. Use the user's manually resized width
   // 2. Use the side panels default width
   // NOTE: If not specified, the side panel will default to
-  // SidePanelEntry::kSidePanelDefaultContentWidth which evaluates to the same
-  // value as GetMinimumSize().
+  // SidePanelEntry::kSidePanelDefaultContentWidth
   if (std::optional<int> width_from_pref = dict.FindInt(panel_id)) {
     SetPanelWidth(width_from_pref.value());
   } else {
@@ -444,6 +443,13 @@ bool SidePanel::IsRightAligned() const {
 gfx::Size SidePanel::GetMinimumSize() const {
   const int min_height = 0;
   return gfx::Size(
+      SidePanelEntry::kSidePanelMinimumContentWidth + GetBorderInsets().width(),
+      min_height);
+}
+
+gfx::Size SidePanel::GetDefaultSize() const {
+  const int min_height = 0;
+  return gfx::Size(
       SidePanelEntry::kSidePanelDefaultContentWidth + GetBorderInsets().width(),
       min_height);
 }
@@ -614,6 +620,13 @@ void SidePanel::OnResize(int resize_amou
     proposed_width = minimum_width;
   }
 
+  // Snap to default_width if the proposed_width is close enough.
+  const int default_width = GetDefaultSize().width();
+  const int snap_diff = 20;
+  if (abs(proposed_width - default_width) < snap_diff) {
+      proposed_width = default_width;
+  }
+
   if (width() != proposed_width) {
     if (SidePanelUI* side_panel_ui =
             browser_view_->browser()->GetFeatures().side_panel_ui()) {
--- a/chrome/browser/ui/views/side_panel/side_panel_entry.h
+++ b/chrome/browser/ui/views/side_panel/side_panel_entry.h
@@ -38,8 +38,10 @@ class SidePanelEntry final : public ui::
     kToolbar,
   };
 
-  // The default and minimum acceptable side panel content width.
+  // The default side panel content width.
   static constexpr int kSidePanelDefaultContentWidth = 360;
+  // The minimum acceptable side panel content width
+  static constexpr int kSidePanelMinimumContentWidth = 260;
   using CreateContentCallback =
       base::RepeatingCallback<std::unique_ptr<views::View>(
           SidePanelEntryScope&)>;
--- a/chrome/browser/ui/views/side_panel/side_panel.h
+++ b/chrome/browser/ui/views/side_panel/side_panel.h
@@ -51,6 +51,7 @@ class SidePanel : public views::Accessib
   HorizontalAlignment GetHorizontalAlignment() const;
   bool IsRightAligned() const;
   gfx::Size GetMinimumSize() const override;
+  gfx::Size GetDefaultSize() const;
   bool IsClosing();
   void DisableAnimationsForTesting() { animations_disabled_ = true; }
   void SetKeyboardResized(bool keyboard_resized) {
