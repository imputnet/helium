--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -18,17 +18,20 @@ namespace {
 
 // Thickness in DIPs of the separator painted on the left and right edges of
 // the tab.
-constexpr int kChromeRefreshSeparatorThickness = 2;
-constexpr int kChromeRefreshSeparatorHorizontalMargin = 2;
+constexpr int kChromeRefreshSeparatorThickness = 1;
+constexpr int kChromeRefreshSeparatorHorizontalMargin = 5;
 // TODO (crbug.com/1451400): This constant should be in LayoutConstants.
 constexpr int kChromeRefreshSeparatorHeight = 16;
 
 // The padding from the top of the tab to the content area.
 constexpr int kChromeRefreshTabVerticalPadding = 6;
-constexpr int kChromeRefreshTabHorizontalPadding = 8;
+constexpr int kChromeRefreshTabHorizontalPadding = 2;
 
 // The standard tab width is 232 DIP, excluding separators and overlap.
-constexpr int kTabWidth = 232;
+constexpr int kTabWidth = 190;
+
+// Split tabs need more space to be readable
+constexpr int kSplitTabWidth = 250;
 
 }  // namespace
 
@@ -42,7 +45,7 @@ int TabStyle::GetStandardWidth(const boo
   if (is_split) {
     // Split tabs appear as half width with one bottom extension. They also must
     // include half the tab overlap as the tabs fill the space between them.
-    return kTabWidth / 2 + GetBottomCornerRadius() + GetTabOverlap() / 2;
+    return kSplitTabWidth / 2 + GetBottomCornerRadius() + GetTabOverlap() / 2;
   } else {
     // The full width includes two extensions with the bottom corner radius.
     return kTabWidth + 2 * GetBottomCornerRadius();
@@ -90,11 +93,11 @@ int TabStyle::GetMinimumInactiveWidth()
 }
 
 int TabStyle::GetTopCornerRadius() const {
-  return 10;
+  return 8;
 }
 
 int TabStyle::GetBottomCornerRadius() const {
-  return 12;
+  return 8;
 }
 
 int TabStyle::GetTabOverlap() const {
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -198,8 +198,6 @@ SkPath TabStyleViewsImpl::GetPath(TabSty
   CHECK(tab());
   const int stroke_thickness = GetStrokeThickness(flags.force_active);
 
-  const TabStyle::TabSelectionState state = GetSelectionState();
-
   // We'll do the entire path calculation in aligned pixels.
   // TODO(dfried): determine if we actually want to use `stroke_thickness` as
   // the inset in this case.
@@ -210,18 +208,14 @@ SkPath TabStyleViewsImpl::GetPath(TabSty
   // tab width (in DIP), not our new, scaled-and-aligned bounds.
   float content_corner_radius =
       GetTopCornerRadiusForWidth(tab()->width()) * scale;
-  float extension_corner_radius = tab_style()->GetBottomCornerRadius() * scale;
+  float extension_corner_radius = 4 * scale;
 
   const float separator_overlap = (tab_style()->GetSeparatorMargins().width() +
                                    tab_style()->GetSeparatorSize().width()) *
                                   scale;
 
   // Selected, hover, and inactive tab fills are a detached squarcle tab.
-  if ((path_type == TabStyle::PathType::kFill &&
-       state != TabStyle::TabSelectionState::kActive) ||
-      path_type == TabStyle::PathType::kHighlight ||
-      path_type == TabStyle::PathType::kInteriorClip ||
-      path_type == TabStyle::PathType::kHitTest) {
+  if ((true)) {
     float top_left_corner_radius = content_corner_radius;
     float top_right_corner_radius = content_corner_radius;
     float bottom_left_corner_radius = content_corner_radius;
@@ -261,29 +255,6 @@ SkPath TabStyleViewsImpl::GetPath(TabSty
       top_right_corner_radius = 0;
     }
 
-    // While the tab is closing do not add extra space as it degrades the close
-    // tab annimation.
-    if (!tab()->closing()) {
-      // If the size of the space for the path is smaller than the size of a
-      // favicon, if we are building a path for the hit test, or if we are
-      // building a path for a split tab, expand to take the entire width of the
-      // separator margins AND the separator.
-      const bool limited_tab_space =
-          (right - left) < (gfx::kFaviconSize * scale);
-      const bool expand_into_left_separator =
-          limited_tab_space || path_type == TabStyle::PathType::kHitTest ||
-          IsRightSplitTab(tab());
-      const bool expand_into_right_separator =
-          limited_tab_space || path_type == TabStyle::PathType::kHitTest ||
-          IsLeftSplitTab(tab());
-      if (expand_into_left_separator) {
-        left -= separator_overlap / 2.0;
-      }
-      if (expand_into_right_separator) {
-        right += separator_overlap / 2.0;
-      }
-    }
-
     if (tab()->split().has_value()) {
       if (IsLeftSplitTab(tab())) {
         top_right_corner_radius = 0;
@@ -491,19 +462,6 @@ gfx::Insets TabStyleViewsImpl::GetConten
   gfx::Insets base_style_insets = tab_style()->GetContentsInsets();
   gfx::Insets split_insets = gfx::Insets(0);
 
-  // For split tabs, remove insets equal to the total separator width between
-  // them.
-  const float total_separator_width =
-      tab_style()->GetSeparatorMargins().left() +
-      tab_style()->GetSeparatorSize().width() +
-      tab_style()->GetSeparatorMargins().right();
-  if (IsRightSplitTab(tab())) {
-    split_insets.set_left(total_separator_width / -2);
-  }
-  if (IsLeftSplitTab(tab())) {
-    split_insets.set_right(total_separator_width / -2);
-  }
-
   return gfx::Insets::TLBR(
              0, 0, GetLayoutConstant(LayoutConstant::kTabstripToolbarOverlap),
              0) +
@@ -828,13 +786,9 @@ float TabStyleViewsImpl::GetHoverOpacity
 }
 
 int TabStyleViewsImpl::GetStrokeThickness(bool should_paint_as_active) const {
-  std::optional<tab_groups::TabGroupId> group = tab_->group();
-  if (group.has_value() && tab_->IsActive()) {
-    return TabGroupUnderline::kStrokeThickness;
-  }
-
-  if (tab_->IsActive() || should_paint_as_active) {
-    return tab_->controller()->GetStrokeThickness();
+  const bool is_split = IsLeftSplitTab(tab_) || IsRightSplitTab(tab_);
+  if (is_split && tab_->controller()->IsActiveTab(tab_)) {
+    return 1;
   }
 
   return 0;
@@ -917,8 +871,7 @@ void TabStyleViewsImpl::PaintTabBackgrou
   const auto* widget = tab_->GetWidget();
   DCHECK(widget);
   const SkColor tab_stroke_color = widget->GetColorProvider()->GetColor(
-      tab_->GetWidget()->ShouldPaintAsActive() ? kColorTabStrokeFrameActive
-                                               : kColorTabStrokeFrameInactive);
+      kColorToolbarActionItemEngaged);
 
   PaintBackgroundStroke(canvas, selection_state,
                         group_color.value_or(tab_stroke_color));
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -133,6 +133,8 @@ constexpr int kTabAlertIndicatorCloseBut
 // the discard ring by this amount if there is enough space.
 constexpr int kIncreasedDiscardIndicatorRadiusDp = 2;
 
+constexpr int kIndicatorPadding = 2;
+
 bool g_show_hover_card_on_mouse_hover = true;
 
 // Helper functions ------------------------------------------------------------
@@ -433,19 +435,15 @@ void Tab::Layout(PassKey) {
   }
   close_button_->SetVisible(showing_close_button_);
 
+  int alert_indicator_right = contents_rect.right();
   if (showing_alert_indicator_) {
-    int right = contents_rect.right();
-    if (showing_close_button_) {
-      right = close_x;
-      if (extra_alert_indicator_padding_) {
-        right -= ui::TouchUiController::Get()->touch_ui()
-                     ? kTabAlertIndicatorCloseButtonPaddingAdjustmentTouchUI
-                     : kTabAlertIndicatorCloseButtonPaddingAdjustment;
-      }
+    int alert_left = start;
+    if (showing_icon_) {
+      alert_left = favicon_bounds.right() + kIndicatorPadding;
     }
     const gfx::Size image_size = alert_indicator_button_->GetPreferredSize();
     gfx::Rect bounds(
-        std::max(contents_rect.x(), right - image_size.width()),
+        alert_left,
         contents_rect.y() + Center(contents_rect.height(), image_size.height()),
         image_size.width(), image_size.height());
     if (center_icon_) {
@@ -456,6 +454,7 @@ void Tab::Layout(PassKey) {
       MaybeAdjustLeftForPinnedTab(&bounds, bounds.width());
     }
     alert_indicator_button_->SetBoundsRect(bounds);
+    alert_indicator_right = bounds.right();
   }
   alert_indicator_button_->UpdateAlertIndicatorAnimation();
   alert_indicator_button_->SetVisible(showing_alert_indicator_);
@@ -464,7 +463,9 @@ void Tab::Layout(PassKey) {
   bool show_title = ShouldRenderAsNormalTab();
   if (show_title) {
     int title_left = start;
-    if (showing_icon_) {
+    if (showing_alert_indicator_) {
+      title_left = alert_indicator_right + kIndicatorPadding;
+    } else if (showing_icon_) {
       // When computing the spacing from the favicon, don't count the actual
       // icon view width (which will include extra room for the alert
       // indicator), but rather the normal favicon width which is what it will
@@ -475,9 +476,7 @@ void Tab::Layout(PassKey) {
       title_left = std::max(title_left, after_favicon);
     }
     int title_right = contents_rect.right();
-    if (showing_alert_indicator_) {
-      title_right = alert_indicator_button_->x() - after_title_padding;
-    } else if (showing_close_button_) {
+    if (showing_close_button_) {
       // Allow the title to overlay the close button's empty border padding.
       title_right = close_x - after_title_padding;
     }
@@ -1187,7 +1186,7 @@ void Tab::UpdateIconVisibility() {
   const int close_button_width =
       GetLayoutConstant(LayoutConstant::kTabCloseButtonSize) +
       GetLayoutConstant(LayoutConstant::kTabAfterTitlePadding);
-  const bool large_enough_for_close_button =
+  const bool large_enough_for_close_button = mouse_hovered_ &&
       available_width >= (touch_ui ? kTouchMinimumContentsWidthForCloseButtons
                                    : kMinimumContentsWidthForCloseButtons);
 
@@ -1235,6 +1234,10 @@ void Tab::UpdateIconVisibility() {
         large_enough_for_close_button;
     if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons"))
       showing_close_button_ = false;
+
+    if (closing_) {
+      showing_close_button_ = false;
+    }
     if (showing_close_button_) {
       available_width -= close_button_width;
     }
@@ -1252,10 +1255,6 @@ void Tab::UpdateIconVisibility() {
       }
     }
   }
-
-  extra_alert_indicator_padding_ = showing_alert_indicator_ &&
-                                   showing_close_button_ &&
-                                   large_enough_for_close_button;
 }
 
 bool Tab::ShouldRenderAsNormalTab() const {
@@ -1276,15 +1275,29 @@ void Tab::UpdateTabIconNeedsAttentionBlo
 }
 
 int Tab::GetWidthOfLargestSelectableRegion() const {
-  // Assume the entire region to the left of the alert indicator and/or close
-  // buttons is available for click-to-select.  If neither are visible, the
-  // entire tab region is available.
-  const int indicator_left = alert_indicator_button_->GetVisible()
-                                 ? alert_indicator_button_->x()
-                                 : width();
-  const int close_button_left =
-      close_button_->GetVisible() ? close_button_->x() : width();
-  return std::min(indicator_left, close_button_left);
+  // Returns the rightmost boundary of the selectable region, aka
+  // the space where the user can click to select the tab.
+  //
+  // This area is between the alert indicator (if visible) and the close
+  // button (if visible). It's used by AlertIndicatorButton to determine
+  // if there's enough safe click area to enable the mute toggle on
+  // inactive tabs.
+
+  int selectable_region = width();
+
+  if (!ShouldRenderAsNormalTab()) {
+    return selectable_region;
+  }
+
+  if (alert_indicator_button_->GetVisible()) {
+    selectable_region = alert_indicator_button_->bounds().right();
+  }
+
+  if (close_button_->GetVisible()) {
+    selectable_region = std::min(selectable_region, close_button_->x());
+  }
+
+  return selectable_region;
 }
 
 void Tab::UpdateForegroundColors() {
--- a/chrome/browser/ui/views/tabs/tab.h
+++ b/chrome/browser/ui/views/tabs/tab.h
@@ -71,7 +71,7 @@ class Tab : public gfx::AnimationDelegat
   // When the content's width of the tab shrinks to below this size we should
   // hide the close button on inactive tabs. Any smaller and they're too easy
   // to hit on accident.
-  static constexpr int kMinimumContentsWidthForCloseButtons = 68;
+  static constexpr int kMinimumContentsWidthForCloseButtons = 56;
   static constexpr int kTouchMinimumContentsWidthForCloseButtons = 100;
 
   // Sets whether hover cards should appear on mouse hover. Used in browser
--- a/chrome/browser/ui/views/tabs/tab_group_highlight.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_highlight.cc
@@ -48,6 +48,8 @@ void TabGroupHighlight::OnPaint(gfx::Can
 }
 
 SkPath TabGroupHighlight::GetPath() const {
+  return {};
+
   // This path imitates the shape of a tab (see GM2TabStyle::GetPath()). It
   // doesn't reuse the exact same GetPath() function because it doesn't need
   // much of the complexity there. Group highlights only appear on group drag,
--- a/chrome/browser/ui/views/tabs/tab_close_button.cc
+++ b/chrome/browser/ui/views/tabs/tab_close_button.cc
@@ -41,6 +41,8 @@
 
 namespace {
 constexpr gfx::Size kButtonSize = {28, 28};
+const gfx::Insets kInkDropInsets = gfx::Insets::VH(1, 0);
+constexpr int kCornerRadius = 4;
 }  // namespace
 
 TabCloseButton::TabCloseButton(PressedCallback pressed_callback,
@@ -74,8 +76,9 @@ TabCloseButton::TabCloseButton(PressedCa
   // but needs to be explicitly mirrored for RTL.
   // TODO(http://crbug.com/1056490): Make ink drops in RTL work the same way as
   // focus rings.
+
   auto ink_drop_highlight_path =
-      std::make_unique<views::CircleHighlightPathGenerator>(gfx::Insets());
+      std::make_unique<views::RoundRectHighlightPathGenerator>(kInkDropInsets, kCornerRadius);
   ink_drop_highlight_path->set_use_contents_bounds(true);
   ink_drop_highlight_path->set_use_mirrored_rect(true);
   views::HighlightPathGenerator::Install(this,
@@ -85,7 +88,7 @@ TabCloseButton::TabCloseButton(PressedCa
   // TODO(http://crbug.com/1056490): Once this bug is solved and explicit
   // mirroring for ink drops is not needed, we can combine these two.
   auto ring_highlight_path =
-      std::make_unique<views::CircleHighlightPathGenerator>(gfx::Insets());
+      std::make_unique<views::RoundRectHighlightPathGenerator>(kInkDropInsets, kCornerRadius);
   ring_highlight_path->set_use_contents_bounds(true);
   views::FocusRing::Get(this)->SetPathGenerator(std::move(ring_highlight_path));
 
--- a/chrome/browser/ui/views/tabs/tab_group_style.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_style.cc
@@ -92,7 +92,7 @@ gfx::Point TabGroupStyle::GetTitleChipOf
   const int total_space =
       GetLayoutConstant(LayoutConstant::kTabStripHeight) - GetEmptyChipSize() -
       GetLayoutConstant(LayoutConstant::kTabstripToolbarOverlap);
-  return gfx::Point(TabStyle::Get()->GetTabOverlap() - 2, total_space / 2);
+  return gfx::Point(TabStyle::Get()->GetTabOverlap() + 2, total_space / 2);
 }
 
 std::unique_ptr<views::Background> TabGroupStyle::GetEmptyTitleChipBackground(
--- a/chrome/browser/ui/views/tabs/tab_group_underline.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_underline.cc
@@ -80,10 +80,7 @@ gfx::Rect TabGroupUnderline::CalculateTa
   gfx::Rect group_bounds = ToEnclosingRect(leading_bounds);
   group_bounds.UnionEvenIfEmpty(ToEnclosingRect(trailing_bounds));
 
-  const int y = group_bounds.bottom() -
-                GetLayoutConstant(LayoutConstant::kTabstripToolbarOverlap);
-
-  return gfx::Rect(group_bounds.x(), y - kStrokeThickness, group_bounds.width(),
+  return gfx::Rect(group_bounds.x(), 0, group_bounds.width(),
                    kStrokeThickness);
 }
 
@@ -93,22 +90,19 @@ gfx::Insets TabGroupUnderline::GetInsets
   // the group, and may be the right boundary if the group is collapsed.
   const TabGroupHeader* const header =
       views::AsViewClass<TabGroupHeader>(sibling_view);
+
+  const int left_offset = 8;
+  const int right_offset = left_offset - 3;
   if (header) {
-    return gfx::Insets::TLBR(0, TabGroupUnderline::GetStrokeInset(), 0,
-                             TabGroupUnderline::GetStrokeInset());
+    return gfx::Insets::TLBR(0, TabGroupUnderline::GetStrokeInset() + left_offset,
+                            0, TabGroupUnderline::GetStrokeInset() + right_offset);
   }
 
   const Tab* const tab = views::AsViewClass<Tab>(sibling_view);
   DCHECK(tab);
 
-  // Active tabs need the rounded bits of the underline poking out the sides.
-  if (tab->IsActive()) {
-    return gfx::Insets::TLBR(0, -kStrokeThickness, 0, -kStrokeThickness);
-  }
-
-  // Inactive tabs are inset like group headers.
-  const int left_inset = TabGroupUnderline::GetStrokeInset();
-  const int right_inset = TabGroupUnderline::GetStrokeInset();
+  const int left_inset = TabGroupUnderline::GetStrokeInset() + left_offset;
+  const int right_inset = TabGroupUnderline::GetStrokeInset() + right_offset;
 
   return gfx::Insets::TLBR(0, left_inset, 0, right_inset);
 }
@@ -119,8 +113,7 @@ void TabGroupUnderline::MaybeSetVisible(
 
 // static
 int TabGroupUnderline::GetStrokeInset() {
-  return TabStyle::Get()->GetTabOverlap() -
-         TabGroupStyle::GetTabGroupOverlapAdjustment() + kStrokeThickness;
+  return TabStyle::Get()->GetTabOverlap() - 7 + kStrokeThickness;
 }
 
 BEGIN_METADATA(TabGroupUnderline)
--- a/chrome/browser/ui/views/tabs/tab_group_underline.h
+++ b/chrome/browser/ui/views/tabs/tab_group_underline.h
@@ -25,8 +25,7 @@ class TabGroupUnderline : public views::
   METADATA_HEADER(TabGroupUnderline, views::View)
 
  public:
-  static constexpr int kStrokeThickness =
-      views::FocusRing::kDefaultHaloThickness;
+  static constexpr int kStrokeThickness = 1;
 
   static int GetStrokeInset();
 
--- a/chrome/browser/ui/views/tabs/tab_group_header.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_header.cc
@@ -22,6 +22,7 @@
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/tabs/saved_tab_groups/saved_tab_group_utils.h"
+#include "chrome/browser/ui/tabs/tab_group_theme.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/views/tabs/tab_group_editor_bubble_tracker.h"
@@ -78,6 +79,8 @@ namespace {
 // The amount of padding between the label and the sync icon.
 constexpr int kSyncIconPaddingFromLabel = 2;
 
+constexpr int kTabGroupStrokeThickness = 1;
+
 bool SupportsDataSharing() {
   return data_sharing::features::IsDataSharingFunctionalityEnabled();
 }
@@ -419,7 +422,8 @@ bool TabGroupHeader::DoesIntersectRect(c
 
 int TabGroupHeader::GetDesiredWidth() const {
   const int overlap_margin = group_style_->GetTabGroupViewOverlap() * 2;
-  return overlap_margin + title_chip_->width();
+  const int extra_padding = 8;
+  return overlap_margin + extra_padding + title_chip_->width();
 }
 
 void TabGroupHeader::SetCollapsedState() {
@@ -559,7 +563,11 @@ void TabGroupHeader::UpdateTitleView() {
   title_->SetText(group_title_);
 
   if (!group_title_.empty()) {
-    title_->SetEnabledColor(color_utils::GetColorWithMaxContrast(color_));
+    const SkColor text_color = GetColorProvider()->GetColor(
+        GetSavedTabGroupForegroundColorId(
+          tab_slot_controller_->GetGroupColorId(group().value())));
+
+    title_->SetEnabledColor(text_color);
   }
 }
 
@@ -690,8 +698,19 @@ void TabGroupHeader::CreateHeaderWithTit
   const int corner_radius = group_style_->GetChipCornerRadius();
   title_chip_->SetBounds(title_chip_origin.x(), title_chip_origin.y(),
                          title_chip_width, text_height);
+
+  const tab_groups::TabGroupColorId group_color_id =
+      tab_slot_controller_->GetGroupColorId(group().value());
+
+  const SkColor background_color =
+      GetColorProvider()->GetColor(GetTabGroupBookmarkColorId(group_color_id));
+  const SkColor stroke_color =
+      GetColorProvider()->GetColor(GetSavedTabGroupOutlineColorId(group_color_id));
+
   title_chip_->SetBackground(
-      views::CreateRoundedRectBackground(color_, corner_radius));
+      views::CreateRoundedRectBackground(background_color, corner_radius));
+  title_chip_->SetBorder(views::CreateRoundedRectBorder(
+      kTabGroupStrokeThickness, corner_radius, stroke_color));
 
   // Set the bounds of the sync icon first, followed by the title.
   const int start_of_sync_icon = title_chip_insets.left();
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -367,7 +367,7 @@ BASE_FEATURE(kVideoPipForceTrustedForMed
 #endif  // !BUILDFLAG(IS_ANDROID)
 
 // Enables user control over muting tab audio from the tab strip.
-BASE_FEATURE(kEnableTabMuting, base::FEATURE_DISABLED_BY_DEFAULT);
+BASE_FEATURE(kEnableTabMuting, base::FEATURE_ENABLED_BY_DEFAULT);
 
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
 // Enables HEVC hardware accelerated decoding.
--- a/chrome/browser/ui/views/tabs/alert_indicator_button.cc
+++ b/chrome/browser/ui/views/tabs/alert_indicator_button.cc
@@ -245,27 +245,8 @@ void AlertIndicatorButton::TransitionToA
     UpdateIconForAlertState(next_state.value());
   }
 
-  if ((alert_state_ == tabs::TabAlert::kAudioPlaying &&
-       next_state == tabs::TabAlert::kAudioMuting) ||
-      (alert_state_ == tabs::TabAlert::kAudioMuting &&
-       next_state == tabs::TabAlert::kAudioPlaying)) {
-    // Instant user feedback: No fade animation.
-    showing_alert_state_ = next_state;
-    fade_animation_.reset();
-  } else {
-    if (!next_state) {
-      showing_alert_state_ = alert_state_;  // Fading-out indicator.
-    } else {
-      showing_alert_state_ = next_state;  // Fading-in to next indicator.
-    }
-    fade_animation_ = CreateTabAlertIndicatorFadeAnimation(next_state);
-    if (!fade_animation_delegate_) {
-      fade_animation_delegate_ = std::make_unique<FadeAnimationDelegate>(this);
-    }
-    fade_animation_->set_delegate(fade_animation_delegate_.get());
-    fade_animation_->Start();
-  }
-
+  showing_alert_state_ = next_state;
+  fade_animation_.reset();
   alert_state_ = next_state;
 
   if (previous_alert_showing_state != showing_alert_state_) {
@@ -429,20 +410,7 @@ bool AlertIndicatorButton::IsTriggerable
 }
 
 void AlertIndicatorButton::PaintButtonContents(gfx::Canvas* canvas) {
-  double opaqueness = 1.0;
-  if (fade_animation_) {
-    opaqueness = fade_animation_->GetCurrentValue();
-    if (!alert_state_) {
-      opaqueness = 1.0 - opaqueness;  // Fading out, not in.
-    }
-  }
-  if (opaqueness < 1.0) {
-    canvas->SaveLayerAlpha(opaqueness * SK_AlphaOPAQUE);
-  }
   ImageButton::PaintButtonContents(canvas);
-  if (opaqueness < 1.0) {
-    canvas->Restore();
-  }
 }
 
 gfx::ImageSkia AlertIndicatorButton::GetImageToPaint() {
--- a/chrome/browser/ui/views/tabs/browser_tab_strip_controller.cc
+++ b/chrome/browser/ui/views/tabs/browser_tab_strip_controller.cc
@@ -275,14 +275,6 @@ bool BrowserTabStripController::IsBrowse
 
 void BrowserTabStripController::SelectTab(int model_index,
                                           const ui::Event& event) {
-  // When selecting a split tab, activate the most recently focused tab in the
-  // split.
-  std::optional<split_tabs::SplitTabId> split_id =
-      tabstrip_->tab_at(model_index)->split();
-  if (split_id.has_value()) {
-    model_index = split_tabs::GetIndexOfLastActiveTab(model_, split_id.value());
-  }
-
   std::unique_ptr<viz::PeakGpuMemoryTracker> tracker =
       content::PeakGpuMemoryTrackerFactory::Create(
           viz::PeakGpuMemoryTracker::Usage::CHANGE_TAB);
