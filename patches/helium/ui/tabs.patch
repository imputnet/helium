--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -18,17 +18,20 @@ namespace {
 
 // Thickness in DIPs of the separator painted on the left and right edges of
 // the tab.
-constexpr int kChromeRefreshSeparatorThickness = 2;
-constexpr int kChromeRefreshSeparatorHorizontalMargin = 2;
+constexpr int kChromeRefreshSeparatorThickness = 1;
+constexpr int kChromeRefreshSeparatorHorizontalMargin = 1;
 // TODO (crbug.com/1451400): This constant should be in LayoutConstants.
 constexpr int kChromeRefreshSeparatorHeight = 16;
 
 // The padding from the top of the tab to the content area.
 constexpr int kChromeRefreshTabVerticalPadding = 6;
-constexpr int kChromeRefreshTabHorizontalPadding = 8;
+constexpr int kChromeRefreshTabHorizontalPadding = 7;
 
 // The standard tab width is 232 DIP, excluding separators and overlap.
-constexpr int kTabWidth = 232;
+constexpr int kTabWidth = 200;
+
+// Split tabs need more space to be readable
+constexpr int kSplitTabWidth = 250;
 
 }  // namespace
 
@@ -42,7 +45,7 @@ int TabStyle::GetStandardWidth(const boo
   if (is_split) {
     // Split tabs appear as half width with one bottom extension. They also must
     // include half the tab overlap as the tabs fill the space between them.
-    return kTabWidth / 2 + GetBottomCornerRadius() + GetTabOverlap() / 2;
+    return kSplitTabWidth / 2 + GetBottomCornerRadius() + GetTabOverlap() / 2;
   } else {
     // The full width includes two extensions with the bottom corner radius.
     return kTabWidth + 2 * GetBottomCornerRadius();
@@ -104,11 +107,11 @@ int TabStyle::GetMinimumInactiveWidth()
 }
 
 int TabStyle::GetTopCornerRadius() const {
-  return 10;
+  return 8;
 }
 
 int TabStyle::GetBottomCornerRadius() const {
-  return 12;
+  return 8;
 }
 
 int TabStyle::GetTabOverlap() const {
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -205,8 +205,6 @@ SkPath TabStyleViewsImpl::GetPath(TabSty
   CHECK(tab());
   const int stroke_thickness = GetStrokeThickness(force_active);
 
-  const TabStyle::TabSelectionState state = GetSelectionState();
-
   // We'll do the entire path calculation in aligned pixels.
   // TODO(dfried): determine if we actually want to use `stroke_thickness` as
   // the inset in this case.
@@ -224,11 +222,7 @@ SkPath TabStyleViewsImpl::GetPath(TabSty
                                   scale;
 
   // Selected, hover, and inactive tab fills are a detached squarcle tab.
-  if ((path_type == TabStyle::PathType::kFill &&
-       state != TabStyle::TabSelectionState::kActive) ||
-      path_type == TabStyle::PathType::kHighlight ||
-      path_type == TabStyle::PathType::kInteriorClip ||
-      path_type == TabStyle::PathType::kHitTest) {
+  if ((true)) {
     float top_left_corner_radius = content_corner_radius;
     float top_right_corner_radius = content_corner_radius;
     float bottom_left_corner_radius = content_corner_radius;
@@ -839,6 +833,8 @@ float TabStyleViewsImpl::GetHoverOpacity
 }
 
 int TabStyleViewsImpl::GetStrokeThickness(bool should_paint_as_active) const {
+  return 0;
+
   std::optional<tab_groups::TabGroupId> group = tab_->group();
   if (group.has_value() && tab_->IsActive()) {
     return TabGroupUnderline::kStrokeThickness;
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -1164,7 +1164,7 @@ void Tab::UpdateIconVisibility() {
   // left that needs to be considered.
   const int close_button_width = GetLayoutConstant(TAB_CLOSE_BUTTON_SIZE) +
                                  GetLayoutConstant(TAB_AFTER_TITLE_PADDING);
-  const bool large_enough_for_close_button =
+  const bool large_enough_for_close_button = mouse_hovered_ &&
       available_width >= (touch_ui ? kTouchMinimumContentsWidthForCloseButtons
                                    : kMinimumContentsWidthForCloseButtons);
 
@@ -1212,6 +1212,10 @@ void Tab::UpdateIconVisibility() {
         large_enough_for_close_button;
     if (base::CommandLine::ForCurrentProcess()->HasSwitch("hide-tab-close-buttons"))
       showing_close_button_ = false;
+
+    if (closing_) {
+      showing_close_button_ = false;
+    }
     if (showing_close_button_) {
       available_width -= close_button_width;
     }
@@ -1229,10 +1233,6 @@ void Tab::UpdateIconVisibility() {
       }
     }
   }
-
-  extra_alert_indicator_padding_ = showing_alert_indicator_ &&
-                                   showing_close_button_ &&
-                                   large_enough_for_close_button;
 }
 
 bool Tab::ShouldRenderAsNormalTab() const {
--- a/chrome/browser/ui/views/tabs/tab.h
+++ b/chrome/browser/ui/views/tabs/tab.h
@@ -69,7 +69,7 @@ class Tab : public gfx::AnimationDelegat
   // When the content's width of the tab shrinks to below this size we should
   // hide the close button on inactive tabs. Any smaller and they're too easy
   // to hit on accident.
-  static constexpr int kMinimumContentsWidthForCloseButtons = 68;
+  static constexpr int kMinimumContentsWidthForCloseButtons = 42;
   static constexpr int kTouchMinimumContentsWidthForCloseButtons = 100;
 
   // Sets whether hover cards should appear on mouse hover. Used in browser
--- a/chrome/browser/ui/views/tabs/tab_group_highlight.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_highlight.cc
@@ -53,27 +53,8 @@ SkPath TabGroupHighlight::GetPath() cons
   // which is a well-scoped interaction. A dragging group doesn't nestle in with
   // the tabs around it, so there are no special cases needed when determining
   // its shape.
-  const int corner_radius = TabStyle::Get()->GetBottomCornerRadius();
-  const int top = GetLayoutConstant(TAB_STRIP_PADDING);
 
   SkPath path;
-  path.moveTo(0, bounds().height());
-  path.arcTo(corner_radius, corner_radius, 0, SkPath::kSmall_ArcSize,
-             SkPathDirection::kCCW, corner_radius,
-             bounds().height() - corner_radius);
-  path.lineTo(corner_radius, top + corner_radius);
-  path.arcTo(corner_radius, corner_radius, 0, SkPath::kSmall_ArcSize,
-             SkPathDirection::kCW, 2 * corner_radius, top);
-  path.lineTo(bounds().width() - 2 * corner_radius, top);
-  path.arcTo(corner_radius, corner_radius, 0, SkPath::kSmall_ArcSize,
-             SkPathDirection::kCW, bounds().width() - corner_radius,
-             top + corner_radius);
-  path.lineTo(bounds().width() - corner_radius,
-              bounds().height() - corner_radius);
-  path.arcTo(corner_radius, corner_radius, 0, SkPath::kSmall_ArcSize,
-             SkPathDirection::kCCW, bounds().width(), bounds().height());
-  path.close();
-
   return path;
 }
 
--- a/chrome/browser/ui/views/tabs/tab_close_button.cc
+++ b/chrome/browser/ui/views/tabs/tab_close_button.cc
@@ -41,6 +41,8 @@
 namespace {
 constexpr int kIconSize = 16;
 constexpr gfx::Size kButtonSize = {28, 28};
+const gfx::Insets kInkDropInsets = gfx::Insets::VH(1, 0);
+constexpr int kCornerRadius = 4;
 }  // namespace
 
 TabCloseButton::TabCloseButton(PressedCallback pressed_callback,
@@ -69,8 +71,9 @@ TabCloseButton::TabCloseButton(PressedCa
   // but needs to be explicitly mirrored for RTL.
   // TODO(http://crbug.com/1056490): Make ink drops in RTL work the same way as
   // focus rings.
+
   auto ink_drop_highlight_path =
-      std::make_unique<views::CircleHighlightPathGenerator>(gfx::Insets());
+      std::make_unique<views::RoundRectHighlightPathGenerator>(kInkDropInsets, kCornerRadius);
   ink_drop_highlight_path->set_use_contents_bounds(true);
   ink_drop_highlight_path->set_use_mirrored_rect(true);
   views::HighlightPathGenerator::Install(this,
@@ -80,7 +83,7 @@ TabCloseButton::TabCloseButton(PressedCa
   // TODO(http://crbug.com/1056490): Once this bug is solved and explicit
   // mirroring for ink drops is not needed, we can combine these two.
   auto ring_highlight_path =
-      std::make_unique<views::CircleHighlightPathGenerator>(gfx::Insets());
+      std::make_unique<views::RoundRectHighlightPathGenerator>(kInkDropInsets, kCornerRadius);
   ring_highlight_path->set_use_contents_bounds(true);
   views::FocusRing::Get(this)->SetPathGenerator(std::move(ring_highlight_path));
 
--- a/chrome/browser/ui/views/tabs/tab_group_style.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_style.cc
@@ -32,7 +32,7 @@ constexpr int kAttentionIndicatorWidth =
 // The size of the empty chip.
 constexpr int kEmptyChipSize = 20;
 constexpr int kCornerRadius = 6;
-constexpr int kTabGroupOverlapAdjustment = 2;
+constexpr int kTabGroupOverlapAdjustment = 3;
 
 }  // namespace
 
--- a/chrome/browser/ui/views/tabs/tab_group_underline.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_underline.cc
@@ -93,21 +93,17 @@ gfx::Insets TabGroupUnderline::GetInsets
   // the group, and may be the right boundary if the group is collapsed.
   const TabGroupHeader* const header =
       views::AsViewClass<TabGroupHeader>(sibling_view);
+
+  const int left_offset = 3;
   if (header) {
-    return gfx::Insets::TLBR(0, TabGroupUnderline::GetStrokeInset(), 0,
-                             TabGroupUnderline::GetStrokeInset());
+    return gfx::Insets::TLBR(0, TabGroupUnderline::GetStrokeInset() + left_offset,
+                            0, TabGroupUnderline::GetStrokeInset());
   }
 
   const Tab* const tab = views::AsViewClass<Tab>(sibling_view);
   DCHECK(tab);
 
-  // Active tabs need the rounded bits of the underline poking out the sides.
-  if (tab->IsActive()) {
-    return gfx::Insets::TLBR(0, -kStrokeThickness, 0, -kStrokeThickness);
-  }
-
-  // Inactive tabs are inset like group headers.
-  const int left_inset = TabGroupUnderline::GetStrokeInset();
+  const int left_inset = TabGroupUnderline::GetStrokeInset() + left_offset;
   const int right_inset = TabGroupUnderline::GetStrokeInset();
 
   return gfx::Insets::TLBR(0, left_inset, 0, right_inset);
@@ -119,8 +115,7 @@ void TabGroupUnderline::MaybeSetVisible(
 
 // static
 int TabGroupUnderline::GetStrokeInset() {
-  return TabStyle::Get()->GetTabOverlap() -
-         TabGroupStyle::GetTabGroupOverlapAdjustment() + kStrokeThickness;
+  return TabStyle::Get()->GetTabOverlap() - 7 + kStrokeThickness;
 }
 
 BEGIN_METADATA(TabGroupUnderline)
