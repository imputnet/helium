--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -139,11 +139,11 @@ int GetLayoutConstant(LayoutConstant con
     case LayoutConstant::kVerticalTabHeight:
       return 30;
     case LayoutConstant::kVerticalTabMinWidth:
-      return 32;
+      return 30;
     case LayoutConstant::kVerticalTabStripUncollapsedPadding:
-      return 12;
+      return 6;
     case LayoutConstant::kVerticalTabStripCollapsedPadding:
-      return 8;
+      return 4;
     case LayoutConstant::kVerticalTabStripTopButtonIconSize:
       return 20;
     case LayoutConstant::kVerticalTabStripBottomButtonPadding:
--- a/chrome/browser/ui/views/toolbar/toolbar_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_view.cc
@@ -1050,7 +1050,8 @@ void ToolbarView::LayoutCommon() {
                           ? LayoutInset::WEBUI_TAB_STRIP_TOOLBAR_INTERIOR_MARGIN
                           : LayoutInset::TOOLBAR_INTERIOR_MARGIN);
 
-  if (ShouldDisplayToolbarTabStrip()) {
+  if (ShouldDisplayToolbarTabStrip() ||
+        browser_view_->ShouldDrawVerticalTabStrip()) {
     interior_margin = GetLayoutInsets(
         LayoutInset::FULL_TOOLBAR_INTERIOR_MARGIN);
   }
--- a/chrome/browser/ui/views/frame/layout/browser_view_tabbed_layout_impl.cc
+++ b/chrome/browser/ui/views/frame/layout/browser_view_tabbed_layout_impl.cc
@@ -173,13 +173,17 @@ int BrowserViewTabbedLayoutImpl::GetColl
     return 0;
   }
 
-  // If there is no leading exclusion, the tabstrip goes all the way to the top.
-  if (params.leading_exclusion.IsEmpty()) {
+  const auto& exclusion_area = delegate().IsVerticalTabStripRightAligned()
+                                  ? params.trailing_exclusion
+                                  : params.leading_exclusion;
+
+  // If there is no side exclusion, the tabstrip goes all the way to the top.
+  if (exclusion_area.IsEmpty()) {
     return 0;
   }
 
   const int exclusion_height =
-      base::ClampCeil(params.leading_exclusion.ContentWithPadding().height());
+      base::ClampCeil(exclusion_area.ContentWithPadding().height());
 
   // Try to align with toolbar. But if it's not visible, then don't.
   if (!delegate().IsToolbarVisible()) {
@@ -248,6 +252,8 @@ BrowserViewTabbedLayoutImpl::CalculatePr
   BrowserLayoutParams params = browser_params;
   bool needs_exclusion = true;
   const TabStripType tab_strip_type = GetTabStripType();
+  const bool vertical_right_aligned =
+      delegate().IsVerticalTabStripRightAligned();
 
   if (tab_strip_type == TabStripType::kWebUi) {
     // When the WebUI tab strip is present, it does not paint over the caption
@@ -298,6 +304,9 @@ BrowserViewTabbedLayoutImpl::CalculatePr
                    views().browser_view)) {
     gfx::Rect vertical_tab_strip_bounds;
     if (tab_strip_type == TabStripType::kVertical) {
+      const BrowserLayoutExclusionArea& side_exclusion =
+          vertical_right_aligned ? params.trailing_exclusion
+                                 : params.leading_exclusion;
       int vertical_tab_strip_relative_top = 0;
       int vertical_tab_strip_width =
           views().vertical_tab_strip_region_view->GetPreferredSize().width();
@@ -310,17 +319,23 @@ BrowserViewTabbedLayoutImpl::CalculatePr
       } else {
         // Un-collapsed tabstrip must be at least as wide as the caption
         // buttons, if present.
-        const int leading_exclusion_width = base::ClampCeil(
-            params.leading_exclusion.ContentWithPadding().width());
+        const int side_exclusion_width = base::ClampCeil(
+            side_exclusion.ContentWithPadding().width());
         vertical_tab_strip_width =
-            std::max(vertical_tab_strip_width, leading_exclusion_width);
+            std::max(vertical_tab_strip_width, side_exclusion_width);
       }
+      const int vertical_tab_strip_x =
+          vertical_right_aligned
+              ? params.visual_client_area.right() - vertical_tab_strip_width
+              : params.visual_client_area.x();
       vertical_tab_strip_bounds = gfx::Rect(
-          params.visual_client_area.x(),
-          params.visual_client_area.y() + vertical_tab_strip_relative_top,
+          vertical_tab_strip_x, params.visual_client_area.y() +
+            vertical_tab_strip_relative_top,
+          vertical_tab_strip_width, params.visual_client_area.height() -
+            vertical_tab_strip_relative_top);
+      params.InsetHorizontal(
           vertical_tab_strip_width,
-          params.visual_client_area.height() - vertical_tab_strip_relative_top);
-      params.InsetHorizontal(vertical_tab_strip_width, /*leading=*/true);
+          /*leading=*/!vertical_right_aligned);
     }
     layout.AddChild(views().vertical_tab_strip_region_view,
                     vertical_tab_strip_bounds,
@@ -362,16 +377,21 @@ BrowserViewTabbedLayoutImpl::CalculatePr
         GetTopContainerBoundsInParent(top_container_local_bounds, params);
     params.SetTop(top_container_layout.bounds.bottom());
 
-    // Possibly bump the leading margin of the top container out to cover the
+    // Possibly bump the side margin of the top container out to cover the
     // caption buttons, leaving all of the child views in the same absolute
     // position.
     if (collapsed_vertical_tab_strip_adjustment > 0) {
-      top_container_layout.bounds.Outset(
-          gfx::Outsets::TLBR(0, collapsed_vertical_tab_strip_adjustment, 0, 0));
-      for (auto& [child, child_layout] : top_container_layout.children) {
-        if (!child_layout.bounds.IsEmpty()) {
-          child_layout.bounds.Offset(collapsed_vertical_tab_strip_adjustment,
-                                     0);
+      if (vertical_right_aligned) {
+        top_container_layout.bounds.Outset(gfx::Outsets::TLBR(
+            0, 0, 0, collapsed_vertical_tab_strip_adjustment));
+      } else {
+        top_container_layout.bounds.Outset(gfx::Outsets::TLBR(
+            0, collapsed_vertical_tab_strip_adjustment, 0, 0));
+        for (auto& [child, child_layout] : top_container_layout.children) {
+          if (!child_layout.bounds.IsEmpty()) {
+            child_layout.bounds.Offset(collapsed_vertical_tab_strip_adjustment,
+                                       0);
+          }
         }
       }
     }
@@ -647,15 +667,25 @@ BrowserViewTabbedLayoutImpl::CalculatePr
         toolbar_height);
 
     // If the toolbar is not in the browser, then the exclusion isn't either.
-    const int exclusion_width =
-        toolbar_bounds
-            ? std::max(0, base::ClampCeil(browser_params.leading_exclusion
-                                              .ContentWithPadding()
-                                              .width()) -
-                              tabstrip_bounds->x())
-            : 0;
+    int exclusion_width = 0;
+    if (toolbar_bounds) {
+      const BrowserLayoutExclusionArea& side_exclusion =
+          vertical_right_aligned ? browser_params.trailing_exclusion
+                                 : browser_params.leading_exclusion;
+      const int side_exclusion_width =
+          base::ClampCeil(side_exclusion.ContentWithPadding().width());
+      const int side_distance_from_client_edge =
+          vertical_right_aligned
+              ? browser_params.visual_client_area.right() -
+                    tabstrip_bounds->right()
+              : tabstrip_bounds->x();
+      exclusion_width = std::max(
+          0, side_exclusion_width - side_distance_from_client_edge - 10);
+    }
     views().vertical_tab_strip_region_view->SetExclusionWidthForLayout(
         exclusion_width);
+    views().vertical_tab_strip_region_view->SetHasLeadingExclusionForLayout(
+        exclusion_width > 0);
   }
 
   return layout;
@@ -712,7 +742,8 @@ gfx::Rect BrowserViewTabbedLayoutImpl::C
     gfx::Rect toolbar_bounds;
     if (toolbar_visible) {
       // Visually clamp two conflicting margins: window controls & toolbar
-      const int exclusion = tab_strip_type == TabStripType::kToolbar ? 10 : 0;
+      const int exclusion = tab_strip_type == TabStripType::kToolbar ||
+                            tab_strip_type == TabStripType::kVertical ? 10 : 0;
       toolbar_bounds =
           needs_exclusion
               ? GetBoundsWithExclusion(params, views().toolbar, exclusion)
--- a/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.h
+++ b/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.h
@@ -48,11 +48,11 @@ class VerticalTabStripRegionView final :
   static constexpr int kResizeAreaWidth = 6;
   // TODO(crbug.com/465833741): Replace constant with derived value based on
   // caption buttons.
-  static constexpr int kUncollapsedMinWidth = 126;
+  static constexpr int kUncollapsedMinWidth = 160;
   // TODO(crbug.com/465832180): Replace constant based width final max width for
   // view.
   static constexpr int kUncollapsedMaxWidth = 400;
-  static constexpr int kCollapsedWidth = 48;
+  static constexpr int kCollapsedWidth = 38;
   // TODO(crbug.com/465833741): Determine snapping behavior.
   static constexpr int kCollapseSnapWidth =
       (kUncollapsedMinWidth + kCollapsedWidth) / 2;
@@ -134,6 +134,7 @@ class VerticalTabStripRegionView final :
   // the leading, top corner.
   void SetToolbarHeightForLayout(const int toolbar_height);
   void SetExclusionWidthForLayout(const int exclusion_width);
+  void SetHasLeadingExclusionForLayout(bool has_leading_exclusion);
 
   TabDragTarget* GetTabDragTarget(const gfx::Point& point_in_screen);
 
@@ -141,6 +142,8 @@ class VerticalTabStripRegionView final :
   views::View* SetTabStripView(std::unique_ptr<views::View> view);
   void ClearTabStripView(views::View* view);
 
+  void UpdateInteriorMargin();
+
   void OnCollapsedStateChanged(
       tabs::VerticalTabStripStateController* state_controller);
   void UpdateCollapseState(tabs::VerticalTabStripState new_state);
@@ -194,6 +197,9 @@ class VerticalTabStripRegionView final :
   // The width of the exclusion zone. This is used to determine when to toggle
   // the collapse state of the state controller.
   std::optional<int> exclusion_width_ = std::nullopt;
+
+  // Whether a leading exclusion exists due to window controls.
+  bool has_leading_exclusion_ = false;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_FRAME_VERTICAL_TAB_STRIP_REGION_VIEW_H_
--- a/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/vertical_tab_strip_region_view.cc
@@ -20,6 +20,7 @@
 #include "chrome/browser/ui/tabs/tab_group_model.h"
 #include "chrome/browser/ui/tabs/tab_strip_api/tab_strip_service.h"
 #include "chrome/browser/ui/tabs/tab_strip_api/tab_strip_service_feature.h"
+#include "chrome/browser/ui/tabs/vertical_tab_strip_state.h"
 #include "chrome/browser/ui/tabs/vertical_tab_strip_state_controller.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/frame/top_container_background.h"
@@ -52,7 +53,9 @@
 #include "ui/views/view_utils.h"
 
 namespace {
-constexpr int kRegionVerticalPadding = 5;
+constexpr int kRegionVerticalPadding = 3;
+constexpr int kBottomContainerGap = 2;
+constexpr int kDefaultWidthSnapDistance = 6;
 }  // namespace
 
 VerticalTabStripRegionView::VerticalTabStripRegionView(
@@ -91,15 +94,13 @@ VerticalTabStripRegionView::VerticalTabS
       views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
                                views::MaximumFlexSizeRule::kUnbounded));
 
-  top_button_separator_ = AddChildView(std::make_unique<views::Separator>());
-
   gemini_button_ = AddChildView(std::make_unique<views::View>());
 
   resize_area_ = AddChildView(std::make_unique<views::ResizeArea>(this));
   resize_area_->SetProperty(views::kViewIgnoredByLayoutKey, true);
 
   resize_animation_.SetSlideDuration(
-      gfx::Animation::RichAnimationDuration(base::Milliseconds(450)));
+      gfx::Animation::RichAnimationDuration(base::Milliseconds(250)));
   resize_animation_.SetTweenType(gfx::Tween::Type::EASE_IN_OUT_EMPHASIZED);
   resize_animation_.Reset(!state_controller_->IsCollapsed());
 
@@ -148,8 +149,11 @@ void VerticalTabStripRegionView::Layout(
 
   // Manually position the resize area as it overlaps views handled by the flex
   // layout.
-  resize_area_->SetBoundsRect(gfx::Rect(bounds().right() - kResizeAreaWidth, 0,
-                                        kResizeAreaWidth, bounds().height()));
+  const int resize_area_x = state_controller_->IsTabStripRightAligned()
+                                ? 0
+                                : bounds().right() - kResizeAreaWidth;
+  resize_area_->SetBoundsRect(gfx::Rect(resize_area_x, 0, kResizeAreaWidth,
+                                        bounds().height()));
 }
 
 views::View* VerticalTabStripRegionView::GetDefaultFocusableChild() {
@@ -332,7 +336,10 @@ void VerticalTabStripRegionView::OnResiz
   if (!starting_width_on_resize_.has_value()) {
     starting_width_on_resize_ = width();
   }
-  const int proposed_width = starting_width_on_resize_.value() + resize_amount;
+  const int resize_delta = state_controller_->IsTabStripRightAligned()
+                              ? -resize_amount
+                              : resize_amount;
+  const int proposed_width = starting_width_on_resize_.value() + resize_delta;
   if (done_resizing) {
     starting_width_on_resize_ = std::nullopt;
   }
@@ -342,6 +349,19 @@ void VerticalTabStripRegionView::OnResiz
     new_state.collapsed = false;
     new_state.uncollapsed_width =
         std::clamp(proposed_width, kUncollapsedMinWidth, kUncollapsedMaxWidth);
+
+    // Snap to default uncollapsed width if within the snap distance.
+    const int default_uncollapsed_width =
+        tabs::kVerticalTabStripDefaultUncollapsedWidth;
+    const int min_snap_width =
+        default_uncollapsed_width - kDefaultWidthSnapDistance;
+    const int max_snap_width =
+        default_uncollapsed_width + kDefaultWidthSnapDistance;
+    if (new_state.uncollapsed_width >= min_snap_width &&
+        new_state.uncollapsed_width <= max_snap_width) {
+      new_state.uncollapsed_width = default_uncollapsed_width;
+    }
+
     if (done_resizing) {
       // We only want to save the uncollapsed width to the state controller if
       // the user has lifted their mouse, otherwise dragging the resize area to
@@ -410,6 +430,15 @@ void VerticalTabStripRegionView::SetExcl
   top_button_container_->SetExclusionWidthForLayout(exclusion_width);
 }
 
+void VerticalTabStripRegionView::SetHasLeadingExclusionForLayout(
+    bool has_leading_exclusion) {
+  if (has_leading_exclusion_ == has_leading_exclusion) {
+    return;
+  }
+  has_leading_exclusion_ = has_leading_exclusion;
+  UpdateInteriorMargin();
+}
+
 VerticalPinnedTabContainerView*
 VerticalTabStripRegionView::GetPinnedTabsContainer() {
   return tab_strip_view_->GetPinnedTabsContainer();
@@ -431,11 +460,12 @@ views::View* VerticalTabStripRegionView:
       views::FlexSpecification(views::MinimumFlexSizeRule::kScaleToZero,
                                views::MaximumFlexSizeRule::kPreferred));
   tab_strip_view_->SetProperty(views::kMarginsKey,
-                               gfx::Insets::VH(kRegionVerticalPadding, 0));
+      gfx::Insets::TLBR(kRegionVerticalPadding, 0,
+          kBottomContainerGap, 0));
   tab_strip_view_->InitializeTabStrip(*tab_strip_model_);
-  std::optional<size_t> separator_index = GetIndexOf(top_button_separator_);
-  CHECK(separator_index.has_value());
-  ReorderChildView(tab_strip_view_, separator_index.value() + 1);
+  std::optional<size_t> top_container_index = GetIndexOf(top_button_container_);
+  CHECK(top_container_index.has_value());
+  ReorderChildView(tab_strip_view_, top_container_index.value() + 1);
   return tab_strip_view_;
 }
 
@@ -445,6 +475,23 @@ void VerticalTabStripRegionView::ClearTa
   RemoveChildViewT(std::exchange(tab_strip_view_, nullptr));
 }
 
+void VerticalTabStripRegionView::UpdateInteriorMargin() {
+  const int padding = GetLayoutConstant(
+      state_controller_->IsCollapsed()
+          ? LayoutConstant::kVerticalTabStripCollapsedPadding
+          : LayoutConstant::kVerticalTabStripUncollapsedPadding);
+
+  // When collapsed and under the toolbar, the top padding has to be 0
+  // in order to align with webview.
+  int top_padding =
+      state_controller_->IsCollapsed() && has_leading_exclusion_
+          ? 0
+          : kRegionVerticalPadding;
+
+  flex_layout_->SetInteriorMargin(
+      gfx::Insets::TLBR(top_padding, 0, padding, 0));
+}
+
 void VerticalTabStripRegionView::OnCollapsedStateChanged(
     tabs::VerticalTabStripStateController* state_controller) {
   if (target_collapse_state_.collapsed != state_controller->IsCollapsed()) {
@@ -460,16 +507,15 @@ void VerticalTabStripRegionView::OnColla
       state_controller_->IsCollapsed()
           ? LayoutConstant::kVerticalTabStripCollapsedPadding
           : LayoutConstant::kVerticalTabStripUncollapsedPadding);
-  top_button_separator_->SetProperty(
-      views::kMarginsKey, gfx::Insets::VH(kRegionVerticalPadding, padding));
+
   top_button_container_->SetProperty(
       views::kMarginsKey,
       gfx::Insets::TLBR(0, padding, kRegionVerticalPadding, padding));
   bottom_button_container_->SetProperty(
       views::kMarginsKey,
-      gfx::Insets::TLBR(kRegionVerticalPadding, padding, 0, padding));
+      gfx::Insets::TLBR(kBottomContainerGap, padding, 0, padding));
 
-  flex_layout_->SetInteriorMargin(gfx::Insets::VH(padding, 0));
+  UpdateInteriorMargin();
 
   if (tab_strip_view_) {
     tab_strip_view_->SetCollapsedState(state_controller->IsCollapsed());
@@ -510,10 +556,6 @@ void VerticalTabStripRegionView::ResizeT
 }
 
 void VerticalTabStripRegionView::UpdateBackgroundColors() {
-  top_button_separator_->SetColorId(IsFrameActive()
-                                        ? kColorTabDividerFrameActive
-                                        : kColorTabDividerFrameInactive);
-
   SchedulePaint();
 }
 
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_top_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_top_container.cc
@@ -18,7 +18,8 @@
 #include "ui/views/view_class_properties.h"
 
 namespace {
-constexpr int kTopButtonPadding = 4;
+constexpr int kTopButtonPadding = 3;
+constexpr int kCollapsedTopButtonPadding = 2;
 }  // namespace
 
 VerticalTabStripTopContainer::VerticalTabStripTopContainer(
@@ -38,12 +39,6 @@ VerticalTabStripTopContainer::VerticalTa
   collapse_button_ = AddChildButtonFor(kActionToggleCollapseVertical);
   collapse_button_->SetProperty(views::kElementIdentifierKey,
                                 kVerticalTabStripCollapseButtonElementId);
-
-  if (tabs::IsProjectsPanelFeatureEnabled()) {
-    projects_button_ = AddChildButtonFor(kActionToggleProjectsPanel);
-    projects_button_->SetProperty(views::kElementIdentifierKey,
-                                  kVerticalTabStripProjectsButtonElementId);
-  }
 }
 
 VerticalTabStripTopContainer::~VerticalTabStripTopContainer() = default;
@@ -64,11 +59,6 @@ views::ProposedLayout VerticalTabStripTo
   CHECK(collapse_button_);
   container_buttons.push_back(collapse_button_);
 
-  if (tabs::IsProjectsPanelFeatureEnabled()) {
-    CHECK(projects_button_);
-    container_buttons.push_back(projects_button_);
-  }
-
   if (state_controller_->IsCollapsed()) {
     // If the vertical tab strip is collapsed, then lay out the buttons
     // vertically in reverse order from top-to-bottom.
@@ -77,7 +67,7 @@ views::ProposedLayout VerticalTabStripTo
       total_height += container_button->GetPreferredSize().height();
     }
 
-    total_height += (container_buttons.size() - 1) * kTopButtonPadding;
+    total_height += (container_buttons.size() - 1) * kCollapsedTopButtonPadding;
 
     if (total_height > host_size.height()) {
       host_size.set_height(total_height);
@@ -88,52 +78,43 @@ views::ProposedLayout VerticalTabStripTo
     for (views::LabelButton* container_button :
          base::Reversed(container_buttons)) {
       const gfx::Size pref_size = container_button->GetPreferredSize();
+      const int button_size = pref_size.height();
 
-      gfx::Rect bounds((host_size.width() - pref_size.width()) / 2, current_y,
-                       pref_size.width(), pref_size.height());
+      gfx::Rect bounds((host_size.width() - button_size) / 2, current_y,
+                       button_size, button_size);
 
       layout.child_layouts.emplace_back(container_button,
                                         container_button->GetVisible(), bounds,
                                         views::SizeBounds(pref_size));
 
-      current_y += pref_size.height() + kTopButtonPadding;
+      current_y += button_size + kCollapsedTopButtonPadding;
     }
   } else {
-    // If the vertical tab strip is uncollapsed, then lay out the buttons
-    // horizontally from right-to-left.
-    int total_width = exclusion_width_;
-    for (views::LabelButton* container_button : container_buttons) {
-      total_width += container_button->GetPreferredSize().width();
-    }
-
-    total_width += (container_buttons.size() - 1) * kTopButtonPadding;
-
-    // If there is not enough space for the buttons on a single line with
-    // caption buttons, shift them below.
-    if (exclusion_width_ > 0 && total_width > host_size.width()) {
-      host_size.Enlarge(0, toolbar_height_);
-    }
+    const bool is_right_aligned = state_controller_->IsTabStripRightAligned();
+    int current_x = is_right_aligned ? host_size.width() - exclusion_width_
+                                     : exclusion_width_;
 
-    int current_x = host_size.width();
-
-    // Calculate bounds to right-align the button horizontally and center it
-    // vertically within the available space.
-    for (views::LabelButton* container_button : container_buttons) {
+    // Calculate bounds to align buttons against the same edge as the tabstrip,
+    // and center them vertically within the available space.
+    for (views::LabelButton* container_button :
+         base::Reversed(container_buttons)) {
       const gfx::Size pref_size = container_button->GetPreferredSize();
+      const int button_size = pref_size.height();
       gfx::Rect bounds(
-          current_x - pref_size.width(),
+          is_right_aligned ? current_x - button_size : current_x,
           host_size.height() -
               (GetLayoutConstant(
                    LayoutConstant::kVerticalTabStripTopButtonContainerHeight) +
-               pref_size.height()) /
+               button_size) /
                   2,
-          pref_size.width(), pref_size.height());
+          button_size, button_size);
 
       layout.child_layouts.emplace_back(container_button,
                                         container_button->GetVisible(), bounds,
                                         views::SizeBounds(pref_size));
 
-      current_x = bounds.x() - kTopButtonPadding;
+      current_x = is_right_aligned ? bounds.x() - kTopButtonPadding
+                                   : bounds.right() + kTopButtonPadding;
     }
   }
 
@@ -171,10 +152,6 @@ bool VerticalTabStripTopContainer::IsPos
     return false;
   }
 
-  if (projects_button_ && IsHitInView(projects_button_, point)) {
-    return false;
-  }
-
   return true;
 }
 
@@ -185,7 +162,11 @@ void VerticalTabStripTopContainer::SetTo
 
 void VerticalTabStripTopContainer::SetExclusionWidthForLayout(
     const int exclusion_width) {
+  if (exclusion_width_ == exclusion_width) {
+    return;
+  }
   exclusion_width_ = exclusion_width;
+  PreferredSizeChanged();
 }
 
 BEGIN_METADATA(VerticalTabStripTopContainer)
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_view.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_view.cc
@@ -144,12 +144,12 @@ VerticalTabView::VerticalTabView(TabColl
       TabChildConfig(close_button_, kIconDesignWidth, kDefaultPadding,
                      /*align_leading=*/false,
                      /*expand=*/false),
-      TabChildConfig(alert_indicator_, kIconDesignWidth, kDefaultPadding,
-                     /*align_leading=*/false,
-                     /*expand=*/false),
       TabChildConfig(icon_, kIconDesignWidth, kHorizontalInset,
                      /*align_leading=*/true,
                      /*expand=*/false),
+      TabChildConfig(alert_indicator_, kIconDesignWidth, kDefaultPadding,
+                     /*align_leading=*/true,
+                     /*expand=*/false),
       TabChildConfig(title_, kTitleMinWidth, kDefaultPadding,
                      /*align_leading=*/true,
                      /*expand=*/true)};
@@ -343,6 +343,7 @@ void VerticalTabView::RemovedFromWidget(
 
 void VerticalTabView::OnBoundsChanged(const gfx::Rect& previous_bounds) {
   SetClipPath(GetPath());
+  UpdateCloseButtonVisibility();
 }
 
 void VerticalTabView::OnThemeChanged() {
@@ -528,6 +529,9 @@ void VerticalTabView::UpdateAlertIndicat
   alert_indicator_->UpdateAlertIndicatorAnimation();
   bool alert_indicator_visible =
       alert_indicator_->showing_alert_state().has_value();
+  const auto* controller = collection_node_ ? collection_node_->GetController()
+                                            : nullptr;
+  const bool is_collapsed = controller && controller->IsCollapsed();
 
 #if BUILDFLAG(ENABLE_GLIC)
   if (glic_tab_underline_view_ && (alert_indicator_->showing_alert_state() ==
@@ -538,11 +542,20 @@ void VerticalTabView::UpdateAlertIndicat
   }
 #endif
   alert_indicator_->SetVisible(alert_indicator_visible);
-  icon_->SetVisible(!pinned_ || !alert_indicator_visible);
+  const bool should_hide_icon_for_alert = pinned_ || is_collapsed;
+  icon_->SetVisible(!alert_indicator_visible || !should_hide_icon_for_alert);
 }
 
 void VerticalTabView::UpdateCloseButtonVisibility() {
-  close_button_->SetVisible((active_ || hovered_) && !pinned_);
+  // We should show the close button only when:
+  // 1) The tab is wide enough and active OR hovered, or
+  // 2) The tab is small and active AND hovered.
+  // It should not be shown if the tab is pinned.
+
+  const bool title_visible = title_->GetVisible() && title_->width() > 0;
+  const bool show_close_button = !pinned_ &&
+      (title_visible ? (active_ || hovered_) : (active_ && hovered_));
+  close_button_->SetVisible(show_close_button);
 }
 
 void VerticalTabView::UpdateColors() {
--- a/chrome/browser/ui/tabs/vertical_tab_strip_state.h
+++ b/chrome/browser/ui/tabs/vertical_tab_strip_state.h
@@ -7,7 +7,7 @@
 
 namespace tabs {
 
-inline constexpr int kVerticalTabStripDefaultUncollapsedWidth = 240;
+inline constexpr int kVerticalTabStripDefaultUncollapsedWidth = 200;
 
 // Per-window state for the vertical tab strip.
 struct VerticalTabStripState {
--- a/chrome/browser/ui/views/tabs/vertical/bottom_container_button.cc
+++ b/chrome/browser/ui/views/tabs/vertical/bottom_container_button.cc
@@ -20,6 +20,9 @@
 #include "ui/views/view_class_properties.h"
 
 namespace {
+
+constexpr int kIconSize = 14;
+
 class BottomContainerButtonActionViewInterface
     : public views::LabelButtonActionViewInterface {
  public:
@@ -34,8 +37,15 @@ class BottomContainerButtonActionViewInt
     // Calling ButtonActionViewInterface instead of
     // LabelButtonActionViewInterface to avoid the text of the button being set.
     ButtonActionViewInterface::ActionItemChangedImpl(action_item);
-    action_view_->SetImageModel(action_view_->GetState(),
-                                action_item->GetImage());
+
+    if (action_item->GetImage().IsVectorIcon()) {
+      const ui::VectorIconModel vector_icon_model =
+          action_item->GetImage().GetVectorIcon();
+
+      action_view_->SetImageModel(action_view_->GetState(),
+        ui::ImageModel::FromVectorIcon(*vector_icon_model.vector_icon(),
+          kColorToolbarButtonIconDisabled, kIconSize));
+    }
   }
 
  private:
@@ -54,17 +64,7 @@ BottomContainerButton::GetActionViewInte
   return std::make_unique<BottomContainerButtonActionViewInterface>(this);
 }
 
-void BottomContainerButton::OnPaintBackground(gfx::Canvas* canvas) {
-  const SkColor color = GetColorProvider()->GetColor(
-      kColorVerticalTabStripBottomButtonBackground);
-
-  cc::PaintFlags flags;
-  flags.setAntiAlias(true);
-  flags.setStyle(cc::PaintFlags::kFill_Style);
-  flags.setColor(color);
-
-  canvas->sk_canvas()->drawRRect(GetButtonShape(), flags);
-}
+void BottomContainerButton::OnPaintBackground(gfx::Canvas* canvas) {}
 
 bool BottomContainerButton::GetHitTestMask(SkPath* mask) const {
   *mask = SkPath::RRect(GetButtonShape());
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_bottom_container.cc
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_bottom_container.cc
@@ -7,16 +7,23 @@
 #include "chrome/browser/ui/actions/chrome_action_id.h"
 #include "chrome/browser/ui/browser_element_identifiers.h"
 #include "chrome/browser/ui/browser_window/public/browser_window_interface.h"
+#include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/tabs/vertical_tab_strip_state_controller.h"
-#include "chrome/browser/ui/views/bookmarks/saved_tab_groups/saved_tab_group_everything_menu.h"
 #include "chrome/browser/ui/views/tabs/vertical/bottom_container_button.h"
-#include "chrome/browser/ui/views/toolbar/toolbar_ink_drop_util.h"
+#include "chrome/grit/generated_resources.h"
+#include "ui/base/l10n/l10n_util.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
+#include "ui/compositor/layer.h"
 #include "ui/views/actions/action_view_controller.h"
-#include "ui/views/controls/button/menu_button_controller.h"
 #include "ui/views/layout/flex_layout_view.h"
 
+namespace {
+
+constexpr int kBasePadding = 4;
+
+}  // namespace
+
 VerticalTabStripBottomContainer::VerticalTabStripBottomContainer(
     tabs::VerticalTabStripStateController* state_controller,
     actions::ActionItem* root_action_item,
@@ -27,41 +34,12 @@ VerticalTabStripBottomContainer::Vertica
   SetProperty(views::kElementIdentifierKey,
               kVerticalTabStripBottomContainerElementId);
 
-  // Flex Specification for uncollapsed state
-  uncollapsed_flex_specification_ =
-      views::FlexSpecification(views::LayoutOrientation::kHorizontal,
-                               views::MinimumFlexSizeRule::kScaleToZero,
-                               views::MaximumFlexSizeRule::kUnbounded, false,
-                               views::MinimumFlexSizeRule::kPreferred);
-
-  // Flex Specification for collapsed state
-  collapsed_flex_specification_ =
-      views::FlexSpecification(views::LayoutOrientation::kVertical,
-                               views::MinimumFlexSizeRule::kScaleToZero,
-                               views::MaximumFlexSizeRule::kPreferred, false,
-                               views::MinimumFlexSizeRule::kPreferred);
-
   collapsed_state_changed_subscription_ =
       state_controller->RegisterOnStateChanged(base::BindRepeating(
           &VerticalTabStripBottomContainer::OnCollapsedStateChanged,
           base::Unretained(this)));
 
-  tab_group_button_ = AddChildButtonFor(kActionTabGroupsMenu);
-
-  // Creating MenuButtonController because tab_group_button is a LabelButton.
-  auto controller = std::make_unique<views::MenuButtonController>(
-      tab_group_button_,
-      base::BindRepeating(&VerticalTabStripBottomContainer::ShowEverythingMenu,
-                          base::Unretained(this)),
-      std::make_unique<views::Button::DefaultButtonControllerDelegate>(
-          tab_group_button_));
-  everything_menu_controller_ = controller.get();
-
-  tab_group_button_->SetButtonController(std::move(controller));
-  tab_group_button_->SetProperty(views::kElementIdentifierKey,
-                                 kSavedTabGroupButtonElementId);
-
-  new_tab_button_ = AddChildButtonFor(kActionNewTab);
+  new_tab_button_ = AddChildButtonFor(kActionNewTab, IDS_ACCNAME_NEWTAB);
   new_tab_button_->SetProperty(views::kElementIdentifierKey,
                                kNewTabButtonElementId);
 
@@ -71,7 +49,8 @@ VerticalTabStripBottomContainer::Vertica
 VerticalTabStripBottomContainer::~VerticalTabStripBottomContainer() = default;
 
 BottomContainerButton* VerticalTabStripBottomContainer::AddChildButtonFor(
-    actions::ActionId action_id) {
+    actions::ActionId action_id,
+    int string_id) {
   std::unique_ptr<BottomContainerButton> container_button =
       std::make_unique<BottomContainerButton>();
   actions::ActionItem* action_item =
@@ -81,28 +60,25 @@ BottomContainerButton* VerticalTabStripB
   action_view_controller_->CreateActionViewRelationship(
       container_button.get(), action_item->GetAsWeakPtr());
 
+  container_button->SetText(l10n_util::GetStringUTF16(string_id));
+  container_button->SetEnabledTextColors(
+      kColorToolbarButtonIconDisabled);
+  container_button->SetTextColor(views::Button::STATE_DISABLED,
+      kColorToolbarButtonIconDisabled);
+
+  container_button->SetBorder(views::CreateEmptyBorder(
+      gfx::Insets::VH(kBasePadding, kBasePadding * 2)));
+  container_button->SetImageLabelSpacing(kBasePadding * 2);
+
   raw_ptr<BottomContainerButton> raw_container_button =
       AddChildView(std::move(container_button));
 
   raw_container_button->SetHorizontalAlignment(
-      gfx::HorizontalAlignment::ALIGN_CENTER);
+      gfx::HorizontalAlignment::ALIGN_LEFT);
 
   return raw_container_button;
 }
 
-void VerticalTabStripBottomContainer::ShowEverythingMenu() {
-  if (everything_menu_ && everything_menu_->IsShowing()) {
-    return;
-  }
-
-  // Creating everything menu.
-  everything_menu_ = std::make_unique<tab_groups::STGEverythingMenu>(
-      everything_menu_controller_, browser_->GetBrowserForMigrationOnly(),
-      tab_groups::STGEverythingMenu::MenuContext::kVerticalTabStrip);
-
-  everything_menu_->RunMenu();
-}
-
 bool VerticalTabStripBottomContainer::IsPositionInWindowCaption(
     const gfx::Point& point) {
   for (views::View* child : children()) {
@@ -133,42 +109,16 @@ void VerticalTabStripBottomContainer::Up
                           ? views::LayoutAlignment::kStretch
                           : views::LayoutAlignment::kStart);
 
-  if (controller->IsCollapsed()) {
-    // If collapsed, the tab group button and the new tab button share the same
-    // weights. The flat edge is inverse to the position: tab group button is
-    // placed on top so the flat edge is on the bottom.
-    tab_group_button_->SetProperty(views::kFlexBehaviorKey,
-                                   collapsed_flex_specification_.WithWeight(1));
-    tab_group_button_->SetFlatEdge(BottomContainerButton::FlatEdge::kBottom);
-
-    new_tab_button_->SetProperty(views::kFlexBehaviorKey,
-                                 collapsed_flex_specification_.WithWeight(1));
-    new_tab_button_->SetProperty(
-        views::kMarginsKey,
-        gfx::Insets::TLBR(
-            GetLayoutConstant(
-                LayoutConstant::kVerticalTabStripCollapsedBottomButtonPadding),
-            0, 0, 0));
-    new_tab_button_->SetFlatEdge(BottomContainerButton::FlatEdge::kTop);
-  } else {
-    // If uncollapsed, the tab group button and the new tab button are set with
-    // weights 1 and 2, respectively. Flat edges should be reset and padding
-    // is moved from top to left.
-    tab_group_button_->SetProperty(
-        views::kFlexBehaviorKey, uncollapsed_flex_specification_.WithWeight(1));
-    tab_group_button_->SetFlatEdge(BottomContainerButton::FlatEdge::kNone);
-
-    new_tab_button_->SetProperty(views::kFlexBehaviorKey,
-                                 uncollapsed_flex_specification_.WithWeight(2));
-    new_tab_button_->SetProperty(
-        views::kMarginsKey,
-        gfx::Insets::TLBR(
-            0,
-            GetLayoutConstant(
-                LayoutConstant::kVerticalTabStripBottomButtonPadding),
-            0, 0));
-    new_tab_button_->SetFlatEdge(BottomContainerButton::FlatEdge::kNone);
-  }
+  const int height = GetLayoutConstant(LayoutConstant::kVerticalTabHeight);
+  views::FlexSpecification flex_spec(
+      views::LayoutOrientation::kHorizontal,
+      views::MinimumFlexSizeRule::kScaleToZero,
+      views::MaximumFlexSizeRule::kUnbounded, false,
+      views::MinimumFlexSizeRule::kPreferred);
+  new_tab_button_->SetProperty(views::kFlexBehaviorKey,
+                               flex_spec.WithWeight(1));
+  new_tab_button_->SetPreferredSize(gfx::Size(-1, height));
+  new_tab_button_->SetFlatEdge(BottomContainerButton::FlatEdge::kNone);
 }
 
 BEGIN_METADATA(VerticalTabStripBottomContainer)
--- a/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_bottom_container.h
+++ b/chrome/browser/ui/views/tabs/vertical/vertical_tab_strip_bottom_container.h
@@ -14,13 +14,8 @@ namespace tabs {
 class VerticalTabStripStateController;
 }  // namespace tabs
 
-namespace tab_groups {
-class STGEverythingMenu;
-}  // namespace tab_groups
-
 namespace views {
 class ActionViewController;
-class MenuButtonController;
 }  // namespace views
 
 // Bottom container of the vertical tab strip, manages the new tab and tab group
@@ -34,9 +29,8 @@ class VerticalTabStripBottomContainer :
       BrowserWindowInterface* browser);
   ~VerticalTabStripBottomContainer() override;
 
-  BottomContainerButton* AddChildButtonFor(actions::ActionId action_id);
-
-  void ShowEverythingMenu();
+  BottomContainerButton* AddChildButtonFor(actions::ActionId action_id,
+                                            int message_id);
 
   bool IsPositionInWindowCaption(const gfx::Point& point);
 
@@ -49,15 +43,9 @@ class VerticalTabStripBottomContainer :
 
   raw_ptr<actions::ActionItem> root_action_item_ = nullptr;
   raw_ptr<BottomContainerButton> new_tab_button_ = nullptr;
-  raw_ptr<BottomContainerButton> tab_group_button_ = nullptr;
   raw_ptr<BrowserWindowInterface> browser_ = nullptr;
-  raw_ptr<views::MenuButtonController> everything_menu_controller_ = nullptr;
   base::CallbackListSubscription collapsed_state_changed_subscription_;
 
-  views::FlexSpecification uncollapsed_flex_specification_;
-  views::FlexSpecification collapsed_flex_specification_;
-
-  std::unique_ptr<tab_groups::STGEverythingMenu> everything_menu_;
   std::unique_ptr<views::ActionViewController> action_view_controller_;
 };
 
--- a/chrome/browser/ui/views/frame/multi_contents_view.h
+++ b/chrome/browser/ui/views/frame/multi_contents_view.h
@@ -125,6 +125,7 @@ class MultiContentsView : public views::
   void OnResize(int resize_amount, bool done_resizing) override;
 
   // views::View:
+  void Layout(PassKey pass_key) override;
   void OnThemeChanged() override;
 
   std::vector<ContentsContainerView*> contents_container_views() const {
--- a/chrome/browser/ui/views/frame/multi_contents_view.cc
+++ b/chrome/browser/ui/views/frame/multi_contents_view.cc
@@ -337,6 +337,11 @@ void MultiContentsView::OnResize(int res
   }
 }
 
+void MultiContentsView::Layout(PassKey pass_key) {
+  LayoutSuperclass<views::View>(this);
+  UpdateContentsBorderAndOverlay();
+}
+
 double MultiContentsView::CalculateRatioWithSnapPoints(
     double end_width,
     double total_width) const {
@@ -617,11 +622,10 @@ int MultiContentsView::GetMinViewWidth(g
 
 void MultiContentsView::UpdateContentsBorderAndOverlay() {
   for (auto* contents_container_view : contents_container_views_) {
-    const bool is_active =
-        contents_container_view->contents_view() == GetActiveContentsView();
+    const bool is_first_view =
+        contents_container_view == contents_container_views_.front();
     contents_container_view->UpdateBorderAndOverlay(
-        IsInSplitView(), is_active,
-        is_active && active_contents_view_highlighted_);
+        IsInSplitView(), is_first_view);
   }
 }
 
--- a/chrome/browser/ui/views/frame/contents_container_view.h
+++ b/chrome/browser/ui/views/frame/contents_container_view.h
@@ -8,6 +8,7 @@
 #include <memory>
 #include <optional>
 
+#include "base/callback_list.h"
 #include "base/memory/raw_ptr.h"
 #include "base/scoped_observation.h"
 #include "chrome/browser/devtools/devtools_contents_resizing_strategy.h"
@@ -19,10 +20,15 @@
 class BrowserView;
 class ContentsContainerOutline;
 class ContentsWebView;
+class LeadingCornerFillView;
 class MultiContentsViewMiniToolbar;
 class ScrimView;
 class ActorOverlayWebView;
 
+namespace tabs {
+class VerticalTabStripStateController;
+}  // namespace tabs
+
 namespace gfx {
 class Rect;
 }  // namespace gfx
@@ -109,9 +115,7 @@ class ContentsContainerView : public vie
                               SkColor outline_color,
                               int font_size);
 
-  void UpdateBorderAndOverlay(bool is_in_split,
-                              bool is_active,
-                              bool is_highlighted);
+  void UpdateBorderAndOverlay(bool is_in_split, bool is_first_view);
 
   void ShowCaptureContentsBorder();
   void HideCaptureContentsBorder();
@@ -129,9 +133,10 @@ class ContentsContainerView : public vie
   // the bounds of contents_webview relative to the local bounds of the
   // container that holds both contents_webview and devtools_webview.
   void UpdateDevToolsDockedPlacement();
+  void OnVerticalTabStripStateChanged(
+      tabs::VerticalTabStripStateController*);
 
   // views::View:
-  void ChildVisibilityChanged(View* child) override;
   void Layout(PassKey) override;
 
   // views::ViewObserver:
@@ -142,6 +147,7 @@ class ContentsContainerView : public vie
       const views::SizeBounds& size_bounds) const override;
 
   bool is_in_split_ = false;
+  bool is_first_view_ = false;
 
   raw_ptr<BrowserView> browser_view_ = nullptr;
   raw_ptr<ContentsWebView> contents_view_ = nullptr;
@@ -173,6 +179,9 @@ class ContentsContainerView : public vie
   // open.
   raw_ptr<ScrimView> contents_scrim_view_ = nullptr;
 
+  // Overlay rounded corner used in vertical layout.
+  raw_ptr<LeadingCornerFillView> leading_corner_fill_view_ = nullptr;
+
   // The view that contains the Glic Actor Overlay. The Actor Overlay is a UI
   // overlay that is shown on top of the web contents.
   raw_ptr<ActorOverlayWebView> actor_overlay_web_view_ = nullptr;
@@ -185,6 +194,7 @@ class ContentsContainerView : public vie
 
   DevToolsContentsResizingStrategy strategy_;
   base::ScopedObservation<View, ViewObserver> view_bounds_observer_{this};
+  base::CallbackListSubscription vertical_tab_strip_state_subscription_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_FRAME_CONTENTS_CONTAINER_VIEW_H_
--- a/chrome/browser/ui/views/frame/contents_container_view.cc
+++ b/chrome/browser/ui/views/frame/contents_container_view.cc
@@ -7,13 +7,18 @@
 #include <memory>
 #include <optional>
 
+#include "base/functional/bind.h"
+#include "base/i18n/rtl.h"
+#include "base/scoped_observation.h"
 #include "chrome/browser/actor/ui/actor_overlay_web_view.h"
 #include "chrome/browser/devtools/devtools_contents_resizing_strategy.h"
 #include "chrome/browser/enterprise/watermark/watermark_view.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser_element_identifiers.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
+#include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/read_anything/read_anything_immersive_overlay_view.h"
+#include "chrome/browser/ui/tabs/vertical_tab_strip_state_controller.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/view_ids.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
@@ -28,13 +33,17 @@
 #include "chrome/common/chrome_features.h"
 #include "components/search/ntp_features.h"
 #include "content/public/browser/web_contents.h"
+#include "third_party/skia/include/core/SkPathBuilder.h"
+#include "third_party/skia/include/core/SkRRect.h"
 #include "ui/accessibility/accessibility_features.h"
+#include "ui/base/metadata/metadata_header_macros.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
 #include "ui/color/color_provider.h"
 #include "ui/compositor/layer.h"
 #include "ui/gfx/geometry/insets.h"
 #include "ui/gfx/geometry/rect.h"
-#include "ui/views/border.h"
+#include "ui/gfx/geometry/skia_conversions.h"
+#include "ui/gfx/scoped_canvas.h"
 #include "ui/views/layout/delegating_layout_manager.h"
 #include "ui/views/layout/fill_layout.h"
 #include "ui/views/layout/proposed_layout.h"
@@ -42,6 +51,7 @@
 #include "ui/views/view.h"
 #include "ui/views/view_class_properties.h"
 #include "ui/views/widget/widget.h"
+#include "ui/views/widget/widget_observer.h"
 
 #if BUILDFLAG(ENABLE_GLIC)
 #include "chrome/browser/glic/browser_ui/context_sharing_border_view.h"
@@ -58,6 +68,107 @@ constexpr int kNewTabFooterSeparatorHeig
 constexpr int kNewTabFooterHeight = 56;
 }  // namespace
 
+class LeadingCornerFillView final : public views::View,
+                                    public views::WidgetObserver {
+  METADATA_HEADER(LeadingCornerFillView, views::View)
+
+ public:
+  LeadingCornerFillView() {
+    SetPaintToLayer();
+    layer()->SetFillsBoundsOpaquely(false);
+    SetCanProcessEventsWithinSubtree(false);
+    SetVisible(false);
+  }
+
+  gfx::Size CalculatePreferredSize(const views::SizeBounds&) const override {
+    return gfx::Size(corner_radius_, corner_radius_);
+  }
+
+  void SetCornerRadius(int corner_radius) {
+    if (corner_radius_ == corner_radius) {
+      return;
+    }
+    corner_radius_ = corner_radius;
+    SetVisible(corner_radius_ > 0);
+    PreferredSizeChanged();
+    SchedulePaint();
+  }
+
+  void SetCornerOnRight(bool corner_on_right) {
+    if (corner_on_right_ == corner_on_right) {
+      return;
+    }
+    corner_on_right_ = corner_on_right;
+    PreferredSizeChanged();
+    SchedulePaint();
+  }
+
+  bool IsCornerOnRight() const { return corner_on_right_; }
+
+  void OnThemeChanged() override {
+    View::OnThemeChanged();
+    SchedulePaint();
+  }
+
+  void AddedToWidget() override {
+    View::AddedToWidget();
+    if (auto* widget = GetWidget()) {
+      widget_observation_.Observe(widget);
+    }
+  }
+
+  void RemovedFromWidget() override {
+    widget_observation_.Reset();
+    View::RemovedFromWidget();
+  }
+
+  void OnPaint(gfx::Canvas* canvas) override {
+    if (corner_radius_ <= 0) {
+      return;
+    }
+
+    const float corner_radius = static_cast<float>(corner_radius_);
+    const bool is_rtl = base::i18n::IsRTL();
+    const bool corner_on_right = is_rtl ? !corner_on_right_ : corner_on_right_;
+    const SkVector rounded_vector = {corner_radius, corner_radius};
+    const SkVector radii[4] = {
+        corner_on_right ? SkVector{0, 0} : rounded_vector,
+        corner_on_right ? rounded_vector : SkVector{0, 0},
+        {0, 0},
+        {0, 0},
+    };
+
+    const SkRect bounds = gfx::RectToSkRect(GetLocalBounds());
+    SkPathBuilder path;
+    path.addRect(bounds);
+    path.addRRect(SkRRect::MakeRectRadii(bounds, radii));
+    SkPath outer_corner_path = path.detach();
+    outer_corner_path.setFillType(SkPathFillType::kEvenOdd);
+
+    gfx::ScopedCanvas scoped_canvas(canvas);
+    canvas->ClipPath(outer_corner_path, /*anti_alias=*/true);
+    canvas->DrawColor(GetColorProvider()->GetColor(
+        GetWidget() && !GetWidget()->ShouldPaintAsActive()
+            ? ui::kColorFrameInactive
+            : ui::kColorFrameActive));
+  }
+
+  // views::WidgetObserver:
+  void OnWidgetActivationChanged(views::Widget* /*widget*/,
+                                 bool /*active*/) override {
+    SchedulePaint();
+  }
+
+ private:
+  int corner_radius_ = 0;
+  bool corner_on_right_ = false;
+  base::ScopedObservation<views::Widget, views::WidgetObserver>
+      widget_observation_{this};
+};
+
+BEGIN_METADATA(LeadingCornerFillView)
+END_METADATA
+
 ContentsContainerView::ContentsContainerView(BrowserView* browser_view)
     : browser_view_(browser_view),
       web_contents_modal_dialog_host_(browser_view_, this) {
@@ -81,6 +192,8 @@ ContentsContainerView::ContentsContainer
   contents_view_ = AddChildView(
       std::make_unique<ContentsWebView>(browser_view->GetProfile()));
   contents_view_->SetID(VIEW_ID_TAB_CONTAINER);
+  leading_corner_fill_view_ =
+      AddChildView(std::make_unique<LeadingCornerFillView>());
 
   if (base::FeatureList::IsEnabled(ntp_features::kNtpFooter)) {
     new_tab_footer_view_separator_ =
@@ -130,6 +243,15 @@ ContentsContainerView::ContentsContainer
 #endif
 
   view_bounds_observer_.Observe(contents_view_);
+
+  auto* vertical_controller =
+      tabs::VerticalTabStripStateController::From(browser_view_->browser());
+  if (vertical_controller) {
+    vertical_tab_strip_state_subscription_ =
+        vertical_controller->RegisterOnStateChanged(base::BindRepeating(
+            &ContentsContainerView::OnVerticalTabStripStateChanged,
+            base::Unretained(this)));
+  }
 }
 
 ContentsContainerView::~ContentsContainerView() = default;
@@ -149,13 +271,31 @@ std::vector<views::View*> ContentsContai
 }
 
 void ContentsContainerView::UpdateBorderAndOverlay(bool is_in_split,
-                                                   bool is_active,
-                                                   bool is_highlighted) {
-  SetBorder(nullptr);
-}
-
-void ContentsContainerView::ChildVisibilityChanged(View* child) {
-  return;
+                                                   bool is_first_view) {
+  is_in_split_ = is_in_split;
+  is_first_view_ = is_first_view;
+
+  const bool show_corner_fill =
+      browser_view_->ShouldDrawVerticalTabStrip() &&
+      (!is_in_split || is_first_view);
+  bool corner_on_right = false;
+  if (show_corner_fill) {
+    auto* controller =
+        tabs::VerticalTabStripStateController::From(browser_view_->browser());
+    corner_on_right = controller && controller->IsTabStripRightAligned();
+  }
+  const int corner_radius =
+      show_corner_fill
+          ? GetLayoutConstant(LayoutConstant::kVerticalTabCornerRadius)
+          : 0;
+  leading_corner_fill_view_->SetCornerOnRight(corner_on_right);
+  leading_corner_fill_view_->SetCornerRadius(corner_radius);
+}
+
+void ContentsContainerView::OnVerticalTabStripStateChanged(
+    tabs::VerticalTabStripStateController*) {
+  UpdateBorderAndOverlay(is_in_split_, is_first_view_);
+  InvalidateLayout();
 }
 
 void ContentsContainerView::Layout(PassKey pass_key) {
@@ -399,6 +539,19 @@ views::ProposedLayout ContentsContainerV
   layouts.child_layouts.emplace_back(
       contents_view_.get(), contents_view_->GetVisible(), contents_rect);
 
+  if (leading_corner_fill_view_) {
+    const gfx::Size corner_size = leading_corner_fill_view_->GetPreferredSize();
+    const gfx::Rect corner_bounds(
+        leading_corner_fill_view_->IsCornerOnRight()
+            ? gfx::Point(contents_rect.right() - corner_size.width(),
+                         contents_rect.y())
+            : contents_rect.origin(),
+        corner_size);
+    layouts.child_layouts.emplace_back(
+        leading_corner_fill_view_.get(),
+        leading_corner_fill_view_->GetVisible(), corner_bounds);
+  }
+
 #if BUILDFLAG(ENABLE_GLIC)
   if (glic_border_) {
     // |glic_border_| should not be seen over devtools.
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1251,10 +1251,19 @@ int BrowserView::GetTabStripHeight() con
   // We want to return tabstrip_->height(), but we might be called in the midst
   // of layout, when that hasn't yet been updated to reflect the current state.
   // So return what the tabstrip height _ought_ to be right now.
-  return ShouldDrawTabStrip() ? horizontal_tab_strip_region_view_->tab_strip()
-                                    ->GetPreferredSize()
-                                    .height()
-                              : 0;
+
+  // The vertical tabstrip region has to use the toolbar height,
+  // since the horizontal tabstrip is not drawn.
+  if (ShouldDrawVerticalTabStrip()) {
+    return toolbar_->GetPreferredSize().height();
+  }
+
+  if (ShouldDrawTabStrip()) {
+    return horizontal_tab_strip_region_view_->tab_strip()
+               ->GetPreferredSize().height();
+  }
+
+  return 0;
 }
 
 gfx::Size BrowserView::GetWebAppFrameToolbarPreferredSize() const {
--- a/chrome/browser/ui/views/tabs/vertical/top_container_button.cc
+++ b/chrome/browser/ui/views/tabs/vertical/top_container_button.cc
@@ -10,6 +10,8 @@
 #include "ui/views/actions/action_view_interface.h"
 
 namespace {
+constexpr int kButtonPadding = 4;
+
 class TopContainerButtonActionViewInterface
     : public views::LabelButtonActionViewInterface {
  public:
@@ -31,6 +33,8 @@ class TopContainerButtonActionViewInterf
 }  // namespace
 
 TopContainerButton::TopContainerButton() {
+  SetBorder(views::CreateEmptyBorder(
+      gfx::Insets::VH(kButtonPadding, kButtonPadding)));
   views::FocusRing::Get(this)->SetColorId(kColorNewTabButtonFocusRing);
   ConfigureInkDropForToolbar(this);
 }
