--- /dev/null
+++ b/chrome/browser/ui/screenshots/screenshot_controller.h
@@ -0,0 +1,86 @@
// Copyright 2024 The Helium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_CONTROLLER_H_
#define CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_CONTROLLER_H_

#include <memory>
#include <string>

#include "base/functional/callback.h"
#include "base/memory/weak_ptr.h"
#include "content/public/browser/web_contents_observer.h"
#include "content/public/browser/web_contents_user_data.h"
#include "ui/gfx/geometry/rect.h"
#include <vector>

namespace content {
class WebContents;
class RenderWidgetHostView;
}  // namespace content

namespace gfx {
class Image;
}

namespace helium {

// Manages screenshot operations for a specific WebContents.
// This controller handles both viewport and full-page captures.
class ScreenshotController : public content::WebContentsObserver,
                             public content::WebContentsUserData<ScreenshotController> {
 public:
  ~ScreenshotController() override;

  ScreenshotController(const ScreenshotController&) = delete;
  ScreenshotController& operator=(const ScreenshotController&) = delete;

  // PHASE 1: Capture the currently visible viewport.
  void TakeViewportScreenshot();

  // PHASE 2: Capture the entire scrollable page.
  void TakeFullPageScreenshot();

  // PHASE 3: Capture a user-selected area.
  void StartAreaSelection();

 private:
  friend class content::WebContentsUserData<ScreenshotController>;

  explicit ScreenshotController(content::WebContents* web_contents);

  // Callback when a viewport capture completes.
  void OnViewportCaptured(const SkBitmap& bitmap);

  // Callback when a full page capture cycle completes.
  void OnFullPageCaptured(const SkBitmap& bitmap);

  // Helper to save the captured image to disk/clipboard.
  void ProcessCapturedImage(const SkBitmap& bitmap);

  // Helper for Area Capture
  void CaptureArea(const gfx::Rect& rect_dip, double device_scale_factor);

  // Full Page Capture State Helpers
  void ScrollAndCaptureNextChunk();
  void StartChunkCapture();
  void OnChunkCaptured(const SkBitmap& bitmap);
  void FinishFullPageCapture();

  // State for full page capture
  struct FullPageCaptureState {
    int total_height = 0;
    int current_y = 0;
    int viewport_height = 0;
    float device_scale_factor = 1.0f;
    std::vector<SkBitmap> chunks;
  };
  std::unique_ptr<FullPageCaptureState> full_page_state_;

  base::WeakPtrFactory<ScreenshotController> weak_ptr_factory_{this};
};

}  // namespace helium

#endif  // CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_CONTROLLER_H_
--- /dev/null
+++ b/chrome/browser/ui/screenshots/screenshot_controller.cc
@@ -0,0 +1,317 @@
// Copyright 2024 The Helium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/screenshots/screenshot_controller.h"

#include "base/base64.h"
#include "base/functional/bind.h"
#include "base/task/thread_pool.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/browser_finder.h"
#include "chrome/browser/ui/screenshots/screenshot_utils.h"
#include "content/public/browser/render_frame_host.h"
#include "content/public/browser/render_view_host.h"
#include "content/public/browser/render_widget_host.h"
#include "content/public/browser/render_widget_host_view.h"
#include "content/public/browser/web_contents.h"
#include "third_party/skia/include/core/SkBitmap.h"
#include "third_party/skia/include/core/SkCanvas.h"
#include "ui/gfx/geometry/rect.h"
#include "ui/gfx/geometry/size.h"

namespace helium {

namespace {

// Helpers for JS injection
const char kGetPageMetricsScript[] = R"(
  (function() {
    return {
      width: document.documentElement.scrollWidth,
      height: document.documentElement.scrollHeight,
      viewportHeight: window.innerHeight,
      pixelRatio: window.devicePixelRatio
    };
  })();
)";

// Phase 3: Selection Overlay Script
const char kSelectionScript[] = R"(
  (function() {
    if (document.getElementById('helium-screenshot-overlay')) return;
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'helium-screenshot-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.zIndex = '2147483647';
    overlay.style.cursor = 'crosshair';
    overlay.style.background = 'rgba(0,0,0,0.3)';
    
    // Create selection box
    const selection = document.createElement('div');
    selection.style.border = '2px solid #0a84ff';
    selection.style.background = 'rgba(10, 132, 255, 0.1)';
    selection.style.position = 'absolute';
    selection.style.display = 'none';
    overlay.appendChild(selection);
    
    document.body.appendChild(overlay);
    
    let startX, startY, isDragging = false;
    
    overlay.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        selection.style.left = startX + 'px';
        selection.style.top = startY + 'px';
        selection.style.width = '0px';
        selection.style.height = '0px';
        selection.style.display = 'block';
    });
    
    overlay.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const currentX = e.clientX;
        const currentY = e.clientY;
        
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        const left = Math.min(currentX, startX);
        const top = Math.min(currentY, startY);
        
        selection.style.left = left + 'px';
        selection.style.top = top + 'px';
        selection.style.width = width + 'px';
        selection.style.height = height + 'px';
    });
    
    return new Promise((resolve) => {
        overlay.addEventListener('mouseup', (e) => {
            isDragging = false;
            const rect = selection.getBoundingClientRect();
            
            // Allow small movements to cancel/ignore
            if (rect.width < 5 || rect.height < 5) {
                // reset? or just ignore?
                return;
            }
            
            // Remove overlay
            document.body.removeChild(overlay);
            
            resolve({
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                pixelRatio: window.devicePixelRatio
            });
        }, {once: true});
        
        // Escape to cancel
        document.addEventListener('keydown', (e) => {
             if (e.key === 'Escape') {
                 document.body.removeChild(overlay);
                 resolve(null);
             }
        }, {once: true});
    });
  })()
)";

}  // namespace

ScreenshotController::ScreenshotController(content::WebContents* web_contents)
    : content::WebContentsObserver(web_contents) {}

ScreenshotController::~ScreenshotController() = default;

void ScreenshotController::TakeViewportScreenshot() {
  content::RenderWidgetHostView* view =
      web_contents()->GetRenderWidgetHostView();
  if (!view) return;

  view->CopyFromSurface(
      gfx::Rect(),  // Copy entire surface
      gfx::Size(),  // No scaling
      base::BindOnce(&ScreenshotController::OnViewportCaptured,
                     weak_ptr_factory_.GetWeakPtr()));
}

void ScreenshotController::OnViewportCaptured(const SkBitmap& bitmap) {
  if (bitmap.drawsNothing()) {
    // Handle error (e.g. show toast)
    return;
  }
  ProcessCapturedImage(bitmap);
}

void ScreenshotController::TakeFullPageScreenshot() {
  // Phase 2: Implementation
  // 1. Get Metrics
  web_contents()->GetPrimaryMainFrame()->ExecuteJavaScript(
      base::UTF8ToUTF16(kGetPageMetricsScript),
      base::BindOnce(
          [](base::WeakPtr<ScreenshotController> controller, base::Value value) {
            if (!controller) return;
            // Parse metrics
            if (!value.is_dict()) return;
            const auto& dict = value.GetDict();
            
            auto state = std::make_unique<FullPageCaptureState>();
            state->total_height = dict.FindInt("height").value_or(0);
            state->viewport_height = dict.FindInt("viewportHeight").value_or(0);
            state->device_scale_factor = dict.FindDouble("pixelRatio").value_or(1.0);
            
            if (state->total_height <= 0 || state->viewport_height <= 0) return;
            
            controller->full_page_state_ = std::move(state);
            controller->ScrollAndCaptureNextChunk();
          },
          weak_ptr_factory_.GetWeakPtr()));
}

void ScreenshotController::ScrollAndCaptureNextChunk() {
  if (!full_page_state_) return;

  int next_y = full_page_state_->current_y;
  
  // Create scroll script
  std::string scroll_script = "window.scrollTo(0, " + std::to_string(next_y) + ");";
  
  web_contents()->GetPrimaryMainFrame()->ExecuteJavaScript(
      base::UTF8ToUTF16(scroll_script),
      base::BindOnce(
          [](base::WeakPtr<ScreenshotController> controller, base::Value) {
              if(!controller) return;
              // Wait for frame presentation ideally, but for now scheduling capture
              // A small delay might be needed for the renderer to paint content.
              // In production, use RenderWidgetHost::RequestPresentationCallback.
              base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
                  FROM_HERE,
                  base::BindOnce(&ScreenshotController::StartChunkCapture, controller),
                  base::Milliseconds(150)); 
          },
          weak_ptr_factory_.GetWeakPtr()));
}

// Added helper method locally to handle the capture call
void ScreenshotController::StartChunkCapture() { // Needs to be added to header if not present, or valid internal call
   content::RenderWidgetHostView* view = web_contents()->GetRenderWidgetHostView();
   if (!view) return; // Cleanup
   
   view->CopyFromSurface(
       gfx::Rect(),
       gfx::Size(),
       base::BindOnce(&ScreenshotController::OnChunkCaptured, weak_ptr_factory_.GetWeakPtr())
   );
}

void ScreenshotController::OnChunkCaptured(const SkBitmap& bitmap) {
    if (!full_page_state_) return;
    
    full_page_state_->chunks.push_back(bitmap);
    
    full_page_state_->current_y += full_page_state_->viewport_height;
    
    if (full_page_state_->current_y < full_page_state_->total_height) {
        ScrollAndCaptureNextChunk();
    } else {
        FinishFullPageCapture();
    }
}

void ScreenshotController::FinishFullPageCapture() {
    // Stitch bitmaps
    if (!full_page_state_ || full_page_state_->chunks.empty()) return;

    int total_width = full_page_state_->chunks[0].width();
    int total_height = 0;
    
    // Calculate total height (accounting for potential overlap or partial last chunk if needed, 
    // but for simplicity assuming full viewport steps with standard crop later if needed)
    // Actually, simple vertical stacking:
    for (const auto& chunk : full_page_state_->chunks) {
        total_height += chunk.height();
    }
    
    // Create canvas
    SkBitmap final_bitmap;
    final_bitmap.allocN32Pixels(total_width, total_height);
    SkCanvas canvas(final_bitmap);
    
    int current_draw_y = 0;
    for (const auto& chunk : full_page_state_->chunks) {
        canvas.drawImage(chunk.asImage(), 0, current_draw_y);
        current_draw_y += chunk.height();
    }
    
    // Restore scroll position (optional TODO)
    
    full_page_state_.reset();
    ProcessCapturedImage(final_bitmap);
}

void ScreenshotController::ProcessCapturedImage(const SkBitmap& bitmap) {
  // Offload PNG encoding and saving to a background thread
  ScreenshotUtils::SaveImage(bitmap, ScreenshotUtils::GetScreenshotSavePath());
  
  // Also copy to clipboard (on UI thread or via helper)
  ScreenshotUtils::CopyImageToClipboard(bitmap);
}

void ScreenshotController::StartAreaSelection() {
    // Phase 3: Execute JS, wait for promise
    web_contents()->GetPrimaryMainFrame()->ExecuteJavaScript(
        base::UTF8ToUTF16(kSelectionScript),
        base::BindOnce(
            [](base::WeakPtr<ScreenshotController> controller, base::Value value) {
                if (!controller) return;
                // If user escaped or error
                if (!value.is_dict()) return;
                
                const auto& dict = value.GetDict();
                double x = dict.FindDouble("x").value_or(0);
                double y = dict.FindDouble("y").value_or(0);
                double width = dict.FindDouble("width").value_or(0);
                double height = dict.FindDouble("height").value_or(0);
                double dsf = dict.FindDouble("pixelRatio").value_or(1.0);
                
                if (width <= 0 || height <= 0) return;
                controller->CaptureArea(gfx::Rect(x, y, width, height), dsf);
            },
            weak_ptr_factory_.GetWeakPtr()));
}

void ScreenshotController::CaptureArea(const gfx::Rect& rect_dip, double device_scale_factor) {
    content::RenderWidgetHostView* view = web_contents()->GetRenderWidgetHostView();
    if (!view) return;

    // Convert DIP rect to Physical Pixels if needed, but CopyFromSurface usually takes physical rects
    // OR DIP rects depending on API version. 
    // Checking ::CopyFromSurface doc: "The |src_rect| is in view coordinates". 
    // Usually view coordinates are DIPs in Blink/Chromium UI but backend pixels in Compositor.
    // However, existing usages often pass empty for full.
    // Let's assume View coordinates (DIPs) -> Actually RWHV usually works in pixels for CopyFromSurface?
    // Let's rely on standard scaling:
    // Actually, RWHV::CopyFromSurface takes `src_rect` in *pixel* coordinates relative to the surface.
    
    gfx::Rect rect_px = gfx::ScaleToEnclosingRect(rect_dip, device_scale_factor);

    view->CopyFromSurface(
       rect_px,
       gfx::Size(), // Output size (same as input -> no scaling)
       base::BindOnce(&ScreenshotController::OnViewportCaptured, weak_ptr_factory_.GetWeakPtr())
   );
}

WEB_CONTENTS_USER_DATA_KEY_IMPL(ScreenshotController);

}  // namespace helium
--- /dev/null
+++ b/chrome/browser/ui/screenshots/screenshot_utils.h
@@ -0,0 +1,29 @@
// Copyright 2024 The Helium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_UTILS_H_
#define CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_UTILS_H_

#include "base/files/file_path.h"
#include "third_party/skia/include/core/SkBitmap.h"

namespace helium {

class ScreenshotUtils {
 public:
  // Saves the bitmap to a PNG file at the specified path.
  // Should be called on a background thread (blocking I/O).
  static void SaveImage(const SkBitmap& bitmap, const base::FilePath& path);

  // Copies the bitmap to the system clipboard.
  // Must be called on the UI thread.
  static void CopyImageToClipboard(const SkBitmap& bitmap);

  // Generates a default timestamped filename in the Downloads or Pictures folder.
  static base::FilePath GetScreenshotSavePath();
};

}  // namespace helium

#endif  // CHROME_BROWSER_UI_SCREENSHOTS_SCREENSHOT_UTILS_H_
--- /dev/null
+++ b/chrome/browser/ui/screenshots/screenshot_utils.cc
@@ -0,0 +1,68 @@
// Copyright 2024 The Helium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/screenshots/screenshot_utils.h"

#include "base/files/file_util.h"
#include "base/logging.h"
#include "base/path_service.h"
#include "base/strings/stringprintf.h"
#include "base/task/task_traits.h"
#include "base/task/thread_pool.h"
#include "base/time/time.h"
#include "chrome/common/chrome_paths.h"
#include "third_party/skia/include/core/SkBitmap.h"
#include "ui/base/clipboard/clipboard.h"
#include "ui/base/clipboard/scoped_clipboard_writer.h"
#include "ui/gfx/codec/png_codec.h"
#include "ui/gfx/image/image.h"

namespace helium {

// static
void ScreenshotUtils::SaveImage(const SkBitmap& bitmap, const base::FilePath& path) {
  base::ThreadPool::PostTask(
      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
      base::BindOnce(
          [](const SkBitmap& bitmap, const base::FilePath& path) {
            std::vector<unsigned char> png_data;
            if (gfx::PNGCodec::EncodeBGRASkBitmap(bitmap, false, &png_data)) {
              if (base::WriteFile(path, png_data)) {
                 LOG(INFO) << "Screenshot saved to: " << path;
              } else {
                 LOG(ERROR) << "Failed to write screenshot to: " << path;
              }
            } else {
               LOG(ERROR) << "Failed to encode screenshot.";
            }
          },
          bitmap, path));
}

// static
void ScreenshotUtils::CopyImageToClipboard(const SkBitmap& bitmap) {
  ui::ScopedClipboardWriter scw(ui::ClipboardBuffer::kCopyPaste);
  scw.WriteImage(bitmap);
}

// static
base::FilePath ScreenshotUtils::GetScreenshotSavePath() {
  base::FilePath download_dir;
  if (!base::PathService::Get(chrome::DIR_USER_DOWNLOADS, &download_dir)) {
      // Fallback to temp if downloads not found
      base::PathService::Get(base::DIR_TEMP, &download_dir);
  }

  base::Time::Exploded now;
  base::Time::Now().LocalExplode(&now);

  std::string filename = base::StringPrintf(
      "Screenshot_%04d%02d%02d_%02d%02d%02d.png",
      now.year, now.month, now.day_of_month,
      now.hour, now.minute, now.second);

  return download_dir.AppendASCII(filename);
}

}  // namespace helium
--- /dev/null
+++ b/chrome/browser/ui/screenshots/screenshot_controller_browsertest.cc
@@ -0,0 +1,63 @@
// Copyright 2024 The Helium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/screenshots/screenshot_controller.h"

#include "base/files/file_util.h"
#include "base/files/scoped_temp_dir.h"
#include "base/run_loop.h"
#include "base/test/bind.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/test/base/in_process_browser_test.h"
#include "chrome/test/base/ui_test_utils.h"
#include "content/public/test/browser_test.h"
#include "content/public/test/browser_test_utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace helium {

class ScreenshotControllerBrowserTest : public InProcessBrowserTest {
 public:
  ScreenshotControllerBrowserTest() = default;
  ~ScreenshotControllerBrowserTest() override = default;

  void SetUpOnMainThread() override {
    ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());
  }

 protected:
  base::ScopedTempDir temp_dir_;
};

IN_PROC_BROWSER_TEST_F(ScreenshotControllerBrowserTest, TakeViewportScreenshot) {
  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GURL("about:blank")));
  
  auto* contents = browser()->tab_strip_model()->GetActiveWebContents();
  ScreenshotController::CreateForWebContents(contents);
  auto* controller = ScreenshotController::FromWebContents(contents);
  ASSERT_TRUE(controller);

  // basic crash test / smoke test
  // Real file validation would require mocking ScreenshotUtils or waiting on file system
  controller->TakeViewportScreenshot();
  
  // Allow tasks to post
  base::RunLoop().RunUntilIdle();
}

IN_PROC_BROWSER_TEST_F(ScreenshotControllerBrowserTest, TakeFullPageScreenshot) {
    ASSERT_TRUE(ui_test_utils::NavigateToURL(
      browser(), GURL("data:text/html,<body><div style='height:2000px; background:red;'>Tall</div></body>")));

    auto* contents = browser()->tab_strip_model()->GetActiveWebContents();
    ScreenshotController::CreateForWebContents(contents);
    auto* controller = ScreenshotController::FromWebContents(contents);
    
    // Smoke test for full page state machine
    controller->TakeFullPageScreenshot();
    
    base::RunLoop().RunUntilIdle();
}

}  // namespace helium
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -164,6 +164,10 @@ static_library("ui") {
     "webui/omnibox/omnibox_ui.cc",
     "webui/omnibox/omnibox_ui.h",
+    "screenshots/screenshot_controller.cc",
+    "screenshots/screenshot_controller.h",
+    "screenshots/screenshot_utils.cc",
+    "screenshots/screenshot_utils.h",
     "webui/omnibox/omnibox_page_handler.cc",
     "webui/omnibox/omnibox_page_handler.h",
     "webui/omnibox/omnibox_ui.cc",

--- a/chrome/app/chrome_command_ids.h
+++ b/chrome/app/chrome_command_ids.h
@@ -95,4 +95,7 @@
 // Helium commands
 #define IDC_COPY_OR_INSPECT_SHORTCUT    34080
+#define IDC_TAKE_SCREENSHOT             34090
+#define IDC_TAKE_FULL_PAGE_SCREENSHOT   34091
+#define IDC_TAKE_AREA_SCREENSHOT        34092
+#define IDC_SCREENSHOTS_SUBMENU         34093
 
 #if BUILDFLAG(IS_CHROMEOS)

--- a/chrome/browser/ui/browser_command_controller.cc
+++ b/chrome/browser/ui/browser_command_controller.cc
@@ -21,6 +21,7 @@
 #include "chrome/browser/ui/browser_window.h"
 #include "chrome/browser/ui/browser_commands.h"
+#include "chrome/browser/ui/screenshots/screenshot_controller.h"
 #include "chrome/browser/ui/bookmarks/bookmark_utils.h"
 #include "chrome/browser/ui/browser.h"
 
@@ -1205,6 +1206,24 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
     case IDC_COPY_URL:
       CopyURL(browser_, browser_->tab_strip_model()->GetActiveWebContents());
       break;
+    case IDC_TAKE_SCREENSHOT:
+     if (auto* contents = browser_->tab_strip_model()->GetActiveWebContents()) {
+       helium::ScreenshotController::CreateForWebContents(contents);
+       helium::ScreenshotController::FromWebContents(contents)->TakeViewportScreenshot();
+     }
+     break;
+    case IDC_TAKE_FULL_PAGE_SCREENSHOT:
+     if (auto* contents = browser_->tab_strip_model()->GetActiveWebContents()) {
+       helium::ScreenshotController::CreateForWebContents(contents);
+       helium::ScreenshotController::FromWebContents(contents)->TakeFullPageScreenshot();
+     }
+     break;
+    case IDC_TAKE_AREA_SCREENSHOT:
+     if (auto* contents = browser_->tab_strip_model()->GetActiveWebContents()) {
+       helium::ScreenshotController::CreateForWebContents(contents);
+       helium::ScreenshotController::FromWebContents(contents)->StartAreaSelection();
+     }
+     break;
     // Hosted App commands
     case IDC_OPEN_IN_PWA_WINDOW:
       base::RecordAction(base::UserMetricsAction("OpenActiveTabInPwaWindow"));

--- a/chrome/browser/ui/toolbar/app_menu_model.cc
+++ b/chrome/browser/ui/toolbar/app_menu_model.cc
@@ -2040,6 +2040,8 @@
 #endif
 #endif
 
+  CreateScreenshotSubMenu();
+
   if (!browser_->profile()->IsIncognitoProfile() && !browser_->profile()->IsGuestSession()) {
     AddItemWithStringIdAndVectorIcon(this, IDC_SHOW_CUSTOMIZE_CHROME_SIDE_PANEL,
                                      IDS_SHOW_CUSTOMIZE_CHROME_SIDE_PANEL,
@@ -2160,5 +2162,14 @@
+  }
+  return false;
+}
+
+void AppMenuModel::CreateScreenshotSubMenu() {
+    auto screenshots_menu = std::make_unique<ui::SimpleMenuModel>(this);
+    screenshots_menu->AddItemWithStringId(IDC_TAKE_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_SCREENSHOT);
+    screenshots_menu->AddItemWithStringId(IDC_TAKE_FULL_PAGE_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_FULL_PAGE_SCREENSHOT);
+    screenshots_menu->AddItemWithStringId(IDC_TAKE_AREA_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_AREA_SCREENSHOT);
+
+    sub_menus_.push_back(std::move(screenshots_menu));
+    AddSubMenuWithStringId(IDC_SCREENSHOTS_SUBMENU, IDS_SCREENSHOTS_SUBMENU_TITLE,
+                         sub_menus_.back().get());
+}
+

--- a/chrome/browser/ui/toolbar/app_menu_model.h
+++ b/chrome/browser/ui/toolbar/app_menu_model.h
@@ -293,6 +293,9 @@
   // Adds a nag to relaunch the browser after an update
   bool AddUpgradeMenuItem();
 
+  // Adds the screenshot submenu
+  void CreateScreenshotSubMenu();
+
   // Adds the Safety Hub menu notifications to the menu. Returns a boolean
   // indicating whether any menu items were added.
   [[nodiscard]] bool AddSafetyHubMenuItem();

--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -2256,4 +2256,9 @@
   AppendLiveCaptionItem();
-  AppendMediaRouterItem();
+
+  // Helium Screenshots
+  menu_model_.AddSeparator(ui::NORMAL_SEPARATOR);
+  menu_model_.AddItemWithStringId(IDC_TAKE_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_SCREENSHOT);
+  menu_model_.AddItemWithStringId(IDC_TAKE_FULL_PAGE_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_FULL_PAGE_SCREENSHOT);
+  menu_model_.AddItemWithStringId(IDC_TAKE_AREA_SCREENSHOT, IDS_CONTENT_CONTEXT_TAKE_AREA_SCREENSHOT);
+  menu_model_.AddSeparator(ui::NORMAL_SEPARATOR);
 
   if (features::IsReadAnythingMenuShuffleExperimentEnabled()) {

--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -102,4 +102,16 @@
+      <!-- Helium Screenshots -->
+      <message name="IDS_CONTENT_CONTEXT_TAKE_SCREENSHOT" desc="The name of the Take Screenshot command in the content area context menu">
+        Take Screenshot (Visible)
+      </message>
+      <message name="IDS_CONTENT_CONTEXT_TAKE_FULL_PAGE_SCREENSHOT" desc="The name of the Take Full Page Screenshot command in the content area context menu">
+        Take Full Page Screenshot
+      </message>
+      <message name="IDS_CONTENT_CONTEXT_TAKE_AREA_SCREENSHOT" desc="The name of the Take Area Screenshot command in the content area context menu">
+        Take Area Screenshot
+      </message>
+      <message name="IDS_SCREENSHOTS_SUBMENU_TITLE" desc="Title of the Capture submenu in the app menu">
+        Capture
+      </message>
+
       <message name="IDS_FLAGS_UI_RELAUNCH_NOTICE" desc="msg">

