--- a/chrome/browser/ui/views/tabs/tab_group_editor_bubble_view.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_editor_bubble_view.cc
@@ -285,7 +285,9 @@ TabGroupEditorBubbleView::TabGroupEditor
     std::optional<gfx::Rect> anchor_rect,
     bool stop_context_menu_propagation)
     : BubbleDialogDelegateView(anchor_view,
-                               views::BubbleBorder::Arrow::TOP_LEFT,
+                               tabs::AreHeliumVerticalTabsEnabled() ?
+                                  views::BubbleBorder::Arrow::TOP_LEFT :
+                                  views::BubbleBorder::Arrow::LEFT_TOP,
                                views::BubbleBorder::DIALOG_SHADOW,
                                true),
       title_field_controller_(this),
--- a/chrome/browser/ui/views/tabs/tab_group_underline.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_underline.cc
@@ -9,6 +9,7 @@
 
 #include "chrome/browser/ui/layout_constants.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/views/tabs/tab.h"
 #include "chrome/browser/ui/views/tabs/tab_group_header.h"
 #include "chrome/browser/ui/views/tabs/tab_group_style.h"
@@ -51,6 +52,10 @@ void TabGroupUnderline::UpdateBounds(con
   const gfx::Rect tab_group_underline_bounds =
       CalculateTabGroupUnderlineBounds(this, leading_view, trailing_view);
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    SetVisible(true);
+  } else {
+
   // The width may be zero if the group underline and header are initialized at
   // the same time, as with tab restore. In this case, don't show the underline.
   if (tab_group_underline_bounds.width() == 0) {
@@ -60,6 +65,8 @@ void TabGroupUnderline::UpdateBounds(con
 
   SetVisible(
       !style_->TabGroupUnderlineShouldBeHidden(leading_view, trailing_view));
+  }
+
   SetBoundsRect(tab_group_underline_bounds);
 }
 
@@ -67,6 +74,18 @@ gfx::Rect TabGroupUnderline::CalculateTa
     const views::View* const underline_view,
     const views::View* const leading_view,
     const views::View* const trailing_view) const {
+
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    int y = leading_view->y() + leading_view->height();
+    int offset = GetLayoutConstant(TOP_BAR_VERTICAL_PADDING);
+    return gfx::Rect(
+      offset * 2,
+      y + offset,
+      kStrokeThickness,
+      (trailing_view->y() + trailing_view->height()) - y - offset
+    );
+  }
+
   gfx::RectF leading_bounds = views::View::ConvertRectToTarget(
       leading_view->parent(), underline_view->parent(),
       gfx::RectF(leading_view->bounds()));
@@ -110,6 +129,10 @@ gfx::Insets TabGroupUnderline::GetInsets
 }
 
 void TabGroupUnderline::MaybeSetVisible(const bool visible) {
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    SetVisible(true);
+    return;
+  }
   SetVisible(visible && !style_->TabGroupUnderlineShouldBeHidden());
 }
 
--- a/chrome/browser/ui/views/tabs/tab_group_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_views.cc
@@ -9,6 +9,7 @@
 
 #include "base/memory/raw_ptr.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h"
 #include "chrome/browser/ui/views/tabs/tab_group_header.h"
 #include "chrome/browser/ui/views/tabs/tab_group_highlight.h"
@@ -39,19 +40,25 @@ TabGroupViews::TabGroupViews(views::View
   header_ = container_view->AddChildView(std::move(header));
   underline_ = container_view->AddChildView(
       std::make_unique<TabGroupUnderline>(this, group_, *style));
-  drag_underline_ = drag_container_view->AddChildView(
-      std::make_unique<TabGroupUnderline>(this, group_, *style));
-  highlight_ = drag_container_view->AddChildView(
-      std::make_unique<TabGroupHighlight>(this, group_, *style));
-  highlight_->SetVisible(false);
+
+  if (!tabs::AreHeliumVerticalTabsEnabled()) {
+    drag_underline_ = drag_container_view->AddChildView(
+        std::make_unique<TabGroupUnderline>(this, group_, *style));
+    highlight_ = drag_container_view->AddChildView(
+        std::make_unique<TabGroupHighlight>(this, group_, *style));
+    highlight_->SetVisible(false);
+  }
 }
 
 TabGroupViews::~TabGroupViews() {
   header_->parent()->RemoveChildViewT(std::exchange(header_, nullptr));
   underline_->parent()->RemoveChildViewT(std::exchange(underline_, nullptr));
+
+  if (!tabs::AreHeliumVerticalTabsEnabled()) {
   drag_underline_->parent()->RemoveChildViewT(
       std::exchange(drag_underline_, nullptr));
   highlight_->parent()->RemoveChildViewT(std::exchange(highlight_, nullptr));
+  }
 }
 
 void TabGroupViews::UpdateBounds() {
@@ -64,6 +71,8 @@ void TabGroupViews::UpdateBounds() {
       GetLeadingTrailingGroupViews();
   underline_->UpdateBounds(leading_group_view, trailing_group_view);
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) return;
+
   auto [leading_dragged_group_view, trailing_dragged_group_view] =
       GetLeadingTrailingDraggedGroupViews();
   drag_underline_->UpdateBounds(leading_dragged_group_view,
@@ -110,7 +119,7 @@ void TabGroupViews::OnGroupVisualsChange
 
   header_->VisualsChanged();
   underline_->SchedulePaint();
-  drag_underline_->SchedulePaint();
+  if (!tabs::AreHeliumVerticalTabsEnabled()) drag_underline_->SchedulePaint();
 }
 
 gfx::Rect TabGroupViews::GetBounds() const {
@@ -138,6 +147,7 @@ SkColor TabGroupViews::GetGroupColor() c
 }
 
 bool TabGroupViews::InTearDown() const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) return !header_ || !header_->GetWidget();
   return !header_ || !header_->GetWidget() || !drag_underline_->GetWidget();
 }
 
@@ -145,10 +155,14 @@ std::tuple<const views::View*, const vie
 TabGroupViews::GetLeadingTrailingGroupViews() const {
   std::vector<raw_ptr<views::View, VectorExperimental>> children =
       underline_->parent()->children();
-  std::vector<raw_ptr<views::View, VectorExperimental>> dragged_children =
+
+  if (!tabs::AreHeliumVerticalTabsEnabled()) {
+    std::vector<raw_ptr<views::View, VectorExperimental>> dragged_children =
       drag_underline_->parent()->children();
-  children.insert(children.end(), dragged_children.begin(),
+    children.insert(children.end(), dragged_children.begin(),
                   dragged_children.end());
+  }
+
   return GetLeadingTrailingGroupViews(children);
 }
 
@@ -178,6 +192,22 @@ TabGroupViews::GetLeadingTrailingGroupVi
     gfx::Rect child_widget_bounds =
         child->ConvertRectToWidget(child->GetLocalBounds());
 
+    if (tabs::AreHeliumVerticalTabsEnabled()) {
+      if (!leading_child ||
+          child_widget_bounds.y() < leading_child_widget_bounds.y()) {
+        leading_child = child;
+        leading_child_widget_bounds = child_widget_bounds;
+      }
+
+      if (!trailing_child ||
+          child_widget_bounds.bottom() > trailing_child_widget_bounds.bottom()) {
+        trailing_child = child;
+        trailing_child_widget_bounds = child_widget_bounds;
+      }
+
+      continue;
+    }
+
     if (!leading_child ||
         child_widget_bounds.x() < leading_child_widget_bounds.x()) {
       leading_child = child;
--- a/chrome/browser/ui/views/tabs/tab_group_header.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_header.cc
@@ -21,7 +21,9 @@
 #include "chrome/browser/ui/browser_element_identifiers.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/ui/layout_constants.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/tabs/saved_tab_groups/saved_tab_group_utils.h"
+#include "chrome/browser/ui/tabs/tab_group_theme.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/views/tabs/tab_group_editor_bubble_view.h"
@@ -78,6 +80,12 @@ namespace {
 // The amount of padding between the label and the sync icon.
 constexpr int kSyncIconPaddingFromLabel = 2;
 
+constexpr int kVerticalTabGroupStrokeThickness = 1;
+
+constexpr int kColorIndicatorSize = 16;
+constexpr int kColorIndicatorCornerRadius = 4;
+constexpr int kColorIndicatorPadding = 8;
+
 bool SupportsDataSharing() {
   return data_sharing::features::IsDataSharingFunctionalityEnabled();
 }
@@ -117,6 +125,8 @@ TabGroupHeader::TabGroupHeader(TabSlotCo
       title_(title_chip_->AddChildView(std::make_unique<views::Label>())),
       sync_icon_(
           title_chip_->AddChildView(std::make_unique<views::ImageView>())),
+      color_indicator_(
+          title_chip_->AddChildView(std::make_unique<views::View>())),
       attention_indicator_(
           title_chip_->AddChildView(std::make_unique<views::ImageView>())),
       group_style_(style),
@@ -451,8 +461,9 @@ void TabGroupHeader::VisualsChanged() {
 
   UpdateTitleView();
   UpdateSyncIconView();
+  UpdateColorIndicatorView();
   UpdateAttentionIndicatorView();
-  if (group_title_.empty()) {
+  if (group_title_.empty() && !tabs::AreHeliumVerticalTabsEnabled()) {
     CreateHeaderWithoutTitle();
   } else {
     CreateHeaderWithTitle();
@@ -559,7 +570,15 @@ void TabGroupHeader::UpdateTitleView() {
   title_->SetText(group_title_);
 
   if (!group_title_.empty()) {
-    title_->SetEnabledColor(color_utils::GetColorWithMaxContrast(color_));
+    if (tabs::AreHeliumVerticalTabsEnabled()) {
+      const SkColor text_color = GetColorProvider()->GetColor(
+            GetSavedTabGroupForegroundColorId(
+              tab_slot_controller_->GetGroupColorId(group().value())));
+
+      title_->SetEnabledColor(text_color);
+    } else {
+      title_->SetEnabledColor(color_utils::GetColorWithMaxContrast(color_));
+    }
   }
 }
 
@@ -574,6 +593,18 @@ void TabGroupHeader::UpdateSyncIconView(
   }
 }
 
+void TabGroupHeader::UpdateColorIndicatorView() {
+  const bool should_show_indicator = tabs::AreHeliumVerticalTabsEnabled();
+  color_indicator_->SetVisible(should_show_indicator);
+
+  if (should_show_indicator) {
+    color_indicator_->SetBackground(
+        views::CreateRoundedRectBackground(color_, kColorIndicatorCornerRadius));
+    color_indicator_->SetPreferredSize(
+        gfx::Size(kColorIndicatorSize, kColorIndicatorSize));
+  }
+}
+
 void TabGroupHeader::UpdateAttentionIndicatorView() {
   const bool supports_attention_indicator = SupportsDataSharing();
   if (!supports_attention_indicator) {
@@ -646,6 +677,12 @@ void TabGroupHeader::CreateHeaderWithTit
   // Visual representation of tab group header:
   //             [            Total Content Width           ]
   // [Left Inset][Sync Icon][Padding][Group Title][Attention][Right Inset]
+  const bool show_color_indicator = tabs::AreHeliumVerticalTabsEnabled();
+  const int color_indicator_width =
+      show_color_indicator ? kColorIndicatorSize : 0;
+  const int color_indicator_padding =
+      show_color_indicator ? kColorIndicatorPadding : 0;
+
   const int sync_icon_width =
       should_show_header_icon_ ? group_style_->GetSyncIconWidth() : 0;
   const int padding_between_label_sync_icon =
@@ -662,47 +699,105 @@ void TabGroupHeader::CreateHeaderWithTit
   const int attention_indicator_padding =
       should_show_attention_indicator ? kSyncIconPaddingFromLabel : 0;
 
+  // Ripped out of total_content_width upstream for cleaner calculations below.
+  const int content_extras_width =
+      color_indicator_width + color_indicator_padding +
+      sync_icon_width + padding_between_label_sync_icon +
+      attention_indicator_width + attention_indicator_padding;
+
   // The max width of the content should be half the standard tab width (not
   // counting overlap).
   const int text_max_width = (tab_style_->GetStandardWidth(/*is_split*/ false) -
                               tab_style_->GetTabOverlap()) /
                                  2 -
                              sync_icon_width - padding_between_label_sync_icon;
-  const int text_width = std::min(
-      title_->GetPreferredSize(views::SizeBounds(title_->width(), {})).width(),
-      text_max_width);
+
+  const int full_text_width = title_->GetPreferredSize(
+      views::SizeBounds(title_->width(), {})).width();
+
+  const gfx::Insets title_chip_insets = group_style_->GetInsetsForHeaderChip();
+  int text_width;
+
+  // In vertical mode text should take up all available space.
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    DCHECK(parent());
+    const int parent_width = parent()->width();
+
+    // This is essentially "parent_width - whatever_is_inside_or_outside_the_chip".
+    const int vertical_text_max_width = parent_width - content_extras_width -
+              title_chip_insets.width() -
+              group_style_->GetTabGroupViewOverlap() * 2;
+
+    text_width = std::max(0, vertical_text_max_width);
+  } else {
+    text_width = std::min(full_text_width, text_max_width);
+  }
+
   const int text_height =
       title_->GetPreferredSize(views::SizeBounds(title_->width(), {})).height();
 
   // Width of title chip should at least be the width of an empty title chip.
-  const int total_content_width =
-      sync_icon_width + padding_between_label_sync_icon + text_width +
-      attention_indicator_width + attention_indicator_padding;
-  const gfx::Insets title_chip_insets = group_style_->GetInsetsForHeaderChip();
+  const int total_content_width = content_extras_width + text_width;
   const int title_chip_width =
       std::max(group_style_->GetEmptyTitleChipBounds(this).width(),
                total_content_width + title_chip_insets.width());
 
+  // In vertical mode the chip height is equal to the tab height.
+  const int title_chip_height = tabs::AreHeliumVerticalTabsEnabled() ?
+                                GetLayoutConstant(TAB_HEIGHT) : text_height;
+
   // The title chip's radius should nestle snuggly against the tab corner
   // radius, taking into account the group underline stroke.
   const gfx::Point title_chip_origin =
       group_style_->GetTitleChipOffset(text_height);
   const int corner_radius = group_style_->GetChipCornerRadius();
   title_chip_->SetBounds(title_chip_origin.x(), title_chip_origin.y(),
-                         title_chip_width, text_height);
-  title_chip_->SetBackground(
-      views::CreateRoundedRectBackground(color_, corner_radius));
-
-  // Set the bounds of the sync icon first, followed by the title.
-  const int start_of_sync_icon = title_chip_insets.left();
-  const int title_chip_vertical_inset = 0;
+                         title_chip_width, title_chip_height);
+
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    const tab_groups::TabGroupColorId group_color_id =
+        tab_slot_controller_->GetGroupColorId(group().value());
+
+    const SkColor background_color =
+        GetColorProvider()->GetColor(GetTabGroupBookmarkColorId(group_color_id));
+    const SkColor stroke_color =
+        GetColorProvider()->GetColor(GetSavedTabGroupOutlineColorId(group_color_id));
+
+    title_chip_->SetBackground(
+        views::CreateRoundedRectBackground(background_color, corner_radius));
+    title_chip_->SetBorder(views::CreateRoundedRectBorder(
+        kVerticalTabGroupStrokeThickness, corner_radius, stroke_color));
+  } else {
+    title_chip_->SetBackground(
+        views::CreateRoundedRectBackground(color_, corner_radius));
+  }
+
+  // Group color indicator layout.
+  const int start_of_color_indicator = title_chip_insets.left();
+  const int title_chip_vertical_inset = tabs::AreHeliumVerticalTabsEnabled() ?
+                                        (title_chip_height - text_height) / 2 : 0;
+
+  if (show_color_indicator) {
+    const int color_vertical_inset =
+        (title_chip_height - kColorIndicatorSize) / 2;
+    color_indicator_->SetBounds(start_of_color_indicator,
+                                color_vertical_inset,
+                                kColorIndicatorSize, kColorIndicatorSize);
+  } else {
+    color_indicator_->SetBounds(0, 0, 0, 0);
+  }
+
+  const int left_inset = show_color_indicator ?
+      color_indicator_->bounds().right() + color_indicator_padding :
+      title_chip_insets.left();
+
   if (!should_show_header_icon_) {
     sync_icon_->SetBounds(0, 0, 0, 0);
-    title_->SetBounds(title_chip_insets.left(), title_chip_vertical_inset,
+    title_->SetBounds(left_inset, title_chip_vertical_inset,
                       text_width, text_height);
     attention_indicator_->SetBounds(0, 0, 0, 0);
   } else {
-    sync_icon_->SetBounds(start_of_sync_icon, title_chip_vertical_inset,
+    sync_icon_->SetBounds(left_inset, title_chip_vertical_inset,
                           sync_icon_width, text_height);
     title_->SetBounds(
         sync_icon_->bounds().right() + padding_between_label_sync_icon,
--- a/chrome/browser/ui/views/tabs/tab_group_header.h
+++ b/chrome/browser/ui/views/tabs/tab_group_header.h
@@ -112,6 +112,7 @@ class TabGroupHeader : public TabSlotVie
 
   void UpdateTitleView();
   void UpdateSyncIconView();
+  void UpdateColorIndicatorView();
   void UpdateAttentionIndicatorView();
   void UpdateIsCollapsed();
 
@@ -140,6 +141,9 @@ class TabGroupHeader : public TabSlotVie
   // the tabstrip.
   const raw_ptr<views::ImageView> sync_icon_;
 
+  // The group color indicator displayed before the title.
+  const raw_ptr<views::View> color_indicator_;
+
   // The circle indicator rendered after the title when a tab group has
   // needs_attention_ set to true.
   const raw_ptr<views::ImageView> attention_indicator_;
--- a/chrome/browser/ui/views/tabs/tab_group_style.cc
+++ b/chrome/browser/ui/views/tabs/tab_group_style.cc
@@ -6,6 +6,7 @@
 
 #include "base/feature_list.h"
 #include "chrome/browser/ui/layout_constants.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/views/tabs/tab.h"
@@ -88,6 +89,12 @@ gfx::Rect TabGroupStyle::GetEmptyTitleCh
 
 gfx::Point TabGroupStyle::GetTitleChipOffset(
     std::optional<int> text_height) const {
+  // For vertical tabs, the title chip simulates the tab, so it is positioned
+  // using the same padding as tabs. We adjust its max width in GetTabGroupViewOverlap().
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return gfx::Point(GetLayoutConstant(TOP_BAR_VERTICAL_PADDING) * 2, 0);
+  }
+
   const int total_space = GetLayoutConstant(TAB_STRIP_HEIGHT) -
                           GetEmptyChipSize() -
                           GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
@@ -100,6 +107,9 @@ std::unique_ptr<views::Background> TabGr
 }
 
 gfx::Insets TabGroupStyle::GetInsetsForHeaderChip() const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return gfx::Insets::VH(0, 7);
+  }
   return gfx::Insets::TLBR(kHeaderChipVerticalInset, GetChipCornerRadius(),
                            kHeaderChipVerticalInset, GetChipCornerRadius());
 }
@@ -129,10 +139,19 @@ float TabGroupStyle::GetAttentionIndicat
 }
 
 int TabGroupStyle::GetChipCornerRadius() const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return TabStyle::Get()->GetTopCornerRadius();
+  }
   return kCornerRadius;
 }
 
 int TabGroupStyle::GetTabGroupViewOverlap() const {
+  // Vertical tabs' group header simulates the tab, so we use the
+  // same margins that we use for tabs.
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return GetLayoutConstant(TOP_BAR_VERTICAL_PADDING) * 2;
+  }
+
   // For refresh the tab has an overlap value is 18. In order to have a margin
   // of 10 from the neighbor tabs this is required.
   return TabStyle::Get()->GetTabOverlap() - GetTabGroupOverlapAdjustment();
