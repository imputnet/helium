--- a/chrome/browser/ui/views/frame/multi_contents_resize_area.cc
+++ b/chrome/browser/ui/views/frame/multi_contents_resize_area.cc
@@ -24,8 +24,8 @@
 namespace {
 const int kHandleCornerRadius = 2;
 const int kHandleHeight = 24;
-const int kHandlePadding = 6;
-const int kHandleWidth = 4;
+const int kHandlePadding = 4;
+const int kHandleWidth = 2;
 }  // namespace
 
 DEFINE_CLASS_ELEMENT_IDENTIFIER_VALUE(MultiContentsResizeHandle,
--- a/chrome/browser/ui/views/frame/multi_contents_view.h
+++ b/chrome/browser/ui/views/frame/multi_contents_view.h
@@ -26,7 +26,6 @@ class MultiContentsDropTargetView;
 class MultiContentsResizeArea;
 class MultiContentsViewDelegate;
 class MultiContentsViewDropTargetController;
-class MultiContentsViewMiniToolbar;
 
 namespace content {
 class WebContents;
@@ -56,8 +55,6 @@ class MultiContentsView : public views::
     double end_width = 0;
   };
 
-  static constexpr int kSplitViewContentInset = 8;
-
   MultiContentsView(BrowserView* browser_view,
                     std::unique_ptr<MultiContentsViewDelegate> delegate);
   MultiContentsView(const MultiContentsView&) = delete;
@@ -159,10 +156,6 @@ class MultiContentsView : public views::
     return contents_container_views_[1]->contents_view();
   }
 
-  MultiContentsViewMiniToolbar* mini_toolbar_for_testing(int index) const {
-    return contents_container_views_[index]->mini_toolbar();
-  }
-
   MultiContentsBackgroundView* background_view_for_testing() const {
     return background_view_;
   }
@@ -277,10 +270,6 @@ class MultiContentsView : public views::
   // Nullopt if not currently resizing.
   std::optional<double> initial_start_width_on_resize_;
 
-  // Insets of the start and end contents view when in split view
-  gfx::Insets start_contents_view_inset_;
-  gfx::Insets end_contents_view_inset_;
-
   bool active_contents_view_highlighted_ = false;
 
   std::optional<int> min_contents_width_for_testing_ = std::nullopt;
--- a/chrome/browser/resources/tab_search/split_view/app.css
+++ b/chrome/browser/resources/tab_search/split_view/app.css
@@ -50,7 +50,7 @@ picture {
 
 .body {
   align-self: center;
-  color: var(--cr-primary-text-color);
+  color: var(--cr-secondary-text-color);
   font-size: 14px;
   font-weight: 400;
   line-height: 20px;
--- a/chrome/browser/ui/views/frame/multi_contents_view.cc
+++ b/chrome/browser/ui/views/frame/multi_contents_view.cc
@@ -26,7 +26,6 @@
 #include "chrome/browser/ui/views/frame/multi_contents_resize_area.h"
 #include "chrome/browser/ui/views/frame/multi_contents_view_delegate.h"
 #include "chrome/browser/ui/views/frame/multi_contents_view_drop_target_controller.h"
-#include "chrome/browser/ui/views/frame/multi_contents_view_mini_toolbar.h"
 #include "chrome/browser/ui/views/frame/scrim_view.h"
 #include "chrome/browser/ui/views/frame/top_container_background.h"
 #include "chrome/browser/ui/views/new_tab_footer/footer_web_view.h"
@@ -63,11 +62,7 @@ MultiContentsView::MultiContentsView(
     BrowserView* browser_view,
     std::unique_ptr<MultiContentsViewDelegate> delegate)
     : browser_view_(browser_view),
-      delegate_(std::move(delegate)),
-      start_contents_view_inset_(
-          gfx::Insets(kSplitViewContentInset).set_top(0).set_right(0)),
-      end_contents_view_inset_(
-          gfx::Insets(kSplitViewContentInset).set_top(0).set_left(0)) {
+      delegate_(std::move(delegate)) {
   SetLayoutManager(std::make_unique<views::DelegatingLayoutManager>(this));
   SetProperty(views::kElementIdentifierKey, kMultiContentsViewElementId);
 
@@ -329,11 +324,8 @@ void MultiContentsView::OnResize(int res
         std::make_optional(contents_container_views_[0]->size().width());
   }
   double total_width = contents_container_views_[0]->size().width() +
-                       contents_container_views_[0]->GetInsets().width() +
-                       contents_container_views_[1]->size().width() +
-                       contents_container_views_[1]->GetInsets().width();
+                       contents_container_views_[1]->size().width();
   double end_width = (initial_start_width_on_resize_.value() +
-                      contents_container_views_[0]->GetInsets().width() +
                       static_cast<double>(resize_amount));
 
   // If end_width is within the snap point widths, update to the snap point.
@@ -441,11 +433,6 @@ views::ProposedLayout MultiContentsView:
   gfx::Rect end_rect(resize_rect.top_right(),
                      gfx::Size(widths.end_width, available_space.height()));
 
-  if (IsInSplitView()) {
-    start_rect.Inset(start_contents_view_inset_);
-    end_rect.Inset(end_contents_view_inset_);
-  }
-
   layouts.child_layouts.emplace_back(contents_container_views_[0],
                                      contents_container_views_[0]->GetVisible(),
                                      start_rect);
@@ -580,8 +567,10 @@ MultiContentsView::ViewWidths MultiConte
     widths.resize_width = resize_area_->GetPreferredSize().width();
     widths.start_width =
         start_ratio_ * (available_space.width() - widths.resize_width);
+
+    // +1 to overcorrect for rounding errors that cause a gap on the very edge
     widths.end_width =
-        available_space.width() - widths.start_width - widths.resize_width;
+        available_space.width() - widths.start_width - widths.resize_width + 1;
   } else {
     CHECK(!contents_container_views_[1]->GetVisible());
     widths.start_width = available_space.width();
@@ -675,10 +664,6 @@ void MultiContentsView::SetShouldShowTop
     return;
   }
   contents_separators_.should_show_top = should_show;
-  start_contents_view_inset_.set_top(
-      should_show ? 0 : MultiContentsView::kSplitViewContentInset);
-  end_contents_view_inset_.set_top(
-      should_show ? 0 : MultiContentsView::kSplitViewContentInset);
 
   // This can be called during BrowserView layout, so protect against creating a
   // layout loop.
@@ -690,8 +675,6 @@ void MultiContentsView::SetShouldShowLea
     return;
   }
   contents_separators_.should_show_leading = should_show;
-  start_contents_view_inset_.set_left(
-      should_show ? 0 : MultiContentsView::kSplitViewContentInset);
 
   // This can be called during BrowserView layout, so protect against creating a
   // layout loop.
@@ -703,8 +686,6 @@ void MultiContentsView::SetShouldShowTra
     return;
   }
   contents_separators_.should_show_trailing = should_show;
-  end_contents_view_inset_.set_right(
-      should_show ? 0 : MultiContentsView::kSplitViewContentInset);
 
   // This can be called during BrowserView layout, so protect against creating a
   // layout loop.
--- a/chrome/browser/ui/views/frame/contents_container_view.cc
+++ b/chrome/browser/ui/views/frame/contents_container_view.cc
@@ -21,7 +21,6 @@
 #include "chrome/browser/ui/views/frame/contents_container_outline.h"
 #include "chrome/browser/ui/views/frame/contents_separator.h"
 #include "chrome/browser/ui/views/frame/contents_web_view.h"
-#include "chrome/browser/ui/views/frame/multi_contents_view_mini_toolbar.h"
 #include "chrome/browser/ui/views/frame/scrim_view.h"
 #include "chrome/browser/ui/views/frame/tab_modal_dialog_host.h"
 #include "chrome/browser/ui/views/frame/top_container_view.h"
@@ -55,10 +54,6 @@
 #endif
 
 namespace {
-constexpr float kContentCornerRadius = 6;
-constexpr gfx::RoundedCornersF kContentRoundedCorners{kContentCornerRadius};
-constexpr int kSplitViewContentPadding = 4;
-
 constexpr int kNewTabFooterSeparatorHeight = 1;
 constexpr int kNewTabFooterHeight = 56;
 }  // namespace
@@ -134,12 +129,6 @@ ContentsContainerView::ContentsContainer
   }
 #endif
 
-  mini_toolbar_ = AddChildView(std::make_unique<MultiContentsViewMiniToolbar>(
-      browser_view, contents_view_));
-
-  container_outline_ =
-      AddChildView(std::make_unique<ContentsContainerOutline>(mini_toolbar_));
-
   view_bounds_observer_.Observe(contents_view_);
 }
 
@@ -162,130 +151,11 @@ std::vector<views::View*> ContentsContai
 void ContentsContainerView::UpdateBorderAndOverlay(bool is_in_split,
                                                    bool is_active,
                                                    bool is_highlighted) {
-  is_in_split_ = is_in_split;
-
-  // The border, mini toolbar, and scrim should not be visible if not in a
-  // split.
-  if (!is_in_split) {
-    SetBorder(nullptr);
-    ClearBorderRoundedCorners();
-    mini_toolbar_->SetVisible(false);
-    container_outline_->SetVisible(false);
-    if (capture_contents_border_widget_) {
-      static_cast<ContentsCaptureBorderView*>(
-          capture_contents_border_widget_->GetContentsView())
-          ->SetIsInSplit(false);
-    }
-    return;
-  }
-
-  SetBorder(views::CreateEmptyBorder(gfx::Insets(
-      kSplitViewContentPadding + ContentsContainerOutline::kThickness)));
-  UpdateBorderRoundedCorners();
-
-  container_outline_->UpdateState(is_active, is_highlighted);
-  // Mini toolbar should only be visible for the inactive contents
-  // container view or both depending on configuration.
-  mini_toolbar_->UpdateState(is_active, is_highlighted);
-  if (capture_contents_border_widget_) {
-    static_cast<ContentsCaptureBorderView*>(
-        capture_contents_border_widget_->GetContentsView())
-        ->SetIsInSplit(true);
-  }
-}
-
-void ContentsContainerView::UpdateBorderRoundedCorners() {
-  // Update devtools rounded corners. Note, devtools exists behind the contents
-  // view so all devtools corners are rounded.
-  devtools_web_view_->holder()->SetCornerRadii(kContentRoundedCorners);
-  devtools_scrim_view_->SetRoundedCorners(kContentRoundedCorners);
-
-  const bool devtools_in_upper_left =
-      devtools_web_view_->GetVisible() &&
-      current_devtools_docked_placement_ == DevToolsDockedPlacement::kLeft;
-  const bool devtools_in_upper_right =
-      devtools_web_view_->GetVisible() &&
-      current_devtools_docked_placement_ == DevToolsDockedPlacement::kRight;
-  const bool devtools_in_lower_left =
-      devtools_web_view_->GetVisible() &&
-      (current_devtools_docked_placement_ == DevToolsDockedPlacement::kBottom ||
-       current_devtools_docked_placement_ == DevToolsDockedPlacement::kLeft);
-  const bool devtools_in_lower_right =
-      devtools_web_view_->GetVisible() &&
-      (current_devtools_docked_placement_ == DevToolsDockedPlacement::kBottom ||
-       current_devtools_docked_placement_ == DevToolsDockedPlacement::kRight);
-
-  const gfx::RoundedCornersF content_upper_rounded_corners =
-      gfx::RoundedCornersF{devtools_in_upper_left ? 0 : kContentCornerRadius,
-                           devtools_in_upper_right ? 0 : kContentCornerRadius,
-                           0, 0};
-  const gfx::RoundedCornersF content_lower_rounded_corners =
-      gfx::RoundedCornersF{0, 0,
-                           devtools_in_lower_right ? 0 : kContentCornerRadius,
-                           devtools_in_lower_left ? 0 : kContentCornerRadius};
-  const gfx::RoundedCornersF content_rounded_corners =
-      gfx::RoundedCornersF{devtools_in_upper_left ? 0 : kContentCornerRadius,
-                           devtools_in_upper_right ? 0 : kContentCornerRadius,
-                           devtools_in_lower_right ? 0 : kContentCornerRadius,
-                           devtools_in_lower_left ? 0 : kContentCornerRadius};
-
-  auto radii = new_tab_footer_view_ && new_tab_footer_view_->GetVisible()
-                   ? content_upper_rounded_corners
-                   : content_rounded_corners;
-
-  contents_view_->SetBackgroundRadii(radii);
-  contents_view_->holder()->SetCornerRadii(radii);
-  contents_scrim_view_->SetRoundedCorners(kContentRoundedCorners);
-
-  if (new_tab_footer_view_) {
-    new_tab_footer_view_->holder()->SetCornerRadii(
-        content_lower_rounded_corners);
-  }
-
-  if (actor_overlay_web_view_) {
-    // ActorOverlayWebView should use the same radii as the contents view since
-    // it acts as a full transparent layer directly over the main web content.
-    actor_overlay_web_view_->holder()->SetCornerRadii(radii);
-  }
-
-#if BUILDFLAG(ENABLE_GLIC)
-  if (glic_border_) {
-    glic_border_->SetRoundedCorners(content_rounded_corners);
-  }
-#endif
-}
-
-void ContentsContainerView::ClearBorderRoundedCorners() {
-  constexpr gfx::RoundedCornersF kNoRoundedCorners = gfx::RoundedCornersF{0};
-
-  devtools_web_view_->holder()->SetCornerRadii(kNoRoundedCorners);
-  devtools_scrim_view_->SetRoundedCorners(kNoRoundedCorners);
-
-  contents_view_->SetBackgroundRadii(kNoRoundedCorners);
-  contents_view_->holder()->SetCornerRadii(kNoRoundedCorners);
-
-  if (new_tab_footer_view_) {
-    new_tab_footer_view_->holder()->SetCornerRadii(kNoRoundedCorners);
-  }
-
-  contents_scrim_view_->SetRoundedCorners(kNoRoundedCorners);
-
-  if (actor_overlay_web_view_) {
-    actor_overlay_web_view_->holder()->SetCornerRadii(kNoRoundedCorners);
-  }
-
-#if BUILDFLAG(ENABLE_GLIC)
-  if (glic_border_) {
-    glic_border_->SetRoundedCorners(kNoRoundedCorners);
-  }
-#endif
+  SetBorder(nullptr);
 }
 
 void ContentsContainerView::ChildVisibilityChanged(View* child) {
-  if ((child == new_tab_footer_view_ || child == devtools_web_view_) &&
-      is_in_split_) {
-    UpdateBorderRoundedCorners();
-  }
+  return;
 }
 
 void ContentsContainerView::Layout(PassKey pass_key) {
@@ -299,9 +169,6 @@ void ContentsContainerView::Layout(PassK
 void ContentsContainerView::OnViewBoundsChanged(View* observed_view) {
   if (observed_view == contents_view_) {
     UpdateDevToolsDockedPlacement();
-    if (is_in_split_) {
-      UpdateBorderRoundedCorners();
-    }
   }
 }
 
@@ -414,7 +281,7 @@ void ContentsContainerView::CreateCaptur
 
   capture_contents_border_widget_->Init(std::move(params));
   auto contents_capture_border_view =
-      std::make_unique<ContentsCaptureBorderView>(mini_toolbar_);
+      std::make_unique<ContentsCaptureBorderView>(nullptr);
   capture_contents_border_widget_->SetContentsView(
       std::move(contents_capture_border_view));
   capture_contents_border_widget_->SetVisibilityChangedAnimationsEnabled(false);
@@ -568,30 +435,6 @@ views::ProposedLayout ContentsContainerV
         non_devtools_contents_bounds, size_bounds);
   }
 
-  if (mini_toolbar_) {
-    // |mini_toolbar_| should be offset in the bottom right corner, overlapping
-    // the outline. Shrink the available space by corner radius to ensure we
-    // have space to draw it at the corners.
-    views::SizeBounds available_space(width, height);
-    available_space.Enlarge(-ContentsContainerOutline::kCornerRadius,
-                            -ContentsContainerOutline::kCornerRadius);
-    gfx::Size mini_toolbar_size =
-        mini_toolbar_->GetPreferredSize(available_space);
-    const int offset_x = width - mini_toolbar_size.width();
-    const int offset_y = height - mini_toolbar_size.height();
-    const gfx::Rect mini_toolbar_rect =
-        gfx::Rect(offset_x, offset_y, mini_toolbar_size.width(),
-                  mini_toolbar_size.height());
-    layouts.child_layouts.emplace_back(
-        mini_toolbar_.get(), mini_toolbar_->GetVisible(), mini_toolbar_rect);
-  }
-
-  if (container_outline_) {
-    layouts.child_layouts.emplace_back(container_outline_.get(),
-                                       container_outline_->GetVisible(),
-                                       gfx::Rect(0, 0, width, height));
-  }
-
   layouts.host_size = gfx::Size(width, height);
   return layouts;
 }
--- a/chrome/browser/ui/views/frame/contents_container_view.h
+++ b/chrome/browser/ui/views/frame/contents_container_view.h
@@ -71,7 +71,6 @@ class ContentsContainerView : public vie
   std::vector<views::View*> GetAccessiblePanes();
 
   ContentsWebView* contents_view() { return contents_view_; }
-  MultiContentsViewMiniToolbar* mini_toolbar() { return mini_toolbar_; }
   ScrimView* contents_scrim_view() { return contents_scrim_view_; }
   views::WebView* devtools_web_view() { return devtools_web_view_; }
   ScrimView* devtools_scrim_view() { return devtools_scrim_view_; }
@@ -94,9 +93,6 @@ class ContentsContainerView : public vie
   enterprise_watermark::WatermarkView* watermark_view() {
     return watermark_view_;
   }
-  const ContentsContainerOutline* contents_outline_view() const {
-    return container_outline_;
-  }
   TabModalDialogHost* web_contents_modal_dialog_host() {
     return &web_contents_modal_dialog_host_;
   }
@@ -134,9 +130,6 @@ class ContentsContainerView : public vie
   // container that holds both contents_webview and devtools_webview.
   void UpdateDevToolsDockedPlacement();
 
-  void UpdateBorderRoundedCorners();
-  void ClearBorderRoundedCorners();
-
   // views::View:
   void ChildVisibilityChanged(View* child) override;
   void Layout(PassKey) override;
@@ -187,10 +180,6 @@ class ContentsContainerView : public vie
   // The glic browser view that renders around the web contents area.
   raw_ptr<glic::ContextSharingBorderView> glic_border_ = nullptr;
 
-  raw_ptr<MultiContentsViewMiniToolbar> mini_toolbar_ = nullptr;
-
-  raw_ptr<ContentsContainerOutline> container_outline_ = nullptr;
-
   std::unique_ptr<views::Widget> capture_contents_border_widget_;
   std::optional<gfx::Rect> dynamic_capture_content_border_bounds_;
 
--- a/chrome/browser/ui/views/frame/multi_contents_drop_target_view.cc
+++ b/chrome/browser/ui/views/frame/multi_contents_drop_target_view.cc
@@ -42,11 +42,9 @@
 
 namespace {
 
-constexpr float kInnerCornerRadius = 6;
-constexpr int kOuterPadding = 8;
 constexpr int kIconSize = 24;
-constexpr int kAnimationDurationMs = 450;
-constexpr gfx::Insets kInnerContainerMargins = gfx::Insets::VH(24, 10);
+constexpr gfx::Insets kInnerContainerMargins = gfx::Insets::VH(32, 10);
+constexpr int kAnimationDurationMs = 300;
 
 }  // namespace
 
@@ -61,17 +59,12 @@ MultiContentsDropTargetView::MultiConten
       ->SetOrientation(views::LayoutOrientation::kVertical)
       .SetMainAxisAlignment(views::LayoutAlignment::kCenter)
       .SetCrossAxisAlignment(views::LayoutAlignment::kCenter)
-      .SetInteriorMargin(gfx::Insets(kOuterPadding))
       .SetDefault(
           views::kFlexBehaviorKey,
           views::FlexSpecification(views::MinimumFlexSizeRule::kScaleToZero,
                                    views::MaximumFlexSizeRule::kUnbounded));
 
   auto inner_container = std::make_unique<views::View>();
-  inner_container->SetBackground(views::CreateLayerBasedRoundedBackground(
-      ui::kColorSysSurface3, gfx::RoundedCornersF(kInnerCornerRadius)));
-  inner_container->background()->SetInternalName(
-      "MultiContentsDropTargetView/InnerContainer");
 
   inner_container_layout_ =
       &inner_container->SetLayoutManager(std::make_unique<views::FlexLayout>())
@@ -90,13 +83,13 @@ MultiContentsDropTargetView::MultiConten
   icon_view_->SetPaintToLayer(ui::LAYER_TEXTURED);
   icon_view_->layer()->SetFillsBoundsOpaquely(false);
   icon_view_->SetImage(ui::ImageModel::FromVectorIcon(
-      kAddCircleIcon, ui::kColorSysPrimary, kIconSize));
+      kAddCircleIcon, ui::kColorMenuIcon, kIconSize));
 
   label_ = inner_container->AddChildView(std::make_unique<views::Label>(
       l10n_util::GetStringUTF16(IDS_SPLIT_VIEW_DRAG_ENTRYPOINT_LABEL)));
   label_->SetPaintToLayer(ui::LAYER_TEXTURED);
   label_->layer()->SetFillsBoundsOpaquely(false);
-  label_->SetEnabledColor(ui::kColorSysPrimary);
+  label_->SetEnabledColor(ui::kColorMenuIcon);
   label_->SetElideBehavior(gfx::NO_ELIDE);
   label_->SetSubpixelRenderingEnabled(false);
 
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -148,7 +148,6 @@
 #include "chrome/browser/ui/views/frame/multi_contents_view.h"
 #include "chrome/browser/ui/views/frame/multi_contents_view_delegate.h"
 #include "chrome/browser/ui/views/frame/multi_contents_view_drop_target_controller.h"
-#include "chrome/browser/ui/views/frame/multi_contents_view_mini_toolbar.h"
 #include "chrome/browser/ui/views/frame/scrim_view.h"
 #include "chrome/browser/ui/views/frame/shadow_overlay_view.h"
 #include "chrome/browser/ui/views/frame/tab_modal_dialog_host.h"
@@ -2345,10 +2344,6 @@ void BrowserView::UpdateToolbar(content:
   if (toolbar_) {
     toolbar_->Update(contents);
   }
-    for (ContentsContainerView* contents_container :
-         multi_contents_view_->contents_container_views()) {
-      contents_container->mini_toolbar()->UpdateContents();
-    }
 }
 
 bool BrowserView::UpdateToolbarSecurityState() {
--- a/chrome/browser/ui/tabs/split_tab_menu_model.cc
+++ b/chrome/browser/ui/tabs/split_tab_menu_model.cc
@@ -11,7 +11,6 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/notreached.h"
 #include "chrome/app/vector_icons/vector_icons.h"
-#include "chrome/browser/feedback/show_feedback_page.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_list.h"
@@ -130,16 +129,6 @@ SplitTabMenuModel::SplitTabMenuModel(Tab
   SetElementIdentifierAt(
       GetIndexOfCommandId(GetCommandIdInt(CommandId::kExitSplit)).value(),
       kExitSplitMenuItem);
-
-  // Only render feedback in the toolbar button menu.
-  if (menu_source == MenuSource::kToolbarButton &&
-      tab_strip_model->profile()->GetPrefs()->GetBoolean(
-          prefs::kUserFeedbackAllowed)) {
-    AddSeparator(ui::MenuSeparatorType::NORMAL_SEPARATOR);
-    AddItemWithStringIdAndIcon(GetCommandIdInt(CommandId::kSendFeedback),
-                               IDS_SPLIT_TAB_SEND_FEEDBACK,
-                               ui::ImageModel::FromVectorIcon(kReportIcon));
-  }
 }
 
 SplitTabMenuModel::~SplitTabMenuModel() = default;
@@ -221,9 +210,6 @@ void SplitTabMenuModel::ExecuteCommand(i
     case CommandId::kExitSplit:
       tab_strip_model_->RemoveSplit(split_id);
       break;
-    case CommandId::kSendFeedback:
-      SendFeedback();
-      break;
   }
 
   base::UmaHistogramEnumeration(
@@ -265,11 +251,3 @@ void SplitTabMenuModel::CloseTabAtIndex(
       index, TabCloseTypes::CLOSE_USER_GESTURE |
                  TabCloseTypes::CLOSE_CREATE_HISTORICAL_TAB);
 }
-
-void SplitTabMenuModel::SendFeedback() {
-  BrowserWindowInterface* const browser =
-      GetBrowserWithTabStripModel(tab_strip_model_);
-  CHECK(browser);
-  chrome::ShowFeedbackPage(browser, feedback::kFeedbackSourceSplitView, "", "",
-                           "split_view", "");
-}
--- a/chrome/browser/ui/tabs/split_tab_menu_model.h
+++ b/chrome/browser/ui/tabs/split_tab_menu_model.h
@@ -47,8 +47,7 @@ class SplitTabMenuModel : public ui::Sim
     kCloseStartTab,
     kCloseEndTab,
     kExitSplit,
-    kSendFeedback,
-    kMaxValue = kSendFeedback,
+    kMaxValue = kExitSplit,
   };
   // LINT.ThenChange(//tools/metrics/histograms/metadata/tab/enums.xml:SplitViewMenuEntry)
 
@@ -78,7 +77,6 @@ class SplitTabMenuModel : public ui::Sim
       split_tabs::SplitTabActiveLocation active_split_tab_location) const;
   split_tabs::SplitTabLayout GetSplitLayout() const;
   void CloseTabAtIndex(int index);
-  void SendFeedback();
 
   raw_ptr<TabStripModel> tab_strip_model_ = nullptr;
 
