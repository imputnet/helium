Audio Context fingerprinting mitigation, inspired by this patch in Cromite:
https://github.com/uazo/cromite/blob/b2824377/build/patches/AudioBuffer-AnalyserNode-fp-mitigations.patch

--- a/chrome/browser/helium_flag_choices.h
+++ b/chrome/browser/helium_flag_choices.h
@@ -28,6 +28,7 @@ namespace helium {
 
   constexpr const char kDisableEchCommandLine[] = "disable-ech";
   constexpr const char kCanvasNoiseCommandLine[] = "fingerprinting-canvas-noise";
+  constexpr const char kAudioContextJitterCommandLine[] = "fingerprinting-audio-context-jitter";
 
 }  // namespace helium
 
--- a/chrome/browser/helium_flag_entries.h
+++ b/chrome/browser/helium_flag_entries.h
@@ -20,4 +20,8 @@
      "Canvas fingerprint deception",
      "Enable noising pixels when the contents of a canvas are read back by a script. Bound to a browser session. Helium flag, Chromium feature.",
      kOsAll, FEATURE_VALUE_TYPE(fingerprinting_protection_interventions::features::kCanvasNoise)},
+    {helium::kAudioContextJitterCommandLine,
+     "Audio Context fingerprint deception",
+     "Adds small random jitter (Â±0.01%) to audio data to prevent fingerprinting. Helium flag.",
+     kOsAll, FEATURE_VALUE_TYPE(blink::features::kAudioContextJitter)},
 #endif  /* CHROME_BROWSER_HELIUM_FLAG_ENTRIES_H_ */
--- a/third_party/blink/common/features.cc
+++ b/third_party/blink/common/features.cc
@@ -19,6 +19,10 @@
 
 namespace blink::features {
 
+BASE_FEATURE(kAudioContextJitter,
+             "AudioContextJitter",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
 BASE_FEATURE(kDisableLinkDrag, "DisableLinkDrag", base::FEATURE_DISABLED_BY_DEFAULT);
 BASE_FEATURE(kReducedSystemInfo, "ReducedSystemInfo", base::FEATURE_DISABLED_BY_DEFAULT);
 BASE_FEATURE(kRemoveClientHints, "RemoveClientHints", base::FEATURE_DISABLED_BY_DEFAULT);
--- a/third_party/blink/public/common/features.h
+++ b/third_party/blink/public/common/features.h
@@ -22,6 +22,8 @@
 namespace blink {
 namespace features {
 
+BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kAudioContextJitter);
+
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kDisableLinkDrag);
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kReducedSystemInfo);
 BLINK_COMMON_EXPORT BASE_DECLARE_FEATURE(kRemoveClientHints);
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer.cc
@@ -32,6 +32,7 @@
 
 #include "base/compiler_specific.h"
 #include "base/containers/span.h"
+#include "third_party/blink/public/common/features.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_audio_buffer_options.h"
 #include "third_party/blink/renderer/modules/webaudio/base_audio_context.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
@@ -200,6 +201,20 @@ AudioBuffer::AudioBuffer(AudioBus* bus)
   }
 }
 
+void AudioBuffer::JitterAudioData() {
+  if (!base::FeatureList::IsEnabled(features::kAudioContextJitter)) {
+    return;
+  }
+
+  for (unsigned i = 0; i < channels_.size(); ++i) {
+    if (NotShared<DOMFloat32Array> channel = getChannelData(i)) {
+      for (float& sample : channel->AsSpan()) {
+        sample = BaseAudioContext::JitterAudioData(sample);
+      }
+    }
+  }
+}
+
 NotShared<DOMFloat32Array> AudioBuffer::getChannelData(
     unsigned channel_index,
     ExceptionState& exception_state) {
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer.h
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer.h
@@ -116,6 +116,8 @@ class MODULES_EXPORT AudioBuffer final :
 
   std::unique_ptr<SharedAudioBuffer> CreateSharedAudioBuffer();
 
+  void JitterAudioData();
+
  private:
   static DOMFloat32Array* CreateFloat32ArrayOrNull(
       uint32_t length,
--- a/third_party/blink/renderer/modules/webaudio/audio_context.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_context.cc
@@ -850,7 +850,12 @@ double AudioContext::baseLatency() const
   DCHECK_CALLED_ON_VALID_SEQUENCE(main_thread_sequence_checker_);
   DCHECK(destination());
 
-  return base_latency_;
+  if (!base::FeatureList::IsEnabled(features::kAudioContextJitter)) {
+    return base_latency_;
+  }
+
+  // Round to two decimal places
+  return std::round(base_latency_ * 100.0) / 100.0;
 }
 
 double AudioContext::outputLatency() const {
--- a/third_party/blink/renderer/modules/webaudio/base_audio_context.cc
+++ b/third_party/blink/renderer/modules/webaudio/base_audio_context.cc
@@ -774,6 +774,13 @@ LocalDOMWindow* BaseAudioContext::GetWin
   return To<LocalDOMWindow>(GetExecutionContext());
 }
 
+float BaseAudioContext::JitterAudioData(float data) {
+  float variation = base::RandFloat() * 0.0001f; // 1/10000
+  float sign = base::RandBool() ? 1.0f : -1.0f;
+
+  return data * (1.0f + variation * sign);
+}
+
 void BaseAudioContext::NotifySourceNodeStartedProcessing(AudioNode* node) {
   DCHECK(IsMainThread());
   DeferredTaskHandler::GraphAutoLocker locker(this);
--- a/third_party/blink/renderer/modules/webaudio/base_audio_context.h
+++ b/third_party/blink/renderer/modules/webaudio/base_audio_context.h
@@ -327,6 +327,8 @@ class MODULES_EXPORT BaseAudioContext
   // if the execution context does not exist.
   bool CheckExecutionContextAndThrowIfNecessary(ExceptionState&);
 
+  static float JitterAudioData(float data);
+
  protected:
   enum class ContextType { kRealtimeContext, kOfflineContext };
 
--- a/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
+++ b/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
@@ -375,6 +375,8 @@ void OfflineAudioContext::FireCompletion
       return;
     }
 
+    rendered_buffer->JitterAudioData();
+
     // Call the offline rendering completion event listener and resolve the
     // promise too.
     DispatchEvent(*OfflineAudioCompletionEvent::Create(rendered_buffer));
--- a/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
+++ b/third_party/blink/renderer/modules/webaudio/realtime_analyser.cc
@@ -32,6 +32,8 @@
 #include <complex>
 
 #include "base/compiler_specific.h"
+#include "third_party/blink/public/common/features.h"
+#include "third_party/blink/renderer/modules/webaudio/base_audio_context.h"
 #include "third_party/blink/renderer/platform/audio/audio_bus.h"
 #include "third_party/blink/renderer/platform/audio/audio_utilities.h"
 #include "third_party/blink/renderer/platform/audio/vector_math.h"
@@ -114,10 +116,15 @@ void RealtimeAnalyser::GetFloatFrequency
     const float* source = magnitude_buffer_.Data();
     float* destination = destination_array->Data();
 
+    const bool kJitterEnabled = base::FeatureList::IsEnabled(
+        features::kAudioContextJitter);
+
     for (unsigned i = 0; i < len; ++i) {
       const float linear_value = UNSAFE_TODO(source[i]);
       const double db_mag = audio_utilities::LinearToDecibels(linear_value);
-      UNSAFE_TODO(destination[i]) = static_cast<float>(db_mag);
+      auto db_value = static_cast<float>(db_mag);
+      UNSAFE_TODO(destination[i]) = kJitterEnabled ?
+          BaseAudioContext::JitterAudioData(db_value) : db_value;
     }
   }
 }
@@ -149,15 +156,22 @@ void RealtimeAnalyser::GetByteFrequencyD
     const float* source = magnitude_buffer_.Data();
     unsigned char* destination = destination_array->Data();
 
+    const bool kJitterEnabled = base::FeatureList::IsEnabled(
+        features::kAudioContextJitter);
+
     for (unsigned i = 0; i < len; ++i) {
       const float linear_value = UNSAFE_TODO(source[i]);
       const double db_mag = audio_utilities::LinearToDecibels(linear_value);
 
       // The range m_minDecibels to m_maxDecibels will be scaled to byte values
       // from 0 to UCHAR_MAX.
-      const double scaled_value =
+      double scaled_value =
           UCHAR_MAX * (db_mag - min_decibels) * range_scale_factor;
 
+      if (kJitterEnabled) {
+        scaled_value = BaseAudioContext::JitterAudioData(scaled_value);
+      }
+
       // Clip to valid range.
       UNSAFE_TODO(destination[i]) =
           static_cast<unsigned char>(ClampTo(scaled_value, 0, UCHAR_MAX));
@@ -182,12 +196,19 @@ void RealtimeAnalyser::GetFloatTimeDomai
 
     const unsigned write_index = GetWriteIndex();
 
+    const bool kJitterEnabled = base::FeatureList::IsEnabled(
+        features::kAudioContextJitter);
+
     for (unsigned i = 0; i < len; ++i) {
       // Buffer access is protected due to modulo operation.
       float value = UNSAFE_TODO(
           input_buffer[(i + write_index - fft_size + kInputBufferSize) %
                        kInputBufferSize]);
 
+      if (kJitterEnabled) {
+        value = BaseAudioContext::JitterAudioData(value);
+      }
+
       UNSAFE_TODO(destination[i]) = value;
     }
   }
@@ -209,12 +230,19 @@ void RealtimeAnalyser::GetByteTimeDomain
 
     const unsigned write_index = GetWriteIndex();
 
+    const bool kJitterEnabled = base::FeatureList::IsEnabled(
+        features::kAudioContextJitter);
+
     for (unsigned i = 0; i < len; ++i) {
       // Buffer access is protected due to modulo operation.
-      const float value = UNSAFE_TODO(
+      float value = UNSAFE_TODO(
           input_buffer[(i + write_index - fft_size + kInputBufferSize) %
                        kInputBufferSize]);
 
+      if (kJitterEnabled) {
+        value = BaseAudioContext::JitterAudioData(value);
+      }
+
       // Scale from nominal -1 -> +1 to unsigned byte.
       const double scaled_value = 128 * (value + 1);
 
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -585,7 +585,6 @@
       // AudioContext.playoutStats interface.
       // https://chromestatus.com/feature/5172818344148992
       name: "AudioContextPlayoutStats",
-      origin_trial_feature_name: "AudioContextPlayoutStats",
       status: "experimental",
     },
     {
